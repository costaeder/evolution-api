diff --git a/BuildImage.ps1 b/BuildImage.ps1
deleted file mode 100644
index 1b3490fd..00000000
--- a/BuildImage.ps1
+++ /dev/null
@@ -1,11 +0,0 @@
-(Get-ECRLoginCommand).Password | docker login --username AWS --password-stdin 130811782740.dkr.ecr.us-east-2.amazonaws.com
-#
-
-$ErrorActionPreference = "Stop"
- 
- 
- 
-
-docker build -t evolution -f .\Dockerfile .
-docker tag evolution:latest 130811782740.dkr.ecr.us-east-2.amazonaws.com/evolution
-docker push 130811782740.dkr.ecr.us-east-2.amazonaws.com/evolution
\ No newline at end of file
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2d316041..5874cab0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,9 @@
+# 2.2.4 (2025-02-24)
+
+### Changed
+
+* Treat `@lid` JIDs as contacts in Chatwoot ignore checks
+
 # 2.2.3 (2025-02-03 11:52)
 
 ### Fixed
diff --git a/Dockerfile b/Dockerfile
index c6abb936..ca61b39a 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -3,7 +3,7 @@ FROM node:20-alpine AS builder
 RUN apk update && \
     apk add git ffmpeg wget curl bash openssl
 
-LABEL version="2.2.3.24" description="Api to control whatsapp features through http requests." 
+LABEL version="2.2.3" description="Api to control whatsapp features through http requests." 
 LABEL maintainer="Davidson Gomes" git="https://github.com/DavidsonGomes"
 LABEL contact="contato@atendai.com"
 
diff --git a/README.md b/README.md
index 93197499..27b3ec5f 100644
--- a/README.md
+++ b/README.md
@@ -47,6 +47,7 @@ Evolution API supports various integrations to enhance its functionality. Below
 
 - [Chatwoot](https://www.chatwoot.com/):
   - Direct integration with Chatwoot for handling customer service for your business.
+  - History import now supports Linked IDs, preserving JIDs ending in `@lid`.
 
 - [RabbitMQ](https://www.rabbitmq.com/):
   - Receive events from the Evolution API via RabbitMQ.
diff --git a/package-lock.json b/package-lock.json
index 5219a85a..83bd4d16 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,12 +1,12 @@
 {
   "name": "evolution-api",
-  "version": "2.2.3.24",
+  "version": "2.2.3",
   "lockfileVersion": 3,
   "requires": true,
   "packages": {
     "": {
       "name": "evolution-api",
-      "version": "2.2.3.24",
+      "version": "2.2.3",
       "license": "Apache-2.0",
       "dependencies": {
         "@adiwajshing/keyed-db": "^0.2.4",
@@ -55,7 +55,6 @@
         "sharp": "^0.32.6",
         "socket.io": "^4.8.1",
         "socket.io-client": "^4.8.1",
-        "source-map-support": "^0.5.21",
         "tsup": "^8.3.5"
       },
       "devDependencies": {
@@ -10849,6 +10848,7 @@
       "version": "0.6.1",
       "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
       "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
+      "dev": true,
       "engines": {
         "node": ">=0.10.0"
       }
@@ -10857,6 +10857,7 @@
       "version": "0.5.21",
       "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
       "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
+      "dev": true,
       "dependencies": {
         "buffer-from": "^1.0.0",
         "source-map": "^0.6.0"
diff --git a/package.json b/package.json
index 8a654f95..7e948028 100644
--- a/package.json
+++ b/package.json
@@ -1,13 +1,13 @@
 {
   "name": "evolution-api",
-  "version": "2.2.3.24",
+  "version": "2.2.3",
   "description": "Rest api for communication with WhatsApp",
   "main": "./dist/main.js",
   "type": "commonjs",
   "scripts": {
     "build": "tsc --noEmit && tsup",
     "start": "tsnd -r tsconfig-paths/register --files --transpile-only ./src/main.ts",
-    "start:prod": "node --enable-source-maps -r source-map-support/register dist/main.js",
+    "start:prod": "node dist/main",
     "dev:server": "tsnd -r tsconfig-paths/register --files --transpile-only --respawn --ignore-watch node_modules ./src/main.ts",
     "test": "tsnd -r tsconfig-paths/register --files --transpile-only --respawn --ignore-watch node_modules ./test/all.test.ts",
     "lint": "eslint --fix --ext .ts src",
@@ -95,7 +95,6 @@
     "sharp": "^0.32.6",
     "socket.io": "^4.8.1",
     "socket.io-client": "^4.8.1",
-    "source-map-support": "^0.5.21",
     "tsup": "^8.3.5"
   },
   "devDependencies": {
diff --git a/src/api/controllers/chat.controller.ts b/src/api/controllers/chat.controller.ts
index 5b715924..207d8ba5 100644
--- a/src/api/controllers/chat.controller.ts
+++ b/src/api/controllers/chat.controller.ts
@@ -19,43 +19,11 @@ import { Query } from '@api/repository/repository.service';
 import { WAMonitoringService } from '@api/services/monitor.service';
 import { Contact, Message, MessageUpdate } from '@prisma/client';
 
-class SimpleMutex {
-  private locked = false;
-  private waiting: Array<() => void> = [];
-
-  async acquire(): Promise<void> {
-    if (this.locked) {
-      await new Promise<void>(resolve => this.waiting.push(resolve));
-    }
-    this.locked = true;
-  }
-
-  release(): void {
-    const next = this.waiting.shift();
-    if (next) next();
-    else this.locked = false;
-  }
-
-  async runExclusive<T>(fn: () => Promise<T>): Promise<T> {
-    await this.acquire();
-    try {
-      return await fn();
-    } finally {
-      this.release();
-    }
-  }
-}
-
-
 export class ChatController {
   constructor(private readonly waMonitor: WAMonitoringService) {}
 
-  private static whatsappNumberMutex = new SimpleMutex();
-
   public async whatsappNumber({ instanceName }: InstanceDto, data: WhatsAppNumberDto) {
-    return await ChatController.whatsappNumberMutex.runExclusive(async () => {
-      return this.waMonitor.waInstances[instanceName].whatsappNumber(data);
-    });
+    return await this.waMonitor.waInstances[instanceName].whatsappNumber(data);
   }
 
   public async readMessage({ instanceName }: InstanceDto, data: ReadMessageDto) {
diff --git a/src/api/integrations/channel/evolution/evolution.channel.service.ts b/src/api/integrations/channel/evolution/evolution.channel.service.ts
index dba02751..edd45c14 100644
--- a/src/api/integrations/channel/evolution/evolution.channel.service.ts
+++ b/src/api/integrations/channel/evolution/evolution.channel.service.ts
@@ -202,6 +202,9 @@ export class EvolutionStartupService extends ChannelStartupService {
           data: messageRaw,
         });
 
+
+        this.logger.verbose('Message received: ');
+
         await this.updateContact({
           remoteJid: messageRaw.key.remoteJid,
           pushName: messageRaw.pushName,
@@ -214,6 +217,35 @@ export class EvolutionStartupService extends ChannelStartupService {
   }
 
   private async updateContact(data: { remoteJid: string; pushName?: string; profilePicUrl?: string }) {
+    const contact = await this.prismaRepository.contact.findFirst({
+      where: { instanceId: this.instanceId, remoteJid: data.remoteJid },
+    });
+
+    if (contact) {
+      const contactRaw: any = {
+        remoteJid: data.remoteJid,
+        pushName: data?.pushName,
+        instanceId: this.instanceId,
+        profilePicUrl: data?.profilePicUrl,
+      };
+
+      this.sendDataWebhook(Events.CONTACTS_UPDATE, contactRaw);
+
+      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
+        await this.chatwootService.eventWhatsapp(
+          Events.CONTACTS_UPDATE,
+          { instanceName: this.instance.name, instanceId: this.instanceId },
+          contactRaw,
+        );
+      }
+
+      await this.prismaRepository.contact.updateMany({
+        where: { remoteJid: contact.remoteJid, instanceId: this.instanceId },
+        data: contactRaw,
+      });
+      return;
+    }
+
     const contactRaw: any = {
       remoteJid: data.remoteJid,
       pushName: data?.pushName,
diff --git a/src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts b/src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts
index c1026a84..1154daf8 100644
--- a/src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts
+++ b/src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts
@@ -60,6 +60,7 @@ import { CacheService } from '@api/services/cache.service';
 import { ChannelStartupService } from '@api/services/channel.service';
 import { Events, MessageSubtype, TypeMediaMessage, wa } from '@api/types/wa.types';
 import { CacheEngine } from '@cache/cacheengine';
+import { Semaphore } from 'async-mutex';
 import {
   CacheConf,
   Chatwoot,
@@ -136,7 +137,7 @@ import mimeTypes from 'mime-types';
 import NodeCache from 'node-cache';
 import cron from 'node-cron';
 import { release } from 'os';
-import path, { join } from 'path';
+import { join } from 'path';
 import P from 'pino';
 import qrcode, { QRCodeToDataURLOptions } from 'qrcode';
 import qrcodeTerminal from 'qrcode-terminal';
@@ -146,14 +147,10 @@ import { v4 } from 'uuid';
 
 import { useVoiceCallsBaileys } from './voiceCalls/useVoiceCallsBaileys';
 
-
-type DownloadMediaMessageContext = {
-  reuploadRequest: (msg: WAMessage) => Promise<WAMessage>;
-  logger: P.Logger;
-};
-
 const groupMetadataCache = new CacheService(new CacheEngine(configService, 'groups').getEngine());
 
+const contactsUpsertSemaphore = new Semaphore(4);
+
 // Adicione a função getVideoDuration no início do arquivo
 async function getVideoDuration(input: Buffer | string | Readable): Promise<number> {
   const MediaInfoFactory = (await import('mediainfo.js')).default;
@@ -384,7 +381,7 @@ export class BaileysStartupService extends ChannelStartupService {
       qrcodeTerminal.generate(qr, { small: true }, (qrcode) =>
         this.logger.log(
           `\n{ instance: ${this.instance.name} pairingCode: ${this.instance.qrcode.pairingCode}, qrcodeCount: ${this.instance.qrcode.count} }\n` +
-            qrcode,
+          qrcode,
         ),
       );
 
@@ -754,30 +751,40 @@ export class BaileysStartupService extends ChannelStartupService {
 
   private readonly chatHandle = {
     'chats.upsert': async (chats: Chat[]) => {
+      const [slot, release] = await contactsUpsertSemaphore.acquire();
+
+      this.logger.verbose(`Acquired slot ${slot} to update ${chats.length} chats.`);
+
       const existingChatIds = await this.prismaRepository.chat.findMany({
         where: { instanceId: this.instanceId },
         select: { remoteJid: true },
       });
 
-      const existingChatIdSet = new Set(existingChatIds.map((chat) => chat.remoteJid));
 
-      const chatsToInsert = chats
-        .filter((chat) => !existingChatIdSet?.has(chat.id))
-        .map((chat) => ({
-          remoteJid: chat.id,
-          instanceId: this.instanceId,
-          name: chat.name,
-          unreadMessages: chat.unreadCount !== undefined ? chat.unreadCount : 0,
-        }));
+      try {
 
-      this.sendDataWebhook(Events.CHATS_UPSERT, chatsToInsert);
+        const existingChatIdSet = new Set(existingChatIds.map((chat) => chat.remoteJid));
 
-      if (chatsToInsert.length > 0) {
-        if (this.configService.get<Database>('DATABASE').SAVE_DATA.CHATS)
-          await this.prismaRepository.chat.createMany({
-            data: chatsToInsert,
-            skipDuplicates: true,
-          });
+        const chatsToInsert = chats
+          .filter((chat) => !existingChatIdSet?.has(chat.id))
+          .map((chat) => ({
+            remoteJid: chat.id,
+            instanceId: this.instanceId,
+            name: chat.name,
+            unreadMessages: chat.unreadCount !== undefined ? chat.unreadCount : 0,
+          }));
+
+        this.sendDataWebhook(Events.CHATS_UPSERT, chatsToInsert);
+
+        if (chatsToInsert.length > 0) {
+          if (this.configService.get<Database>('DATABASE').SAVE_DATA.CHATS)
+            await this.prismaRepository.chat.createMany({
+              data: chatsToInsert,
+              skipDuplicates: true,
+            });
+        }
+      } finally {
+        release();
       }
     },
 
@@ -790,21 +797,30 @@ export class BaileysStartupService extends ChannelStartupService {
         }
       >[],
     ) => {
-      const chatsRaw = chats.map((chat) => {
-        return { remoteJid: chat.id, instanceId: this.instanceId };
-      });
 
-      this.sendDataWebhook(Events.CHATS_UPDATE, chatsRaw);
+      const [slot, release] = await contactsUpsertSemaphore.acquire();
+      this.logger.verbose(`Acquired slot ${slot} to update ${chats.length} chats.`);
 
-      for (const chat of chats) {
-        await this.prismaRepository.chat.updateMany({
-          where: {
-            instanceId: this.instanceId,
-            remoteJid: chat.id,
-            name: chat.name,
-          },
-          data: { remoteJid: chat.id },
+      try {
+
+        const chatsRaw = chats.map((chat) => {
+          return { remoteJid: chat.id, instanceId: this.instanceId };
         });
+
+        this.sendDataWebhook(Events.CHATS_UPDATE, chatsRaw);
+
+        for (const chat of chats) {
+          await this.prismaRepository.chat.updateMany({
+            where: {
+              instanceId: this.instanceId,
+              remoteJid: chat.id,
+              name: chat.name,
+            },
+            data: { remoteJid: chat.id },
+          });
+        }
+      } finally {
+        release();
       }
     },
 
@@ -821,8 +837,22 @@ export class BaileysStartupService extends ChannelStartupService {
   };
 
   private readonly contactHandle = {
+
     'contacts.upsert': async (contacts: Contact[]) => {
+
+     
+
+     
+
       try {
+
+        if (contacts.length > 500) {
+          this.logger.error(`Muitos contatos sendo atualizados de uma vez. Impedindo a execução.`);
+          return;
+        }
+
+        this.logger.verbose(`Atualizando. ${contacts.length} contatos.`);
+
         const contactsRaw: any = contacts.map((contact) => ({
           remoteJid: contact.id,
           pushName: contact?.name || contact?.verifiedName || contact.id.split('@')[0],
@@ -879,32 +909,43 @@ export class BaileysStartupService extends ChannelStartupService {
           this.sendDataWebhook(Events.CONTACTS_UPDATE, updatedContacts);
           await Promise.all(
             updatedContacts.map(async (contact) => {
-              const update = this.prismaRepository.contact.updateMany({
-                where: { remoteJid: contact.remoteJid, instanceId: this.instanceId },
-                data: {
-                  profilePicUrl: contact.profilePicUrl,
-                },
-              });
 
-              if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
-                const instance = { instanceName: this.instance.name, instanceId: this.instance.id };
+              const [slot, release] = await contactsUpsertSemaphore.acquire();
 
-                const findParticipant = await this.chatwootService.findContact(
-                  instance,
-                  contact.remoteJid.split('@')[0],
-                );
+              this.logger.verbose(`Acquired slot ${slot} to upsert ${contacts.length} contacts.`);
 
-                if (!findParticipant) {
-                  return;
-                }
+              try {
 
-                this.chatwootService.updateContact(instance, findParticipant.id, {
-                  name: contact.pushName,
-                  avatar_url: contact.profilePicUrl,
+                const update = this.prismaRepository.contact.updateMany({
+                  where: { remoteJid: contact.remoteJid, instanceId: this.instanceId },
+                  data: {
+                    profilePicUrl: contact.profilePicUrl,
+                  },
                 });
-              }
 
-              return update;
+                if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
+                  const instance = { instanceName: this.instance.name, instanceId: this.instance.id };
+
+                  const findParticipant = await this.chatwootService.findContact(
+                    instance,
+                    contact.remoteJid.split('@')[0],
+                  );
+
+                  if (!findParticipant) {
+                    return;
+                  }
+
+                  this.chatwootService.updateContact(instance, findParticipant.id, {
+                    name: contact.pushName,
+                    avatar_url: contact.profilePicUrl,
+                  });
+                }
+
+                return update;
+              } finally {
+                release();
+              }
+              
             }),
           );
         }
@@ -912,9 +953,16 @@ export class BaileysStartupService extends ChannelStartupService {
         console.error(error);
         this.logger.error(`Error: ${error.message}`);
       }
+     
     },
 
     'contacts.update': async (contacts: Partial<Contact>[]) => {
+
+      if (contacts.length > 300) {
+        this.logger.error(`Muitos contatos sendo atualizados de uma vez. Impedindo a execução.`);
+        return;
+      }
+
       const contactsRaw: {
         remoteJid: string;
         pushName?: string;
@@ -1025,18 +1073,18 @@ export class BaileysStartupService extends ChannelStartupService {
 
         const messagesRepository: Set<string> = new Set(
           chatwootImport.getRepositoryMessagesCache(instance) ??
-            (
-              await this.prismaRepository.message.findMany({
-                select: { key: true },
-                where: { instanceId: this.instanceId },
-              })
-            ).map((message) => {
-              const key = message.key as {
-                id: string;
-              };
-
-              return key.id;
-            }),
+          (
+            await this.prismaRepository.message.findMany({
+              select: { key: true },
+              where: { instanceId: this.instanceId },
+            })
+          ).map((message) => {
+            const key = message.key as {
+              id: string;
+            };
+
+            return key.id;
+          }),
         );
 
         if (chatwootImport.getRepositoryMessagesCache(instance) === null) {
@@ -1296,25 +1344,13 @@ export class BaileysStartupService extends ChannelStartupService {
                     true,
                   );
 
-                  const { buffer, mediaType, fileName: originalName, size } = media;
-                  const mimetype = mimeTypes.lookup(originalName).toString();
-
-                  // calcula a extensão (usa a do nome original ou, em último caso, a do mimetype)
-                  const ext = path.extname(originalName) || `.${mimeTypes.extension(mimetype)}`;
-
-                  // força usar sempre o id da mensagem como nome de arquivo
-                  const fileName = `${received.key.id}${ext}`;
-
-                  const fullName = join(
-                    this.instance.id,
-                    received.key.remoteJid,
-                    mediaType,
-                    fileName,
-                  );
-
+                  const { buffer, mediaType, fileName, size } = media;
+                  const mimetype = mimeTypes.lookup(fileName).toString();
+                  const fullName = join(`${this.instance.id}`, received.key.remoteJid, mediaType, fileName);
                   await s3Service.uploadFile(fullName, buffer, size.fileLength?.low, {
                     'Content-Type': mimetype,
                   });
+
                   await this.prismaRepository.media.create({
                     data: {
                       messageId: msg.id,
@@ -1440,11 +1476,6 @@ export class BaileysStartupService extends ChannelStartupService {
           continue;
         }
 
-        if (!key.id) {
-          console.warn(`Mensagem sem key.id, pulando update: ${JSON.stringify(key)}`);
-          continue;
-        }
-
         if (status[update.status] === 'READ' && key.fromMe) {
           if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
             this.chatwootService.eventWhatsapp(
@@ -1532,7 +1563,7 @@ export class BaileysStartupService extends ChannelStartupService {
             remoteJid: key.remoteJid,
             fromMe: key.fromMe,
             participant: key?.remoteJid,
-            status: status[update.status]?? 'UNKNOWN',
+            status: status[update.status],
             pollUpdates,
             instanceId: this.instanceId,
           };
@@ -2264,12 +2295,20 @@ export class BaileysStartupService extends ChannelStartupService {
         }
       }
 
+
+
+
       if (this.configService.get<Database>('DATABASE').SAVE_DATA.NEW_MESSAGE) {
         const msg = await this.prismaRepository.message.create({
           data: messageRaw,
         });
 
+        
+
         if (isMedia && this.configService.get<S3>('S3').ENABLE) {
+
+          this.logger.verbose(`Processing media message`);
+
           try {
             const message: any = messageRaw;
             const media = await this.getBase64FromMediaMessage(
@@ -2291,10 +2330,14 @@ export class BaileysStartupService extends ChannelStartupService {
               fileName,
             );
 
-            await s3Service.uploadFile(fullName, buffer, size.fileLength?.low, {
+            this.logger.verbose(`Uploading file to S3`);
+
+           let result =  await s3Service.uploadFile(fullName, buffer, size.fileLength?.low, {
               'Content-Type': mimetype,
             });
 
+            this.logger.verbose(`File uploaded to S3 ${JSON.stringify(result)}`);
+
             await this.prismaRepository.media.create({
               data: {
                 messageId: msg.id,
@@ -2307,6 +2350,8 @@ export class BaileysStartupService extends ChannelStartupService {
 
             const mediaUrl = await s3Service.getObjectUrl(fullName);
 
+            this.logger.info(`Media URL on S3 ${mediaUrl}`);
+
             messageRaw.message.mediaUrl = mediaUrl;
 
             await this.prismaRepository.message.update({
@@ -3624,145 +3669,94 @@ export class BaileysStartupService extends ChannelStartupService {
     }
   }
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  public async getBase64FromMediaMessage(
-    data: getBase64FromMediaMessageDto,
-    getBuffer = false
-  ) {
+  public async getBase64FromMediaMessage(data: getBase64FromMediaMessageDto, getBuffer = false) {
     try {
       const m = data?.message;
       const convertToMp4 = data?.convertToMp4 ?? false;
-  
-      // Se já houver propriedade "message", usa-o; senão, busca-o via key
-      const msg: proto.IWebMessageInfo = m?.message
-        ? m
-        : (await this.getMessage(m.key, true)) as proto.IWebMessageInfo;
+
+      const msg = m?.message ? m : ((await this.getMessage(m.key, true)) as proto.IWebMessageInfo);
+
       if (!msg) {
-        throw new Error('Message not found');
+        throw 'Message not found';
       }
-  
-      // Verifica se o conteúdo está aninhado em algum subtipo (ex.: extendedTextMessage)
+
       for (const subtype of MessageSubtype) {
         if (msg.message[subtype]) {
           msg.message = msg.message[subtype].message;
-          break;
         }
       }
-  
-      // Identifica o tipo de mídia contido na mensagem
+
       let mediaMessage: any;
-      let mediaType = '';
+      let mediaType: string;
+
       for (const type of TypeMediaMessage) {
-        if (msg.message[type]) {
-          mediaMessage = msg.message[type];
+        mediaMessage = msg.message[type];
+        if (mediaMessage) {
           mediaType = type;
           break;
         }
       }
+
       if (!mediaMessage) {
-        throw new Error('The message is not of the media type');
+        throw 'The message is not of the media type';
       }
-  
-      // Se o mediaKey for um objeto, forçamos a serialização para “descolar” possíveis problemas
-      if (typeof mediaMessage.mediaKey === 'object') {
+
+      if (typeof mediaMessage['mediaKey'] === 'object') {
         msg.message = JSON.parse(JSON.stringify(msg.message));
       }
-  
-      // Define um contexto completo conforme DownloadMediaMessageContext
-      const downloadContext: DownloadMediaMessageContext = {
-        logger: P({ level: 'error' }),
-        reuploadRequest: async (message: WAMessage): Promise<WAMessage> => {
-          // Aqui chamamos explicitamente o método que atualiza a mídia;
-          // Se o método updateMediaMessage não retornar nada (void), retornamos a própria mensagem.
-          const updatedMsg = await this.client.updateMediaMessage(message);
-          return updatedMsg ? updatedMsg : message;
+
+      const buffer = await downloadMediaMessage(
+        { key: msg?.key, message: msg?.message },
+        'buffer',
+        {},
+        {
+          logger: P({ level: 'error' }) as any,
+          reuploadRequest: this.client.updateMediaMessage,
         },
-      };
-  
-      let buffer: Buffer;
-      try {
-        // Tenta baixar a mídia usando o contexto com reuploadRequest
-        buffer = (await downloadMediaMessage(
-          { key: msg.key, message: msg.message },
-          'buffer',
-          {},
-          downloadContext
-        )) as Buffer;
-      } catch (initialError) {
-        this.logger.warn(
-          'Initial downloadMediaMessage failed, updating media and retrying...'
-        );
-        // Se a tentativa falhar (possivelmente por URL expirada), atualiza a mídia e refaz o download
-        await this.client.updateMediaMessage(msg);
-        buffer = (await downloadMediaMessage(
-          { key: msg.key, message: msg.message },
-          'buffer',
-          {},
-          { logger: P({ level: 'error' }), reuploadRequest: async (m: WAMessage) => m } // Contexto “vazio”
-        )) as Buffer;
-      }
-  
+      );
       const typeMessage = getContentType(msg.message);
-      const ext = mimeTypes.extension(mediaMessage?.mimetype);
-      const fileName =
-        mediaMessage?.fileName || `${msg.key.id}.${ext}` || `${v4()}.${ext}`;
-  
-      // Se for áudio e for pedido converter para mp4, processa a conversão
+
+      const ext = mimeTypes.extension(mediaMessage?.['mimetype']);
+      const fileName = mediaMessage?.['fileName'] || `${msg.key.id}.${ext}` || `${v4()}.${ext}`;
+
       if (convertToMp4 && typeMessage === 'audioMessage') {
         try {
-          const converted = await this.processAudioMp4(buffer.toString('base64'));
-          if (Buffer.isBuffer(converted)) {
-            return {
+          const convert = await this.processAudioMp4(buffer.toString('base64'));
+
+          if (Buffer.isBuffer(convert)) {
+            const result = {
               mediaType,
               fileName,
-              caption: mediaMessage.caption,
+              caption: mediaMessage['caption'],
               size: {
-                fileLength: mediaMessage.fileLength,
-                height: mediaMessage.height,
-                width: mediaMessage.width,
+                fileLength: mediaMessage['fileLength'],
+                height: mediaMessage['height'],
+                width: mediaMessage['width'],
               },
               mimetype: 'audio/mp4',
-              base64: converted.toString('base64'),
-              buffer: getBuffer ? converted : null,
+              base64: convert.toString('base64'),
+              buffer: getBuffer ? convert : null,
             };
+
+            return result;
           }
-        } catch (convertError) {
+        } catch (error) {
           this.logger.error('Error converting audio to mp4:');
-          this.logger.error(convertError);
+          this.logger.error(error);
           throw new BadRequestException('Failed to convert audio to MP4');
         }
       }
-  
-      // Retorna os dados da mídia
+
       return {
         mediaType,
         fileName,
-        caption: mediaMessage.caption,
+        caption: mediaMessage['caption'],
         size: {
-          fileLength: mediaMessage.fileLength,
-          height: mediaMessage.height,
-          width: mediaMessage.width,
+          fileLength: mediaMessage['fileLength'],
+          height: mediaMessage['height'],
+          width: mediaMessage['width'],
         },
-        mimetype: mediaMessage.mimetype,
+        mimetype: mediaMessage['mimetype'],
         base64: buffer.toString('base64'),
         buffer: getBuffer ? buffer : null,
       };
@@ -3773,19 +3767,6 @@ export class BaileysStartupService extends ChannelStartupService {
     }
   }
 
-
-
-
-
-
-
-
-
-
-
-
-
-
   public async fetchPrivacySettings() {
     const privacy = await this.client.fetchPrivacySettings();
 
@@ -4493,41 +4474,29 @@ export class BaileysStartupService extends ChannelStartupService {
     return unreadMessages;
   }
 
-  private async addLabel(
-    labelId: string,
-    instanceId: string,
-    chatId: string
-  ): Promise<void> {
-    try {
-      await this.prismaRepository.$executeRawUnsafe(
-        `UPDATE "Chat"
-           SET "labels" = (
-             SELECT to_jsonb(array_agg(DISTINCT elem))
-             FROM (
-               SELECT jsonb_array_elements_text("Chat".labels) AS elem
-               UNION
-               SELECT $1::text AS elem
-             ) sub
-           ),
-           "updatedAt" = NOW()
-         WHERE "instanceId" = $2
-           AND "remoteJid"  = $3;`,
-        labelId,
-        instanceId,
-        chatId
-      );
-    } catch (err: unknown) {
-      // Não deixa quebrar nada: registra e segue em frente
-      const msg =
-        err instanceof Error ? err.message : JSON.stringify(err);
-      // Use console.warn para evitar conflito de assinatura de método
-      console.warn(
-        `Failed to add label ${labelId} to chat ${chatId}@${instanceId}: ${msg}`
-      );
-    }
+  private async addLabel(labelId: string, instanceId: string, chatId: string) {
+    const id = cuid();
+
+    await this.prismaRepository.$executeRawUnsafe(
+      `INSERT INTO "Chat" ("id", "instanceId", "remoteJid", "labels", "createdAt", "updatedAt")
+       VALUES ($4, $2, $3, to_jsonb(ARRAY[$1]::text[]), NOW(), NOW()) ON CONFLICT ("instanceId", "remoteJid")
+     DO
+      UPDATE
+          SET "labels" = (
+          SELECT to_jsonb(array_agg(DISTINCT elem))
+          FROM (
+          SELECT jsonb_array_elements_text("Chat"."labels") AS elem
+          UNION
+          SELECT $1::text AS elem
+          ) sub
+          ),
+          "updatedAt" = NOW();`,
+      labelId,
+      instanceId,
+      chatId,
+      id,
+    );
   }
-  
-  
 
   private async removeLabel(labelId: string, instanceId: string, chatId: string) {
     const id = cuid();
diff --git a/src/api/integrations/chatbot/chatbot.controller.ts b/src/api/integrations/chatbot/chatbot.controller.ts
index f99b4fae..cf2bba42 100644
--- a/src/api/integrations/chatbot/chatbot.controller.ts
+++ b/src/api/integrations/chatbot/chatbot.controller.ts
@@ -145,7 +145,10 @@ export class ChatbotController {
         return true;
       }
 
-      if (ignoreContacts && remoteJid.endsWith('@s.whatsapp.net')) {
+      if (
+        ignoreContacts &&
+        (remoteJid.endsWith('@s.whatsapp.net') || remoteJid.endsWith('@lid'))
+      ) {
         this.logger.warn('Ignoring message from contact: ' + remoteJid);
         return true;
       }
diff --git a/src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts b/src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts
index 834d97b8..889b39ad 100644
--- a/src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts
+++ b/src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts
@@ -1,26 +1,26 @@
-import { InstanceDto } from '@api/dto/instance.dto';
-import { Options, Quoted, SendAudioDto, SendMediaDto, SendTextDto } from '@api/dto/sendMessage.dto';
-import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
-import { postgresClient } from '@api/integrations/chatbot/chatwoot/libs/postgres.client';
-import { chatwootImport } from '@api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper';
-import { PrismaRepository } from '@api/repository/repository.service';
-import { CacheService } from '@api/services/cache.service';
-import { WAMonitoringService } from '@api/services/monitor.service';
-import { Events } from '@api/types/wa.types';
-import { Chatwoot, ConfigService, Database, HttpServer } from '@config/env.config';
-import { Logger } from '@config/logger.config';
-import ChatwootClient, {
-  ChatwootAPIConfig,
-  contact,
-  contact_inboxes,
-  conversation,
-  conversation_show,
-  generic_id,
-  inbox,
-} from '@figuro/chatwoot-sdk';
-import { request as chatwootRequest } from '@figuro/chatwoot-sdk/dist/core/request';
-import { Chatwoot as ChatwootModel, Contact as ContactModel, Message as MessageModel } from '@prisma/client';
-import i18next from '@utils/i18n';
+import { InstanceDto } from '@api/dto/instance.dto';
+import { Options, Quoted, SendAudioDto, SendMediaDto, SendTextDto } from '@api/dto/sendMessage.dto';
+import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
+import { postgresClient } from '@api/integrations/chatbot/chatwoot/libs/postgres.client';
+import { chatwootImport } from '@api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper';
+import { PrismaRepository } from '@api/repository/repository.service';
+import { CacheService } from '@api/services/cache.service';
+import { WAMonitoringService } from '@api/services/monitor.service';
+import { Events } from '@api/types/wa.types';
+import { Chatwoot, ConfigService, Database, HttpServer } from '@config/env.config';
+import { Logger } from '@config/logger.config';
+import ChatwootClient, {
+  ChatwootAPIConfig,
+  contact,
+  contact_inboxes,
+  conversation,
+  conversation_show,
+  generic_id,
+  inbox,
+} from '@figuro/chatwoot-sdk';
+import { request as chatwootRequest } from '@figuro/chatwoot-sdk/dist/core/request';
+import { Chatwoot as ChatwootModel, Contact as ContactModel, Message as MessageModel } from '@prisma/client';
+import i18next from '@utils/i18n';
 import { sendTelemetry } from '@utils/sendTelemetry';
 import axios from 'axios';
 import { proto } from 'baileys';
@@ -29,2596 +29,2559 @@ import FormData from 'form-data';
 import Jimp from 'jimp';
 import Long from 'long';
 import mimeTypes from 'mime-types';
+import { createJid } from '@utils/createJid';
 import path from 'path';
 import { Readable } from 'stream';
-
-interface ChatwootMessage {
-  messageId?: number;
-  inboxId?: number;
-  conversationId?: number;
-  contactInboxSourceId?: string;
-  isRead?: boolean;
-}
-
-export class ChatwootService {
-  private readonly logger = new Logger('ChatwootService');
-
-  private provider: any;
-
-  constructor(
-    private readonly waMonitor: WAMonitoringService,
-    private readonly configService: ConfigService,
-    private readonly prismaRepository: PrismaRepository,
-    private readonly cache: CacheService,
-  ) { }
-
-  private pgClient = postgresClient.getChatwootConnection();
-
-  private async getProvider(instance: InstanceDto): Promise<ChatwootModel | null> {
-    const cacheKey = `${instance.instanceName}:getProvider`;
-    if (await this.cache.has(cacheKey)) {
-      const provider = (await this.cache.get(cacheKey)) as ChatwootModel;
-
-      return provider;
-    }
-
-    const provider = await this.waMonitor.waInstances[instance.instanceName]?.findChatwoot();
-
-    if (!provider) {
-      this.logger.warn('provider not found');
-      return null;
-    }
-
-    this.cache.set(cacheKey, provider);
-
-    return provider;
-  }
-
-  private async clientCw(instance: InstanceDto) {
-    const provider = await this.getProvider(instance);
-
-    if (!provider) {
-      this.logger.error('provider not found');
-      return null;
-    }
-
-    this.provider = provider;
-
-    const client = new ChatwootClient({
-      config: this.getClientCwConfig(),
-    });
-
-    return client;
-  }
-
-  public getClientCwConfig(): ChatwootAPIConfig & { nameInbox: string; mergeBrazilContacts: boolean } {
-    return {
-      basePath: this.provider.url,
-      with_credentials: true,
-      credentials: 'include',
-      token: this.provider.token,
-      nameInbox: this.provider.nameInbox,
-      mergeBrazilContacts: this.provider.mergeBrazilContacts,
-    };
-  }
-
-  public getCache() {
-    return this.cache;
-  }
-
-  public async create(instance: InstanceDto, data: ChatwootDto) {
-    await this.waMonitor.waInstances[instance.instanceName].setChatwoot(data);
-
-    if (data.autoCreate) {
-      this.logger.log('Auto create chatwoot instance');
-      const urlServer = this.configService.get<HttpServer>('SERVER').URL;
-
-      await this.initInstanceChatwoot(
-        instance,
-        data.nameInbox ?? instance.instanceName.split('-cwId-')[0],
-        `${urlServer}/chatwoot/webhook/${encodeURIComponent(instance.instanceName)}`,
-        true,
-        data.number,
-        data.organization,
-        data.logo,
-      );
-    }
-    return data;
-  }
-
-  public async find(instance: InstanceDto): Promise<ChatwootDto> {
-    try {
-      return await this.waMonitor.waInstances[instance.instanceName].findChatwoot();
-    } catch (error) {
-      this.logger.error('chatwoot not found');
-      return { enabled: null, url: '' };
-    }
-  }
-
-  public async getContact(instance: InstanceDto, id: number) {
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      this.logger.warn('client not found');
-      return null;
-    }
-
-    if (!id) {
-      this.logger.warn('id is required');
-      return null;
-    }
-
-    const contact = await client.contact.getContactable({
-      accountId: this.provider.accountId,
-      id,
-    });
-
-    if (!contact) {
-      this.logger.warn('contact not found');
-      return null;
-    }
-
-    return contact;
-  }
-
-  public async initInstanceChatwoot(
-    instance: InstanceDto,
-    inboxName: string,
-    webhookUrl: string,
-    qrcode: boolean,
-    number: string,
-    organization?: string,
-    logo?: string,
-  ) {
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      this.logger.warn('client not found');
-      return null;
-    }
-
-    const findInbox: any = await client.inboxes.list({
-      accountId: this.provider.accountId,
-    });
-
-    const checkDuplicate = findInbox.payload.map((inbox) => inbox.name).includes(inboxName);
-
-    let inboxId: number;
-
-    this.logger.log('Creating chatwoot inbox');
-    if (!checkDuplicate) {
-      const data = {
-        type: 'api',
-        webhook_url: webhookUrl,
+
+interface ChatwootMessage {
+  messageId?: number;
+  inboxId?: number;
+  conversationId?: number;
+  contactInboxSourceId?: string;
+  isRead?: boolean;
+}
+
+export class ChatwootService {
+  private readonly logger = new Logger('ChatwootService');
+
+  private provider: any;
+
+  constructor(
+    private readonly waMonitor: WAMonitoringService,
+    private readonly configService: ConfigService,
+    private readonly prismaRepository: PrismaRepository,
+    private readonly cache: CacheService,
+  ) {}
+
+  private pgClient = postgresClient.getChatwootConnection();
+
+  private async getProvider(instance: InstanceDto): Promise<ChatwootModel | null> {
+    const cacheKey = `${instance.instanceName}:getProvider`;
+    if (await this.cache.has(cacheKey)) {
+      const provider = (await this.cache.get(cacheKey)) as ChatwootModel;
+
+      return provider;
+    }
+
+    const provider = await this.waMonitor.waInstances[instance.instanceName]?.findChatwoot();
+
+    if (!provider) {
+      this.logger.warn('provider not found');
+      return null;
+    }
+
+    this.cache.set(cacheKey, provider);
+
+    return provider;
+  }
+
+  private async clientCw(instance: InstanceDto) {
+    const provider = await this.getProvider(instance);
+
+    if (!provider) {
+      this.logger.error('provider not found');
+      return null;
+    }
+
+    this.provider = provider;
+
+    const client = new ChatwootClient({
+      config: this.getClientCwConfig(),
+    });
+
+    return client;
+  }
+
+  public getClientCwConfig(): ChatwootAPIConfig & { nameInbox: string; mergeBrazilContacts: boolean } {
+    return {
+      basePath: this.provider.url,
+      with_credentials: true,
+      credentials: 'include',
+      token: this.provider.token,
+      nameInbox: this.provider.nameInbox,
+      mergeBrazilContacts: this.provider.mergeBrazilContacts,
+    };
+  }
+
+  public getCache() {
+    return this.cache;
+  }
+
+  public async create(instance: InstanceDto, data: ChatwootDto) {
+    await this.waMonitor.waInstances[instance.instanceName].setChatwoot(data);
+
+    if (data.autoCreate) {
+      this.logger.log('Auto create chatwoot instance');
+      const urlServer = this.configService.get<HttpServer>('SERVER').URL;
+
+      await this.initInstanceChatwoot(
+        instance,
+        data.nameInbox ?? instance.instanceName.split('-cwId-')[0],
+        `${urlServer}/chatwoot/webhook/${encodeURIComponent(instance.instanceName)}`,
+        true,
+        data.number,
+        data.organization,
+        data.logo,
+      );
+    }
+    return data;
+  }
+
+  public async find(instance: InstanceDto): Promise<ChatwootDto> {
+    try {
+      return await this.waMonitor.waInstances[instance.instanceName].findChatwoot();
+    } catch (error) {
+      this.logger.error('chatwoot not found');
+      return { enabled: null, url: '' };
+    }
+  }
+
+  public async getContact(instance: InstanceDto, id: number) {
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    if (!id) {
+      this.logger.warn('id is required');
+      return null;
+    }
+
+    const contact = await client.contact.getContactable({
+      accountId: this.provider.accountId,
+      id,
+    });
+
+    if (!contact) {
+      this.logger.warn('contact not found');
+      return null;
+    }
+
+    return contact;
+  }
+
+  public async initInstanceChatwoot(
+    instance: InstanceDto,
+    inboxName: string,
+    webhookUrl: string,
+    qrcode: boolean,
+    number: string,
+    organization?: string,
+    logo?: string,
+  ) {
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    const findInbox: any = await client.inboxes.list({
+      accountId: this.provider.accountId,
+    });
+
+    const checkDuplicate = findInbox.payload.map((inbox) => inbox.name).includes(inboxName);
+
+    let inboxId: number;
+
+    this.logger.log('Creating chatwoot inbox');
+    if (!checkDuplicate) {
+      const data = {
+        type: 'api',
+        webhook_url: webhookUrl,
+      };
+
+      const inbox = await client.inboxes.create({
+        accountId: this.provider.accountId,
+        data: {
+          name: inboxName,
+          channel: data as any,
+        },
+      });
+
+      if (!inbox) {
+        this.logger.warn('inbox not found');
+        return null;
+      }
+
+      inboxId = inbox.id;
+    } else {
+      const inbox = findInbox.payload.find((inbox) => inbox.name === inboxName);
+
+      if (!inbox) {
+        this.logger.warn('inbox not found');
+        return null;
+      }
+
+      inboxId = inbox.id;
+    }
+    this.logger.log(`Inbox created - inboxId: ${inboxId}`);
+
+    if (!this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT) {
+      this.logger.log('Chatwoot bot contact is disabled');
+
+      return true;
+    }
+
+    this.logger.log('Creating chatwoot bot contact');
+    const contact =
+      (await this.findContact(instance, '123456')) ||
+      ((await this.createContact(
+        instance,
+        '123456',
+        inboxId,
+        false,
+        organization ? organization : 'EvolutionAPI',
+        logo ? logo : 'https://evolution-api.com/files/evolution-api-favicon.png',
+      )) as any);
+
+    if (!contact) {
+      this.logger.warn('contact not found');
+      return null;
+    }
+
+    const contactId = contact.id || contact.payload.contact.id;
+    this.logger.log(`Contact created - contactId: ${contactId}`);
+
+    if (qrcode) {
+      this.logger.log('QR code enabled');
+      const data = {
+        contact_id: contactId.toString(),
+        inbox_id: inboxId.toString(),
+      };
+
+      const conversation = await client.conversations.create({
+        accountId: this.provider.accountId,
+        data,
+      });
+
+      if (!conversation) {
+        this.logger.warn('conversation not found');
+        return null;
+      }
+
+      let contentMsg = 'init';
+
+      if (number) {
+        contentMsg = `init:${number}`;
+      }
+
+      const message = await client.messages.create({
+        accountId: this.provider.accountId,
+        conversationId: conversation.id,
+        data: {
+          content: contentMsg,
+          message_type: 'outgoing',
+        },
+      });
+
+      if (!message) {
+        this.logger.warn('conversation not found');
+        return null;
+      }
+      this.logger.log('Init message sent');
+    }
+
+    return true;
+  }
+
+  public async createContact(
+    instance: InstanceDto,
+    phoneNumber: string,
+    inboxId: number,
+    isGroup: boolean,
+    name?: string,
+    avatar_url?: string,
+    jid?: string,
+  ) {
+    const client = await this.clientCw(instance);
+
+    this.logger.verbose('Create contact called.');
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    let data: any = {};
+    if (!isGroup) {
+      data = {
+        inbox_id: inboxId,
+        name: name || phoneNumber,
+        identifier: jid,
+        avatar_url: avatar_url,
       };
 
-      const inbox = await client.inboxes.create({
-        accountId: this.provider.accountId,
-        data: {
-          name: inboxName,
-          channel: data as any,
-        },
-      });
-
-      if (!inbox) {
-        this.logger.warn('inbox not found');
-        return null;
+      if (phoneNumber && !phoneNumber.includes('@')) {
+        data.phone_number = `+${phoneNumber}`;
       }
-
-      inboxId = inbox.id;
     } else {
-      const inbox = findInbox.payload.find((inbox) => inbox.name === inboxName);
-
-      if (!inbox) {
-        this.logger.warn('inbox not found');
-        return null;
-      }
-
-      inboxId = inbox.id;
-    }
-    this.logger.log(`Inbox created - inboxId: ${inboxId}`);
-
-    if (!this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT) {
-      this.logger.log('Chatwoot bot contact is disabled');
-
-      return true;
-    }
-
-    this.logger.log('Creating chatwoot bot contact');
-    const contact =
-      (await this.findContact(instance, '123456')) ||
-      ((await this.createContact(
-        instance,
-        '123456',
-        inboxId,
-        false,
-        organization ? organization : 'EvolutionAPI',
-        logo ? logo : 'https://evolution-api.com/files/evolution-api-favicon.png',
-      )) as any);
-
-    if (!contact) {
-      this.logger.warn('contact not found');
-      return null;
-    }
-
-    const contactId = contact.id || contact.payload.contact.id;
-    this.logger.log(`Contact created - contactId: ${contactId}`);
-
-    if (qrcode) {
-      this.logger.log('QR code enabled');
-      const data = {
-        contact_id: contactId.toString(),
-        inbox_id: inboxId.toString(),
-      };
-
-      const conversation = await client.conversations.create({
-        accountId: this.provider.accountId,
-        data,
-      });
-
-      if (!conversation) {
-        this.logger.warn('conversation not found');
-        return null;
-      }
-
-      let contentMsg = 'init';
-
-      if (number) {
-        contentMsg = `init:${number}`;
-      }
-
-      const message = await client.messages.create({
-        accountId: this.provider.accountId,
-        conversationId: conversation.id,
-        data: {
-          content: contentMsg,
-          message_type: 'outgoing',
-        },
-      });
-
-      if (!message) {
-        this.logger.warn('conversation not found');
-        return null;
-      }
-      this.logger.log('Init message sent');
-    }
-
-    return true;
-  }
-
-  public async createContact(
-    instance: InstanceDto,
-    phoneNumber: string,
-    inboxId: number,
-    isGroup: boolean,
-    name?: string,
-    avatar_url?: string,
-    jid?: string,
-  ) {
-    this.logger.verbose(
-      `[ChatwootService][createContact] start instance=${instance.instanceName} phone=${phoneNumber}`
-    );
-  
-    // 1) obter cliente
-    const client = await this.clientCw(instance);
-    if (!client) {
-      this.logger.warn(
-        `[ChatwootService][createContact] client not found for instance=${instance.instanceName}`
-      );
-      return null;
-    }
-    this.logger.verbose(`[ChatwootService][createContact] client obtained`);
-  
-    // 2) montar payload
-    const data: any = { inbox_id: inboxId, name: name || phoneNumber, avatar_url };
-    if (!isGroup) {
-      data.identifier = jid;
-      data.phone_number = `+${phoneNumber}`;
+      data = {
+        inbox_id: inboxId,
+        name: name || phoneNumber,
+        identifier: phoneNumber,
+        avatar_url: avatar_url,
+      };
+    }
+
+    const contact = await client.contacts.create({
+      accountId: this.provider.accountId,
+      data,
+    });
+
+    if (!contact) {
+      this.logger.warn('contact not found');
+      return null;
+    }
+
+    const findContact = await this.findContact(instance, phoneNumber);
+
+    const contactId = findContact?.id;
+
+    await this.addLabelToContact(this.provider.nameInbox, contactId);
+
+    return contact;
+  }
+
+  public async updateContact(instance: InstanceDto, id: number, data: any) {
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    if (!id) {
+      this.logger.warn('id is required');
+      return null;
+    }
+
+    try {
+      const contact = await client.contacts.update({
+        accountId: this.provider.accountId,
+        id,
+        data,
+      });
+      
+
+      return contact;
+    } catch (error) {
+      return null;
+    }
+  }
+
+  public async addLabelToContact(nameInbox: string, contactId: number) {
+    try {
+      const uri = this.configService.get<Chatwoot>('CHATWOOT').IMPORT.DATABASE.CONNECTION.URI;
+
+      if (!uri) return false;
+
+      const sqlTags = `SELECT id, taggings_count FROM tags WHERE name = $1 LIMIT 1`;
+      const tagData = (await this.pgClient.query(sqlTags, [nameInbox]))?.rows[0];
+      let tagId = tagData?.id;
+      const taggingsCount = tagData?.taggings_count || 0;
+
+      const sqlTag = `INSERT INTO tags (name, taggings_count) 
+                      VALUES ($1, $2) 
+                      ON CONFLICT (name) 
+                      DO UPDATE SET taggings_count = tags.taggings_count + 1 
+                      RETURNING id`;
+
+      tagId = (await this.pgClient.query(sqlTag, [nameInbox, taggingsCount + 1]))?.rows[0]?.id;
+
+      const sqlCheckTagging = `SELECT 1 FROM taggings 
+                               WHERE tag_id = $1 AND taggable_type = 'Contact' AND taggable_id = $2 AND context = 'labels' LIMIT 1`;
+
+      const taggingExists = (await this.pgClient.query(sqlCheckTagging, [tagId, contactId]))?.rowCount > 0;
+
+      if (!taggingExists) {
+        const sqlInsertLabel = `INSERT INTO taggings (tag_id, taggable_type, taggable_id, context, created_at) 
+                                VALUES ($1, 'Contact', $2, 'labels', NOW())`;
+
+        await this.pgClient.query(sqlInsertLabel, [tagId, contactId]);
+      }
+
+      return true;
+    } catch (error) {
+      return false;
+    }
+  }
+
+  public async findContact(instance: InstanceDto, phoneNumber: string) {
+    const client = await this.clientCw(instance);
+  
+
+    this.logger.verbose(`Finding contact in chatwoot: ${phoneNumber}`);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+  
+    const cacheKey = `${instance.instanceName}:findContact-${phoneNumber}`;
+    this.logger.verbose(`Finding contact in chatwoot - cache key: ${cacheKey}`);
+
+    const stackTrace = new Error().stack;
+    this.logger.verbose(`Stack trace: ${stackTrace}`);
+
+  
+    // Verifica o cache
+    if (await this.cache.has(cacheKey)) {
+      this.logger.verbose(`Finding contact in chatwoot - hit for key: ${cacheKey}`);
+      const cachedContact = await this.cache.get(cacheKey);
+      this.logger.verbose(`Cached contact: ${JSON.stringify(cachedContact)}`);
+      return cachedContact;
+    }
+    
+    this.logger.verbose(`Miss for key: ${cacheKey}`);
+    
+    let query: any;
+    const isGroup = phoneNumber?.includes('@g.us');
+    const searchByIdentifier = !phoneNumber || phoneNumber.endsWith('@lid');
+
+    if (isGroup || searchByIdentifier) {
+      query = phoneNumber;
     } else {
-      data.identifier = phoneNumber;
-    }
-    this.logger.verbose(
-      `[ChatwootService][createContact] payload=${JSON.stringify(data)}`
-    );
-  
-    // 3) criar no Chatwoot
-    let rawResponse: any;
-    try {
-      rawResponse = await client.contacts.create({
-        accountId: this.provider.accountId,
-        data,
-      });
-      this.logger.verbose(
-        `[ChatwootService][createContact] raw create response=${JSON.stringify(rawResponse)}`
-      );
-    } catch (err) {
-      this.logger.error(
-        `[ChatwootService][createContact] error creating contact: ${err}`
-      );
-      throw err;
-    }
-  
-    // 4) extrair o contactId dos dois possíveis formatos
-    //    - legacy: { id: number, ... }
-    //    - nova versão: { payload: { contact: { id: number, ... } } }
-    const maybePayload = rawResponse.payload?.contact;
-    const contactObj = maybePayload ?? rawResponse;
-    const contactId = contactObj.id as number | undefined;
-  
-    if (!contactId) {
-      this.logger.error(
-        `[ChatwootService][createContact] no id found in response; raw=${JSON.stringify(rawResponse)}`
-      );
-      return null;
+      query = `+${phoneNumber}`;
     }
-    this.logger.verbose(
-      `[ChatwootService][createContact] created contact id=${contactId}`
-    );
-  
-    // 5) adicionar label
-    try {
-      this.logger.verbose(
-        `[ChatwootService][createContact] adding label=${this.provider.nameInbox} to contactId=${contactId}`
-      );
-      await this.addLabelToContact(this.provider.nameInbox, contactId);
-    } catch (err) {
-      this.logger.error(
-        `[ChatwootService][createContact] error addLabelToContact: ${err}`
-      );
-    }
-  
-    // 6) retornar objeto com .id para ser usado pelo createConversation
-    return { id: contactId, ...contactObj };
-  }
-  
-  
-  
-
-  public async updateContact(instance: InstanceDto, id: number, data: any) {
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      this.logger.warn('client not found');
-      return null;
-    }
-
-    if (!id) {
-      this.logger.warn('id is required');
-      return null;
-    }
-
-    try {
-      const contact = await client.contacts.update({
+  
+    let contact: any;
+  
+    if (isGroup) {
+      contact = await client.contacts.search({
         accountId: this.provider.accountId,
-        id,
-        data,
+        q: query,
       });
-
-      return contact;
-    } catch (error) {
-      return null;
-    }
-  }
-
-  public async addLabelToContact(nameInbox: string, contactId: number) {
-    try {
-      const uri = this.configService.get<Chatwoot>('CHATWOOT').IMPORT.DATABASE.CONNECTION.URI;
-
-      if (!uri) return false;
-
-      const sqlTags = `SELECT id, taggings_count FROM tags WHERE name = $1 LIMIT 1`;
-      const tagData = (await this.pgClient.query(sqlTags, [nameInbox]))?.rows[0];
-      let tagId = tagData?.id;
-      const taggingsCount = tagData?.taggings_count || 0;
-
-      const sqlTag = `INSERT INTO tags (name, taggings_count) 
-                        VALUES ($1, $2) 
-                        ON CONFLICT (name) 
-                        DO UPDATE SET taggings_count = tags.taggings_count + 1 
-                        RETURNING id`;
-
-      tagId = (await this.pgClient.query(sqlTag, [nameInbox, taggingsCount + 1]))?.rows[0]?.id;
-
-      const sqlCheckTagging = `SELECT 1 FROM taggings 
-                                WHERE tag_id = $1 AND taggable_type = 'Contact' AND taggable_id = $2 AND context = 'labels' LIMIT 1`;
-
-      const taggingExists = (await this.pgClient.query(sqlCheckTagging, [tagId, contactId]))?.rowCount > 0;
-
-      if (!taggingExists) {
-        const sqlInsertLabel = `INSERT INTO taggings (tag_id, taggable_type, taggable_id, context, created_at) 
-                                  VALUES ($1, 'Contact', $2, 'labels', NOW())`;
-
-        await this.pgClient.query(sqlInsertLabel, [tagId, contactId]);
-      }
-
-      return true;
-    } catch (error) {
-      return false;
-    }
-  }
-
-  public async findContact(instance: InstanceDto, phoneNumber: string) {
-    this.logger.verbose(
-      `[ChatwootService][findContact] start for instance=${instance.instanceName}, phoneNumber=${phoneNumber}`
-    );
-  
-    const client = await this.clientCw(instance);
-    if (!client) {
-      this.logger.warn(
-        `[ChatwootService][findContact] client not found for instance=${instance.instanceName}`
-      );
-      return null;
-    }
-  
-    const isGroup = phoneNumber.includes('@g.us');
-    const query = isGroup ? phoneNumber : `+${phoneNumber}`;
-  
-    this.logger.verbose(
-      `[ChatwootService][findContact] isGroup=${isGroup}, query=${query}`
-    );
-  
-    let response: any;
-    try {
-      if (isGroup) {
-        response = await client.contacts.search({
-          accountId: this.provider.accountId,
-          q: query,
-        });
-      } else {
-        response = await chatwootRequest(this.getClientCwConfig(), {
-          method: 'POST',
-          url: `/api/v1/accounts/${this.provider.accountId}/contacts/filter`,
-          body: { payload: this.getFilterPayload(query) },
-        });
-      }
-      this.logger.verbose(
-        `[ChatwootService][findContact] raw response: ${JSON.stringify(response)}`
-      );
-    } catch (error) {
-      this.logger.error(
-        `[ChatwootService][findContact] error during API call: ${error.message}`
-      );
-      return null;
-    }
-  
-    const payload = response.payload || [];
-    this.logger.verbose(
-      `[ChatwootService][findContact] payload length: ${payload.length}`
-    );
-  
-    if (payload.length === 0) {
-      this.logger.warn(
-        `[ChatwootService][findContact] contact not found for query=${query}`
-      );
-      return null;
-    }
-  
-    let found: any;
-    if (isGroup) {
-      found = payload.find((c: any) => c.identifier === query);
     } else {
-      found = payload.length > 1
-        ? this.findContactInContactList(payload, query)
-        : payload[0];
-    }
-  
-    this.logger.verbose(
-      `[ChatwootService][findContact] returning contact: ${JSON.stringify(found)}`
-    );
-  
-    return found;
-  }
-  
-
-  private async mergeBrazilianContacts(contacts: any[]) {
-    try {
-      const contact = await chatwootRequest(this.getClientCwConfig(), {
+      contact = await chatwootRequest(this.getClientCwConfig(), {
         method: 'POST',
-        url: `/api/v1/accounts/${this.provider.accountId}/actions/contact_merge`,
+        url: `/api/v1/accounts/${this.provider.accountId}/contacts/filter`,
         body: {
-          base_contact_id: contacts.find((contact) => contact.phone_number.length === 14)?.id,
-          mergee_contact_id: contacts.find((contact) => contact.phone_number.length === 13)?.id,
+          payload: this.getFilterPayload(
+            query,
+            searchByIdentifier,
+          ),
         },
       });
-
-      return contact;
-    } catch {
-      this.logger.error('Error merging contacts');
-      return null;
     }
-  }
-
-  private findContactInContactList(contacts: any[], query: string) {
+  
+    if (!contact || contact?.payload?.length === 0) {
+      this.logger.warn('contact not found');
+      return null;
+    }
+  
+    const resolvedContact = isGroup
+      ? contact.payload.find((c) => c.identifier === query)
+      : contact.payload.length > 1
+      ? this.findContactInContactList(contact.payload, query, searchByIdentifier)
+      : contact.payload[0];
+  
+    // Armazena no cache
+    await this.cache.set(cacheKey, resolvedContact); 
+    this.logger.verbose(`Contact cached with key: ${cacheKey}`);
+  
+    return resolvedContact;
+  }
+
+  private async mergeBrazilianContacts(contacts: any[]) {
+    try {
+      const contact = await chatwootRequest(this.getClientCwConfig(), {
+        method: 'POST',
+        url: `/api/v1/accounts/${this.provider.accountId}/actions/contact_merge`,
+        body: {
+          base_contact_id: contacts.find((contact) => contact.phone_number.length === 14)?.id,
+          mergee_contact_id: contacts.find((contact) => contact.phone_number.length === 13)?.id,
+        },
+      });
+
+      return contact;
+    } catch {
+      this.logger.error('Error merging contacts');
+      return null;
+    }
+  }
+
+  private findContactInContactList(
+    contacts: any[],
+    query: string,
+    useIdentifier = false,
+  ) {
     const phoneNumbers = this.getNumbers(query);
-    const searchableFields = this.getSearchableFields();
-
-    // eslint-disable-next-line prettier/prettier
-    if (contacts.length === 2 && this.getClientCwConfig().mergeBrazilContacts && query.startsWith('+55')) {
-      const contact = this.mergeBrazilianContacts(contacts);
-      if (contact) {
-        return contact;
-      }
-    }
-
-    const phone = phoneNumbers.reduce(
-      (savedNumber, number) => (number.length > savedNumber.length ? number : savedNumber),
-      '',
-    );
-
-    const contact_with9 = contacts.find((contact) => contact.phone_number === phone);
-    if (contact_with9) {
-      return contact_with9;
-    }
-
-    for (const contact of contacts) {
-      for (const field of searchableFields) {
-        if (contact[field] && phoneNumbers.includes(contact[field])) {
-          return contact;
-        }
-      }
-    }
-
-    return null;
-  }
-
-  private getNumbers(query: string) {
-    const numbers = [];
-    numbers.push(query);
-
-    if (query.startsWith('+55') && query.length === 14) {
-      const withoutNine = query.slice(0, 5) + query.slice(6);
-      numbers.push(withoutNine);
-    } else if (query.startsWith('+55') && query.length === 13) {
-      const withNine = query.slice(0, 5) + '9' + query.slice(5);
-      numbers.push(withNine);
-    }
-
-    return numbers;
-  }
-
-  private getSearchableFields() {
-    return ['phone_number'];
+    const searchableFields = this.getSearchableFields(useIdentifier);
+
+    // eslint-disable-next-line prettier/prettier
+    if (contacts.length === 2 && this.getClientCwConfig().mergeBrazilContacts && query.startsWith('+55')) {
+      const contact = this.mergeBrazilianContacts(contacts);
+      if (contact) {
+        return contact;
+      }
+    }
+
+    const phone = phoneNumbers.reduce(
+      (savedNumber, number) => (number.length > savedNumber.length ? number : savedNumber),
+      '',
+    );
+
+    const contact_with9 = contacts.find((contact) => contact.phone_number === phone);
+    if (contact_with9) {
+      return contact_with9;
+    }
+
+    for (const contact of contacts) {
+      for (const field of searchableFields) {
+        if (contact[field] && phoneNumbers.includes(contact[field])) {
+          return contact;
+        }
+      }
+    }
+
+    return null;
+  }
+
+  private getNumbers(query: string) {
+    const numbers = [];
+    numbers.push(query);
+
+    if (query.startsWith('+55') && query.length === 14) {
+      const withoutNine = query.slice(0, 5) + query.slice(6);
+      numbers.push(withoutNine);
+    } else if (query.startsWith('+55') && query.length === 13) {
+      const withNine = query.slice(0, 5) + '9' + query.slice(5);
+      numbers.push(withNine);
+    }
+
+    return numbers;
+  }
+
+  private getSearchableFields(includeIdentifier = false) {
+    const fields = ['phone_number'];
+    if (includeIdentifier) {
+      fields.push('identifier');
+    }
+    return fields;
   }
-
-  private getFilterPayload(query: string) {
-    const filterPayload = [];
-
+
+  private getFilterPayload(query: string, includeIdentifier = false) {
+    const filterPayload = [];
+
     const numbers = this.getNumbers(query);
-    const fieldsToSearch = this.getSearchableFields();
-
-    fieldsToSearch.forEach((field, index1) => {
-      numbers.forEach((number, index2) => {
-        const queryOperator = fieldsToSearch.length - 1 === index1 && numbers.length - 1 === index2 ? null : 'OR';
-        filterPayload.push({
-          attribute_key: field,
-          filter_operator: 'equal_to',
-          values: [number.replace('+', '')],
-          query_operator: queryOperator,
-        });
-      });
-    });
-
-    return filterPayload;
-  }
-
- 
-
-  private pendingCreateConv = new Map<string, Promise<number>>();
-
-  public async createConversation(instance: InstanceDto, body: any): Promise<number> {
-    const remoteJid = body.key.remoteJid as string;
-    this.logger.verbose("[createConversation] Iniciando para remoteJid=" + remoteJid);
-  
-    // 0) Se já está criando, reutiliza a promise
-    if (this.pendingCreateConv.has(remoteJid)) {
-      this.logger.verbose("[createConversation] Ja em criacao para " + remoteJid + ", retornando promise existente");
-      return this.pendingCreateConv.get(remoteJid)!;
-    }
-  
-    let triedRecovery = false;
-    const cacheKey = instance.instanceName + ":createConversation-" + remoteJid;
-  
-    const p = (async (): Promise<number> => {
-      try {
-        this.logger.verbose("[createConversation] Chamando _createConversation pela primeira vez");
-        return await this._createConversation(instance, body);
-      } catch (err) {
-        this.logger.error("[createConversation] Erro na primeira tentativa: " + err);
-        if (!triedRecovery) {
-          triedRecovery = true;
-          this.logger.warn("[createConversation] Tentando recuperacao: limpando cache e recriando conversa");
-          await this.cache.delete(cacheKey);
-          this.logger.verbose("[createConversation] Cache deletado para chave=" + cacheKey);
-          return await this._createConversation(instance, body);
-        }
-        this.logger.error("[createConversation] Ja tentei recuperacao, repassando erro");
-        throw err;
-      }
-    })();
-  
-    this.pendingCreateConv.set(remoteJid, p);
-    try {
-      const convId = await p;
-      this.logger.verbose("[createConversation] Concluido para " + remoteJid + ", convId=" + convId);
-      return convId;
-    } finally {
-      this.pendingCreateConv.delete(remoteJid);
-      this.logger.verbose("[createConversation] Removido pendingCreateConv para " + remoteJid);
-    }
-  }
-
-
- 
-  
-  private async _createConversation(instance: InstanceDto, body: any): Promise<number> {
-    const remoteJid = body.key.remoteJid as string;
-    const cacheKey = instance.instanceName + ":createConversation-" + remoteJid;
-    this.logger.verbose("[_createConversation] Start para remoteJid=" + remoteJid);
-  
-    // 1) Cliente Chatwoot
-    const client = await this.clientCw(instance);
-    if (!client) {
-      this.logger.error("[_createConversation] Client Chatwoot nao encontrado para " + instance.instanceName);
-      throw new Error("Client not found for instance: " + instance.instanceName);
-    }
-    this.logger.verbose("[_createConversation] Client Chatwoot obtido");
-  
-    // 2) Cache
-    const hasCache = await this.cache.has(cacheKey);
-    this.logger.verbose("[_createConversation] Cache check para key=" + cacheKey + ": " + hasCache);
-    if (hasCache) {
-      const cachedId = (await this.cache.get(cacheKey)) as number;
-      this.logger.verbose("[_createConversation] Usando ID em cache=" + cachedId);
-      return cachedId;
-    }
-  
-    // 3) Inbox
-    const filterInbox = await this.getInbox(instance);
-    if (!filterInbox) {
-      this.logger.error("[_createConversation] Inbox nao encontrada para " + instance.instanceName);
-      throw new Error("Inbox not found for instance: " + instance.instanceName);
-    }
-    this.logger.verbose("[_createConversation] Inbox encontrada: id=" + filterInbox.id);
-  
-    // 4) Contato
-    const isGroup = remoteJid.includes("@g.us");
-    const chatId = isGroup ? remoteJid : remoteJid.split("@")[0];
-    this.logger.verbose("[_createConversation] isGroup=" + isGroup + ", chatId=" + chatId);
-  
-    let contact = await this.findContact(instance, chatId);
-    if (contact) {
-      this.logger.verbose("[_createConversation] Contato encontrado: id=" + contact.id);
-    } else {
-      this.logger.verbose("[_createConversation] Contato nao existe, criando...");
-
-
-      const isOutgoing = body.key.fromMe;
-      const senderName = !isOutgoing && body.pushName ? body.pushName : chatId;
-
-      const name = isGroup
-        ? (await this.waMonitor.waInstances[instance.instanceName]
-              .client.groupMetadata(chatId)).subject + " (GROUP)"
-        : senderName;
-
-
-
-      const pictureUrl = (await this.waMonitor.waInstances[instance.instanceName].profilePicture(chatId)).profilePictureUrl;
-      contact = await this.createContact(
-        instance,
-        chatId,
-        filterInbox.id,
-        isGroup,
-        name,
-        pictureUrl || null,
-        isGroup ? remoteJid : undefined
-      );
-      if (!contact) {
-        this.logger.error("[_createConversation] Falha ao criar contato para " + chatId);
-        throw new Error("Nao conseguiu criar contato para conversa");
-      }
-      this.logger.verbose("[_createConversation] Contato criado: id=" + contact.id);
-    }
-    const contactId = (contact.id ?? contact.payload?.contact?.id) as number;
-  
-    // 5) Listar conversas existentes
-    this.logger.verbose("[_createConversation] Chamando listConversations para contactId=" + contactId);
-    const listResp: any = await client.contacts.listConversations({
-      accountId: this.provider.accountId,
-      id: contactId,
-    });
-    this.logger.verbose("[_createConversation] listConversations raw: " + JSON.stringify(listResp));
-  
-    let conversations: any[] = [];
-    if (Array.isArray(listResp)) conversations = listResp;
-    else if (Array.isArray(listResp.payload)) conversations = listResp.payload;
-    else if (Array.isArray(listResp.data?.payload)) conversations = listResp.data.payload;
-    else if (Array.isArray(listResp.data)) conversations = listResp.data;
-    this.logger.verbose("[_createConversation] Encontradas " + conversations.length + " conversas");
-  
-    // 6) Filtrar conversa aberta ou pendente
-    let conv = null;
-    if (this.provider.reopenConversation) {
-      this.logger.verbose("[_createConversation] reopenConversation=true, buscando inbox_id=" + filterInbox.id);
-      conv = conversations.find(c => c.inbox_id === filterInbox.id);
-      if (conv && this.provider.conversationPending && conv.status !== "pending") {
-        this.logger.verbose("[_createConversation] Reabrindo conversa " + conv.id + " para status=pending");
-        await client.conversations.toggleStatus({
-          accountId: this.provider.accountId,
-          conversationId: conv.id,
-          data: { status: "pending" },
-        });
-      }
-    } else {
-      this.logger.verbose("[_createConversation] reopenConversation=false, buscando status!=resolved");
-      conv = conversations.find(c => c.status !== "resolved" && c.inbox_id === filterInbox.id);
-    }
-  
-    if (conv) {
-      this.logger.verbose("[_createConversation] Usando conversa existente id=" + conv.id);
-      this.cache.set(cacheKey, conv.id, 5 * 60);
-      return conv.id;
-    }
-  
-    // 7) Criar nova conversa
-    this.logger.verbose("[_createConversation] Nenhuma conversa encontrada, criando nova...");
-    const payload: any = {
-      contact_id: contactId.toString(),
-      inbox_id: filterInbox.id.toString(),
-      ...(this.provider.conversationPending ? { status: "pending" } : {}),
-    };
-  
-    try {
-      const newConv = await client.conversations.create({
-        accountId: this.provider.accountId,
-        data: payload,
-      });
-
-      const displayId = (newConv as any).display_id ?? newConv.id;
-
-      if (!displayId) {
-        this.logger.error("[_createConversation] create retornou sem DisplayID");
-        throw new Error("Falha ao criar nova conversa: resposta sem DisplayID");
-      }
-      this.logger.verbose("[_createConversation] Nova conversa criada DisplayId=" + displayId);
-      this.cache.set(cacheKey, displayId, 5 * 60);
-      return displayId;
-  
-    } catch (err: any) {
-      this.logger.error("[_createConversation] Erro ao criar conversa: " + err);
-      this.logger.warn("[_createConversation] Tentando recuperar conversa via listConversations novamente");
-  
-      const retryList: any = await client.contacts.listConversations({
-        accountId: this.provider.accountId,
-        id: contactId,
-      });
-      this.logger.verbose("[_createConversation] retry listConversations raw: " + JSON.stringify(retryList));
-  
-      let retryConvs: any[] = [];
-      if (Array.isArray(retryList)) retryConvs = retryList;
-      else if (Array.isArray(retryList.payload)) retryConvs = retryList.payload;
-      else if (Array.isArray(retryList.data?.payload)) retryConvs = retryList.data.payload;
-      else if (Array.isArray(retryList.data)) retryConvs = retryList.data;
-      this.logger.verbose("[_createConversation] retry encontrou " + retryConvs.length + " conversas");
-  
-      const recovered = retryConvs.find(c => c.inbox_id === filterInbox.id);
-      if (recovered) {
-        this.logger.verbose("[_createConversation] Recuperou conversa existente id=" + recovered.id);
-        this.cache.set(cacheKey, recovered.id, 5 * 60);
-        return recovered.id;
+    const fieldsToSearch = this.getSearchableFields(includeIdentifier);
+
+    fieldsToSearch.forEach((field, index1) => {
+      numbers.forEach((number, index2) => {
+        const queryOperator = fieldsToSearch.length - 1 === index1 && numbers.length - 1 === index2 ? null : 'OR';
+        filterPayload.push({
+          attribute_key: field,
+          filter_operator: 'equal_to',
+          values: [number.replace('+', '')],
+          query_operator: queryOperator,
+        });
+      });
+    });
+
+    return filterPayload;
+  }
+
+  public async createConversation(instance: InstanceDto, body: any) {
+    try {
+      this.logger.verbose('--- Start createConversation ---');
+      this.logger.verbose(`Instance: ${JSON.stringify(instance)}`);
+
+      const client = await this.clientCw(instance);
+
+      if (!client) {
+        this.logger.warn(`Client not found for instance: ${JSON.stringify(instance)}`);
+        return null;
+      }
+
+      const cacheKey = `${instance.instanceName}:createConversation-${body.key.remoteJid}`;
+      this.logger.verbose(`Cache key: ${cacheKey}`);
+
+      if (await this.cache.has(cacheKey)) {
+        this.logger.verbose(`Cache hit for key: ${cacheKey}`);
+        const conversationId = (await this.cache.get(cacheKey)) as number;
+        this.logger.verbose(`Cached conversation ID: ${conversationId}`);
+        let conversationExists: conversation | boolean;
+        try {
+          conversationExists = await client.conversations.get({
+            accountId: this.provider.accountId,
+            conversationId: conversationId,
+          });
+          this.logger.verbose(`Conversation exists: ${JSON.stringify(conversationExists)}`);
+        } catch (error) {
+          this.logger.error(`Error getting conversation: ${error}`);
+          conversationExists = false;
+        }
+        if (!conversationExists) {
+          this.logger.verbose('Conversation does not exist, re-calling createConversation');
+          this.cache.delete(cacheKey);
+          return await this.createConversation(instance, body);
+        }
+
+        return conversationId;
+      }
+
+      const isGroup = body.key.remoteJid.includes('@g.us');
+      this.logger.verbose(`Is group: ${isGroup}`);
+
+      const chatId = body.key.remoteJid;
+      let phoneNumber = isGroup ? chatId : this.getNumberFromRemoteJid(chatId);
+      if (!phoneNumber && chatId.endsWith('@lid')) {
+        phoneNumber = chatId;
       }
-  
-      this.logger.error("[_createConversation] Nao recuperou conversa, repassando erro");
-      throw err;
-    }
-  }
-  
-
-
-
-
-
-
-
-
-
-
-
-
-
-  public async getInbox(instance: InstanceDto): Promise<inbox | null> {
-    const cacheKey = `${instance.instanceName}:getInbox`;
-    if (await this.cache.has(cacheKey)) {
-      return (await this.cache.get(cacheKey)) as inbox;
-    }
-
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      this.logger.warn('client not found');
-      return null;
-    }
-
-    const inbox = (await client.inboxes.list({
-      accountId: this.provider.accountId,
-    })) as any;
-
-    if (!inbox) {
-      this.logger.warn('inbox not found');
-      return null;
-    }
-
-    const findByName = inbox.payload.find((inbox) => inbox.name === this.getClientCwConfig().nameInbox);
-
-    if (!findByName) {
-      this.logger.warn('inbox not found');
-      return null;
-    }
-
-    this.cache.set(cacheKey, findByName);
-    return findByName;
-  }
-
-  public async createMessage(
-    instance: InstanceDto,
-    conversationId: number,
-    content: string,
-    messageType: 'incoming' | 'outgoing' | undefined,
-    privateMessage?: boolean,
-    attachments?: {
-      content: unknown;
-      encoding: string;
-      filename: string;
-    }[],
-    messageBody?: any,
-    sourceId?: string,
-    quotedMsg?: MessageModel,
-  ) {
-
-    if (sourceId && this.isImportHistoryAvailable()) {
-      const messageAlreadySaved = await chatwootImport.getExistingSourceIds([sourceId]);
-      if (messageAlreadySaved && messageAlreadySaved.size > 0) {
-        this.logger.warn('Message already saved on chatwoot');
-        return null;
+      this.logger.verbose(`Chat ID: ${chatId}`);
+
+      let nameContact: string;
+
+      nameContact = !body.key.fromMe ? body.pushName : phoneNumber;
+      this.logger.verbose(`Name contact: ${nameContact}`);
+
+      const filterInbox = await this.getInbox(instance);
+
+      if (!filterInbox) {
+        this.logger.warn(`Inbox not found for instance: ${JSON.stringify(instance)}`);
+        return null;
+      }
+
+      if (isGroup) {
+        this.logger.verbose('Processing group conversation');
+        const group = await this.waMonitor.waInstances[instance.instanceName].client.groupMetadata(chatId);
+        this.logger.verbose(`Group metadata: ${JSON.stringify(group)}`);
+
+        nameContact = `${group.subject} (GROUP)`;
+
+        const picture_url = await this.waMonitor.waInstances[instance.instanceName].profilePicture(
+          body.key.participant.split('@')[0],
+        );
+        this.logger.verbose(`Participant profile picture URL: ${JSON.stringify(picture_url)}`);
+
+        const findParticipant = await this.findContact(instance, body.key.participant.split('@')[0]);
+        this.logger.verbose(`Found participant: ${JSON.stringify(findParticipant)}`);
+
+        if (findParticipant) {
+          if (!findParticipant.name || findParticipant.name === phoneNumber) {
+            await this.updateContact(instance, findParticipant.id, {
+              name: body.pushName,
+              avatar_url: picture_url.profilePictureUrl || null,
+            });
+          }
+        } else {
+          await this.createContact(
+            instance,
+            body.key.participant.split('@')[0],
+            filterInbox.id,
+            false,
+            body.pushName,
+            picture_url.profilePictureUrl || null,
+            body.key.participant,
+          );
+        }
+      }
+
+      const picture_url = await this.waMonitor.waInstances[instance.instanceName].profilePicture(chatId);
+      this.logger.verbose(`Contact profile picture URL: ${JSON.stringify(picture_url)}`);
+
+      let contact = await this.findContact(instance, phoneNumber);
+      this.logger.verbose(`Found contact: ${JSON.stringify(contact)}`);
+
+      if (contact) {
+        if (!body.key.fromMe) {
+          const waProfilePictureFile =
+            picture_url?.profilePictureUrl?.split('#')[0].split('?')[0].split('/').pop() || '';
+          const chatwootProfilePictureFile = contact?.thumbnail?.split('#')[0].split('?')[0].split('/').pop() || '';
+          const pictureNeedsUpdate = waProfilePictureFile !== chatwootProfilePictureFile;
+          const nameNeedsUpdate =
+            !contact.name ||
+            contact.name === phoneNumber ||
+            (`+${phoneNumber}`.startsWith('+55')
+              ? this.getNumbers(`+${phoneNumber}`).some(
+                  (v) => contact.name === v || contact.name === v.substring(3) || contact.name === v.substring(1),
+                )
+              : false);
+
+          this.logger.verbose(`Picture needs update: ${pictureNeedsUpdate}`);
+          this.logger.verbose(`Name needs update: ${nameNeedsUpdate}`);
+
+          if (pictureNeedsUpdate || nameNeedsUpdate) {
+            contact = await this.updateContact(instance, contact.id, {
+              ...(nameNeedsUpdate && { name: nameContact }),
+              ...(waProfilePictureFile === '' && { avatar: null }),
+              ...(pictureNeedsUpdate && { avatar_url: picture_url?.profilePictureUrl }),
+            });
+          }
+        }
+      } else {
+        const jid = body.key.remoteJid;
+        contact = await this.createContact(
+          instance,
+          phoneNumber,
+          filterInbox.id,
+          isGroup,
+          nameContact,
+          picture_url.profilePictureUrl || null,
+          jid,
+        );
+      }
+
+      if (!contact) {
+        this.logger.warn('Contact not created or found');
+        return null;
+      }
+
+      const contactId = contact?.payload?.id || contact?.payload?.contact?.id || contact?.id;
+      this.logger.verbose(`Contact ID: ${contactId}`);
+
+      const contactConversations = (await client.contacts.listConversations({
+        accountId: this.provider.accountId,
+        id: contactId,
+      })) as any;
+      this.logger.verbose(`Contact conversations: ${JSON.stringify(contactConversations)}`);
+
+      if (!contactConversations || !contactConversations.payload) {
+        this.logger.error('No conversations found or payload is undefined');
+        return null;
+      }
+
+      if (contactConversations.payload.length) {
+        let conversation: any;
+        if (this.provider.reopenConversation) {
+          conversation = contactConversations.payload.find((conversation) => conversation.inbox_id == filterInbox.id);
+          this.logger.verbose(`Found conversation in reopenConversation mode: ${JSON.stringify(conversation)}`);
+
+          if (this.provider.conversationPending && conversation.status !== 'open') {
+            if (conversation) {
+              await client.conversations.toggleStatus({
+                accountId: this.provider.accountId,
+                conversationId: conversation.id,
+                data: {
+                  status: 'pending',
+                },
+              });
+            }
+          }
+        } else {
+          conversation = contactConversations.payload.find(
+            (conversation) => conversation.status !== 'resolved' && conversation.inbox_id == filterInbox.id,
+          );
+          this.logger.verbose(`Found conversation: ${JSON.stringify(conversation)}`);
+        }
+
+        if (conversation) {
+          this.logger.verbose(`Returning existing conversation ID: ${conversation.id}`);
+          this.cache.set(cacheKey, conversation.id);
+          return conversation.id;
+        }
+      }
+
+      const data = {
+        contact_id: contactId.toString(),
+        inbox_id: filterInbox.id.toString(),
+      };
+
+      if (this.provider.conversationPending) {
+        data['status'] = 'pending';
+      }
+
+      const conversation = await client.conversations.create({
+        accountId: this.provider.accountId,
+        data,
+      });
+
+      if (!conversation) {
+        this.logger.warn('Conversation not created or found');
+        return null;
+      }
+
+      this.logger.verbose(`New conversation created with ID: ${conversation.id}`);
+      this.cache.set(cacheKey, conversation.id);
+      return conversation.id;
+    } catch (error) {
+      this.logger.error(`Error in createConversation: ${error}`);
+    }
+  }
+
+  public async getInbox(instance: InstanceDto): Promise<inbox | null> {
+    const cacheKey = `${instance.instanceName}:getInbox`;
+    if (await this.cache.has(cacheKey)) {
+      return (await this.cache.get(cacheKey)) as inbox;
+    }
+
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    const inbox = (await client.inboxes.list({
+      accountId: this.provider.accountId,
+    })) as any;
+
+    if (!inbox) {
+      this.logger.warn('inbox not found');
+      return null;
+    }
+
+    const findByName = inbox.payload.find((inbox) => inbox.name === this.getClientCwConfig().nameInbox);
+
+    if (!findByName) {
+      this.logger.warn('inbox not found');
+      return null;
+    }
+
+    this.cache.set(cacheKey, findByName);
+    return findByName;
+  }
+
+  public async createMessage(
+    instance: InstanceDto,
+    conversationId: number,
+    content: string,
+    messageType: 'incoming' | 'outgoing' | undefined,
+    privateMessage?: boolean,
+    attachments?: {
+      content: unknown;
+      encoding: string;
+      filename: string;
+    }[],
+    messageBody?: any,
+    sourceId?: string,
+    quotedMsg?: MessageModel,
+  ) {
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    const replyToIds = await this.getReplyToIds(messageBody, instance);
+
+    const sourceReplyId = quotedMsg?.chatwootMessageId || null;
+
+    const message = await client.messages.create({
+      accountId: this.provider.accountId,
+      conversationId: conversationId,
+      data: {
+        content: content,
+        message_type: messageType,
+        attachments: attachments,
+        private: privateMessage || false,
+        source_id: sourceId,
+        content_attributes: {
+          ...replyToIds,
+        },
+        source_reply_id: sourceReplyId ? sourceReplyId.toString() : null,
+      },
+    });
+
+    if (!message) {
+      this.logger.warn('message not found');
+      return null;
+    }
+
+    return message;
+  }
+
+  public async getOpenConversationByContact(
+    instance: InstanceDto,
+    inbox: inbox,
+    contact: generic_id & contact,
+  ): Promise<conversation> {
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    const conversations = (await client.contacts.listConversations({
+      accountId: this.provider.accountId,
+      id: contact.id,
+    })) as any;
+
+    return (
+      conversations.payload.find(
+        (conversation) => conversation.inbox_id === inbox.id && conversation.status === 'open',
+      ) || undefined
+    );
+  }
+
+  public async createBotMessage(
+    instance: InstanceDto,
+    content: string,
+    messageType: 'incoming' | 'outgoing' | undefined,
+    attachments?: {
+      content: unknown;
+      encoding: string;
+      filename: string;
+    }[],
+  ) {
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    const contact = await this.findContact(instance, '123456');
+
+    if (!contact) {
+      this.logger.warn('contact not found');
+      return null;
+    }
+
+    const filterInbox = await this.getInbox(instance);
+
+    if (!filterInbox) {
+      this.logger.warn('inbox not found');
+      return null;
+    }
+
+    const conversation = await this.getOpenConversationByContact(instance, filterInbox, contact);
+
+    if (!conversation) {
+      this.logger.warn('conversation not found');
+      return;
+    }
+
+    const message = await client.messages.create({
+      accountId: this.provider.accountId,
+      conversationId: conversation.id,
+      data: {
+        content: content,
+        message_type: messageType,
+        attachments: attachments,
+      },
+    });
+
+    if (!message) {
+      this.logger.warn('message not found');
+      return null;
+    }
+
+    return message;
+  }
+
+  private async sendData(
+    conversationId: number,
+    fileStream: Readable,
+    fileName: string,
+    messageType: 'incoming' | 'outgoing' | undefined,
+    content?: string,
+    instance?: InstanceDto,
+    messageBody?: any,
+    sourceId?: string,
+    quotedMsg?: MessageModel,
+  ) {
+    if (sourceId && this.isImportHistoryAvailable()) {
+      const messageAlreadySaved = await chatwootImport.getExistingSourceIds([sourceId]);
+      if (messageAlreadySaved) {
+        if (messageAlreadySaved.size > 0) {
+          this.logger.warn('Message already saved on chatwoot');
+          return null;
+        }
+      }
+    }
+    const data = new FormData();
+
+    if (content) {
+      data.append('content', content);
+    }
+
+    data.append('message_type', messageType);
+
+    data.append('attachments[]', fileStream, { filename: fileName });
+
+    const sourceReplyId = quotedMsg?.chatwootMessageId || null;
+
+    if (messageBody && instance) {
+      const replyToIds = await this.getReplyToIds(messageBody, instance);
+
+      if (replyToIds.in_reply_to || replyToIds.in_reply_to_external_id) {
+        const content = JSON.stringify({
+          ...replyToIds,
+        });
+        data.append('content_attributes', content);
+      }
+    }
+
+    if (sourceReplyId) {
+      data.append('source_reply_id', sourceReplyId.toString());
+    }
+
+    if (sourceId) {
+      data.append('source_id', sourceId);
+    }
+
+    const config = {
+      method: 'post',
+      maxBodyLength: Infinity,
+      url: `${this.provider.url}/api/v1/accounts/${this.provider.accountId}/conversations/${conversationId}/messages`,
+      headers: {
+        api_access_token: this.provider.token,
+        ...data.getHeaders(),
+      },
+      data: data,
+    };
+
+    try {
+      const { data } = await axios.request(config);
+
+      return data;
+    } catch (error) {
+      this.logger.error(error);
+    }
+  }
+
+  public async createBotQr(
+    instance: InstanceDto,
+    content: string,
+    messageType: 'incoming' | 'outgoing' | undefined,
+    fileStream?: Readable,
+    fileName?: string,
+  ) {
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      this.logger.warn('client not found');
+      return null;
+    }
+
+    if (!this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT) {
+      this.logger.log('Chatwoot bot contact is disabled');
+
+      return true;
+    }
+
+    const contact = await this.findContact(instance, '123456');
+
+    if (!contact) {
+      this.logger.warn('contact not found');
+      return null;
+    }
+
+    const filterInbox = await this.getInbox(instance);
+
+    if (!filterInbox) {
+      this.logger.warn('inbox not found');
+      return null;
+    }
+
+    const conversation = await this.getOpenConversationByContact(instance, filterInbox, contact);
+
+    if (!conversation) {
+      this.logger.warn('conversation not found');
+      return;
+    }
+
+    const data = new FormData();
+
+    if (content) {
+      data.append('content', content);
+    }
+
+    data.append('message_type', messageType);
+
+    if (fileStream && fileName) {
+      data.append('attachments[]', fileStream, { filename: fileName });
+    }
+
+    const config = {
+      method: 'post',
+      maxBodyLength: Infinity,
+      url: `${this.provider.url}/api/v1/accounts/${this.provider.accountId}/conversations/${conversation.id}/messages`,
+      headers: {
+        api_access_token: this.provider.token,
+        ...data.getHeaders(),
+      },
+      data: data,
+    };
+
+    try {
+      const { data } = await axios.request(config);
+
+      return data;
+    } catch (error) {
+      this.logger.error(error);
+    }
+  }
+
+  public async sendAttachment(waInstance: any, number: string, media: any, caption?: string, options?: Options) {
+    try {
+      const parsedMedia = path.parse(decodeURIComponent(media));
+      let mimeType = mimeTypes.lookup(parsedMedia?.ext) || '';
+      let fileName = parsedMedia?.name + parsedMedia?.ext;
+
+      if (!mimeType) {
+        const parts = media.split('/');
+        fileName = decodeURIComponent(parts[parts.length - 1]);
+
+        const response = await axios.get(media, {
+          responseType: 'arraybuffer',
+        });
+        mimeType = response.headers['content-type'];
+      }
+
+      let type = 'document';
+
+      switch (mimeType.split('/')[0]) {
+        case 'image':
+          type = 'image';
+          break;
+        case 'video':
+          type = 'video';
+          break;
+        case 'audio':
+          type = 'audio';
+          break;
+        default:
+          type = 'document';
+          break;
+      }
+
+      if (type === 'audio') {
+        const data: SendAudioDto = {
+          number: number,
+          audio: media,
+          delay: 1200,
+          quoted: options?.quoted,
+        };
+
+        sendTelemetry('/message/sendWhatsAppAudio');
+
+        const messageSent = await waInstance?.audioWhatsapp(data, true);
+
+        return messageSent;
+      }
+
+      if (type === 'image' && parsedMedia && parsedMedia?.ext === '.gif') {
+        type = 'document';
+      }
+
+      const data: SendMediaDto = {
+        number: number,
+        mediatype: type as any,
+        fileName: fileName,
+        media: media,
+        delay: 1200,
+        quoted: options?.quoted,
+      };
+
+      sendTelemetry('/message/sendMedia');
+
+      if (caption) {
+        data.caption = caption;
+      }
+
+      const messageSent = await waInstance?.mediaMessage(data, null, true);
+
+      return messageSent;
+    } catch (error) {
+      this.logger.error(error);
+    }
+  }
+
+  public async onSendMessageError(instance: InstanceDto, conversation: number, error?: any) {
+    this.logger.verbose(`onSendMessageError ${JSON.stringify(error)}`);
+
+    const client = await this.clientCw(instance);
+
+    if (!client) {
+      return;
+    }
+
+    if (error && error?.status === 400 && error?.message[0]?.exists === false) {
+      client.messages.create({
+        accountId: this.provider.accountId,
+        conversationId: conversation,
+        data: {
+          content: `${i18next.t('cw.message.numbernotinwhatsapp')}`,
+          message_type: 'outgoing',
+          private: true,
+        },
+      });
+
+      return;
+    }
+
+    client.messages.create({
+      accountId: this.provider.accountId,
+      conversationId: conversation,
+      data: {
+        content: i18next.t('cw.message.notsent', {
+          error: error ? `_${error.toString()}_` : '',
+        }),
+        message_type: 'outgoing',
+        private: true,
+      },
+    });
+  }
+
+  public async receiveWebhook(instance: InstanceDto, body: any) {
+    try {
+      await new Promise((resolve) => setTimeout(resolve, 500));
+
+      const client = await this.clientCw(instance);
+
+      if (!client) {
+        this.logger.warn('client not found');
+        return null;
+      }
+
+      if (
+        this.provider.reopenConversation === false &&
+        body.event === 'conversation_status_changed' &&
+        body.status === 'resolved' &&
+        body.meta?.sender?.identifier
+      ) {
+        const keyToDelete = `${instance.instanceName}:createConversation-${body.meta.sender.identifier}`;
+        this.cache.delete(keyToDelete);
+      }
+
+      if (
+        !body?.conversation ||
+        body.private ||
+        (body.event === 'message_updated' && !body.content_attributes?.deleted)
+      ) {
+        return { message: 'bot' };
+      }
+
+      const identifier = body.conversation.meta.sender?.identifier;
+      const senderPhone = body.conversation.meta.sender?.phone_number?.replace('+', '');
+
+      let chatId = identifier || senderPhone;
+      if (identifier?.endsWith('@lid') && senderPhone) {
+        chatId = senderPhone;
       }
-    }
-
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      this.logger.warn('client not found');
-      return null;
-    }
-
-    const replyToIds = await this.getReplyToIds(messageBody, instance);
-
-    const sourceReplyId = quotedMsg?.chatwootMessageId || null;
-
-    const message = await client.messages.create({
-      accountId: this.provider.accountId,
-      conversationId: conversationId,
-      data: {
-        content: content,
-        message_type: messageType,
-        attachments: attachments,
-        private: privateMessage || false,
-        source_id: sourceId,
-        content_attributes: {
-          ...replyToIds,
-        },
-        source_reply_id: sourceReplyId ? sourceReplyId.toString() : null,
-      },
-    });
-
-    if (!message) {
-      this.logger.warn('message not found');
-      return null;
-    }
-
-    return message;
-  }
-
-  public async getOpenConversationByContact(
-    instance: InstanceDto,
-    inbox: inbox,
-    contact: generic_id & contact,
-  ): Promise<conversation> {
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      this.logger.warn('client not found');
-      return null;
-    }
-
-    const conversations = (await client.contacts.listConversations({
-      accountId: this.provider.accountId,
-      id: contact.id,
-    })) as any;
-
-    return (
-      conversations.payload.find(
-        (conversation) => conversation.inbox_id === inbox.id && conversation.status === 'open',
-      ) || undefined
-    );
-  }
-
-  public async createBotMessage(
-    instance: InstanceDto,
-    content: string,
-    messageType: 'incoming' | 'outgoing' | undefined,
-    attachments?: {
-      content: unknown;
-      encoding: string;
-      filename: string;
-    }[],
-  ) {
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      this.logger.warn('client not found');
-      return null;
-    }
-
-    const contact = await this.findContact(instance, '123456');
-
-    if (!contact) {
-      this.logger.warn('contact not found');
-      return null;
-    }
-
-    const filterInbox = await this.getInbox(instance);
-
-    if (!filterInbox) {
-      this.logger.warn('inbox not found');
-      return null;
-    }
-
-    const conversation = await this.getOpenConversationByContact(instance, filterInbox, contact);
-
-    if (!conversation) {
-      this.logger.warn('conversation not found');
-      return;
-    }
-
-    const message = await client.messages.create({
-      accountId: this.provider.accountId,
-      conversationId: conversation.id,
-      data: {
-        content: content,
-        message_type: messageType,
-        attachments: attachments,
-      },
-    });
-
-    if (!message) {
-      this.logger.warn('message not found');
-      return null;
-    }
-
-    return message;
-  }
-
-  private async sendData(
-    conversationId: number,
-    fileStream: Readable,
-    fileName: string,
-    messageType: 'incoming' | 'outgoing' | undefined,
-    content?: string,
-    instance?: InstanceDto,
-    messageBody?: any,
-    sourceId?: string,
-    quotedMsg?: MessageModel,
-  ) {
-    if (sourceId && this.isImportHistoryAvailable()) {
-      const messageAlreadySaved = await chatwootImport.getExistingSourceIds([sourceId]);
-      if (messageAlreadySaved) {
-        if (messageAlreadySaved.size > 0) {
-          this.logger.warn('Message already saved on chatwoot');
-          return null;
-        }
-      }
-    }
-    const data = new FormData();
-
-    if (content) {
-      data.append('content', content);
-    }
-
-    data.append('message_type', messageType);
-
-    data.append('attachments[]', fileStream, { filename: fileName });
-
-    const sourceReplyId = quotedMsg?.chatwootMessageId || null;
-
-    if (messageBody && instance) {
-      const replyToIds = await this.getReplyToIds(messageBody, instance);
-
-      if (replyToIds.in_reply_to || replyToIds.in_reply_to_external_id) {
-        const content = JSON.stringify({
-          ...replyToIds,
-        });
-        data.append('content_attributes', content);
-      }
-    }
-
-    if (sourceReplyId) {
-      data.append('source_reply_id', sourceReplyId.toString());
-    }
-
-    if (sourceId) {
-      data.append('source_id', sourceId);
-    }
-
-    const config = {
-      method: 'post',
-      maxBodyLength: Infinity,
-      url: `${this.provider.url}/api/v1/accounts/${this.provider.accountId}/conversations/${conversationId}/messages`,
-      headers: {
-        api_access_token: this.provider.token,
-        ...data.getHeaders(),
-      },
-      data: data,
-    };
-
-    try {
-      const { data } = await axios.request(config);
-
-      return data;
-    } catch (error) {
-      this.logger.error(error);
-    }
-  }
-
-  public async createBotQr(
-    instance: InstanceDto,
-    content: string,
-    messageType: 'incoming' | 'outgoing' | undefined,
-    fileStream?: Readable,
-    fileName?: string,
-  ) {
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      this.logger.warn('client not found');
-      return null;
-    }
-
-    if (!this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT) {
-      this.logger.log('Chatwoot bot contact is disabled');
-
-      return true;
-    }
-
-    const contact = await this.findContact(instance, '123456');
-
-    if (!contact) {
-      this.logger.warn('contact not found');
-      return null;
-    }
-
-    const filterInbox = await this.getInbox(instance);
-
-    if (!filterInbox) {
-      this.logger.warn('inbox not found');
-      return null;
-    }
-
-    const conversation = await this.getOpenConversationByContact(instance, filterInbox, contact);
-
-    if (!conversation) {
-      this.logger.warn('conversation not found');
-      return;
-    }
-
-    const data = new FormData();
-
-    if (content) {
-      data.append('content', content);
-    }
-
-    data.append('message_type', messageType);
-
-    if (fileStream && fileName) {
-      data.append('attachments[]', fileStream, { filename: fileName });
-    }
-
-    const config = {
-      method: 'post',
-      maxBodyLength: Infinity,
-      url: `${this.provider.url}/api/v1/accounts/${this.provider.accountId}/conversations/${conversation.id}/messages`,
-      headers: {
-        api_access_token: this.provider.token,
-        ...data.getHeaders(),
-      },
-      data: data,
-    };
-
-    try {
-      const { data } = await axios.request(config);
-
-      return data;
-    } catch (error) {
-      this.logger.error(error);
-    }
-  }
-
-  public async sendAttachment(waInstance: any, number: string, media: any, caption?: string, options?: Options) {
-    try {
-      const parsedMedia = path.parse(decodeURIComponent(media));
-      let mimeType = mimeTypes.lookup(parsedMedia?.ext) || '';
-      let fileName = parsedMedia?.name + parsedMedia?.ext;
-
-      if (!mimeType) {
-        const parts = media.split('/');
-        fileName = decodeURIComponent(parts[parts.length - 1]);
-
-        const response = await axios.get(media, {
-          responseType: 'arraybuffer',
-        });
-        mimeType = response.headers['content-type'];
-      }
-
-      let type = 'document';
-
-      switch (mimeType.split('/')[0]) {
-        case 'image':
-          type = 'image';
-          break;
-        case 'video':
-          type = 'video';
-          break;
-        case 'audio':
-          type = 'audio';
-          break;
-        default:
-          type = 'document';
-          break;
-      }
-
-      if (type === 'audio') {
-        const data: SendAudioDto = {
-          number: number,
-          audio: media,
-          delay: 1200,
-          quoted: options?.quoted,
-        };
-
-        sendTelemetry('/message/sendWhatsAppAudio');
-
-        const messageSent = await waInstance?.audioWhatsapp(data, true);
-
-        return messageSent;
-      }
-
-      if (type === 'image' && parsedMedia && parsedMedia?.ext === '.gif') {
-        type = 'document';
-      }
-
-      const data: SendMediaDto = {
-        number: number,
-        mediatype: type as any,
-        fileName: fileName,
-        media: media,
-        delay: 1200,
-        quoted: options?.quoted,
-      };
-
-      sendTelemetry('/message/sendMedia');
-
-      if (caption) {
-        data.caption = caption;
-      }
-
-      const messageSent = await waInstance?.mediaMessage(data, null, true);
-
-      return messageSent;
-    } catch (error) {
-      this.logger.error(error);
-    }
-  }
-
-  public async onSendMessageError(instance: InstanceDto, conversation: number, error?: any) {
-    this.logger.verbose(`onSendMessageError ${JSON.stringify(error)}`);
-
-    const client = await this.clientCw(instance);
-
-    if (!client) {
-      return;
-    }
-
-    if (error && error?.status === 400 && error?.message[0]?.exists === false) {
-      client.messages.create({
-        accountId: this.provider.accountId,
-        conversationId: conversation,
-        data: {
-          content: `${i18next.t('cw.message.numbernotinwhatsapp')}`,
-          message_type: 'outgoing',
-          private: true,
-        },
-      });
-
-      return;
-    }
-
-    client.messages.create({
-      accountId: this.provider.accountId,
-      conversationId: conversation,
-      data: {
-        content: i18next.t('cw.message.notsent', {
-          error: error ? `_${error.toString()}_` : '',
-        }),
-        message_type: 'outgoing',
-        private: true,
-      },
-    });
-  }
-
-  public async receiveWebhook(instance: InstanceDto, body: any) {
-    try {
-      await new Promise((resolve) => setTimeout(resolve, 500));
-
-      const client = await this.clientCw(instance);
-
-      if (!client) {
-        this.logger.warn('client not found');
-        return null;
-      }
-
-      if (
-        this.provider.reopenConversation === false &&
-        body.event === 'conversation_status_changed' &&
-        body.status === 'resolved' &&
-        body.meta?.sender?.identifier
-      ) {
-        const keyToDelete = `${instance.instanceName}:createConversation-${body.meta.sender.identifier}`;
-        this.cache.delete(keyToDelete);
-      }
-
-      if (
-        !body?.conversation ||
-        body.private ||
-        (body.event === 'message_updated' && !body.content_attributes?.deleted)
-      ) {
-        return { message: 'bot' };
-      }
-
-      const chatId =
-        body.conversation.meta.sender?.identifier || body.conversation.meta.sender?.phone_number.replace('+', '');
-      // Chatwoot to Whatsapp
-      const messageReceived = body.content
-        ? body.content
-          .replaceAll(/(?<!\*)\*((?!\s)([^\n*]+?)(?<!\s))\*(?!\*)/g, '_$1_') // Substitui * por _
-          .replaceAll(/\*{2}((?!\s)([^\n*]+?)(?<!\s))\*{2}/g, '*$1*') // Substitui ** por *
-          .replaceAll(/~{2}((?!\s)([^\n*]+?)(?<!\s))~{2}/g, '~$1~') // Substitui ~~ por ~
-          .replaceAll(/(?<!`)`((?!\s)([^`*]+?)(?<!\s))`(?!`)/g, '```$1```') // Substitui ` por ```
-        : body.content;
-
-      const senderName = body?.conversation?.messages[0]?.sender?.available_name || body?.sender?.name;
-      const waInstance = this.waMonitor.waInstances[instance.instanceName];
-
-      if (body.event === 'message_updated' && body.content_attributes?.deleted) {
-        const message = await this.prismaRepository.message.findFirst({
-          where: {
-            chatwootMessageId: body.id,
-            instanceId: instance.instanceId,
-          },
-        });
-
-        if (message) {
-          const key = message.key as {
-            id: string;
-            remoteJid: string;
-            fromMe: boolean;
-            participant: string;
-          };
-
-          await waInstance?.client.sendMessage(key.remoteJid, { delete: key });
-
-          await this.prismaRepository.message.deleteMany({
-            where: {
-              instanceId: instance.instanceId,
-              chatwootMessageId: body.id,
-            },
-          });
-        }
-        return { message: 'bot' };
-      }
-
-      const cwBotContact = this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT;
-
-      if (chatId === '123456' && body.message_type === 'outgoing') {
-        const command = messageReceived.replace('/', '');
-
-        if (cwBotContact && (command.includes('init') || command.includes('iniciar'))) {
-          const state = waInstance?.connectionStatus?.state;
-
-          if (state !== 'open') {
-            const number = command.split(':')[1];
-            await waInstance.connectToWhatsapp(number);
-          } else {
-            await this.createBotMessage(
-              instance,
-              i18next.t('cw.inbox.alreadyConnected', {
-                inboxName: body.inbox.name,
-              }),
-              'incoming',
-            );
-          }
-        }
-
-        if (command === 'clearcache') {
-          waInstance.clearCacheChatwoot();
-          await this.createBotMessage(
-            instance,
-            i18next.t('cw.inbox.clearCache', {
-              inboxName: body.inbox.name,
-            }),
-            'incoming',
-          );
-        }
-
-        if (command === 'status') {
-          const state = waInstance?.connectionStatus?.state;
-
-          if (!state) {
-            await this.createBotMessage(
-              instance,
-              i18next.t('cw.inbox.notFound', {
-                inboxName: body.inbox.name,
-              }),
-              'incoming',
-            );
-          }
-
-          if (state) {
-            await this.createBotMessage(
-              instance,
-              i18next.t('cw.inbox.status', {
-                inboxName: body.inbox.name,
-                state: state,
-              }),
-              'incoming',
-            );
-          }
-        }
-
-        if (cwBotContact && (command === 'disconnect' || command === 'desconectar')) {
-          const msgLogout = i18next.t('cw.inbox.disconnect', {
-            inboxName: body.inbox.name,
-          });
-
-          await this.createBotMessage(instance, msgLogout, 'incoming');
-
-          await waInstance?.client?.logout('Log out instance: ' + instance.instanceName);
-          await waInstance?.client?.ws?.close();
-        }
-      }
-
-      if (body.message_type === 'outgoing' && body?.conversation?.messages?.length && chatId !== '123456') {
-        if (body?.conversation?.messages[0]?.source_id?.substring(0, 5) === 'WAID:') {
-          return { message: 'bot' };
-        }
-
-        if (!waInstance && body.conversation?.id) {
-          this.onSendMessageError(instance, body.conversation?.id, 'Instance not found');
-          return { message: 'bot' };
-        }
-
-        let formatText: string;
-        if (senderName === null || senderName === undefined) {
-          formatText = messageReceived;
-        } else {
-          const formattedDelimiter = this.provider.signDelimiter
-            ? this.provider.signDelimiter.replaceAll('\\n', '\n')
-            : '\n';
-          const textToConcat = this.provider.signMsg ? [`*${senderName}:*`] : [];
-          textToConcat.push(messageReceived);
-
-          formatText = textToConcat.join(formattedDelimiter);
-        }
-
-        for (const message of body.conversation.messages) {
-          if (message.attachments && message.attachments.length > 0) {
-            for (const attachment of message.attachments) {
-              if (!messageReceived) {
-                formatText = null;
-              }
-
-              const options: Options = {
-                quoted: await this.getQuotedMessage(body, instance),
-              };
-
+      // Chatwoot to Whatsapp
+      const messageReceived = body.content
+        ? body.content
+            .replaceAll(/(?<!\*)\*((?!\s)([^\n*]+?)(?<!\s))\*(?!\*)/g, '_$1_') // Substitui * por _
+            .replaceAll(/\*{2}((?!\s)([^\n*]+?)(?<!\s))\*{2}/g, '*$1*') // Substitui ** por *
+            .replaceAll(/~{2}((?!\s)([^\n*]+?)(?<!\s))~{2}/g, '~$1~') // Substitui ~~ por ~
+            .replaceAll(/(?<!`)`((?!\s)([^`*]+?)(?<!\s))`(?!`)/g, '```$1```') // Substitui ` por ```
+        : body.content;
+
+      const senderName = body?.conversation?.messages[0]?.sender?.available_name || body?.sender?.name;
+      const waInstance = this.waMonitor.waInstances[instance.instanceName];
+
+      if (body.event === 'message_updated' && body.content_attributes?.deleted) {
+        const message = await this.prismaRepository.message.findFirst({
+          where: {
+            chatwootMessageId: body.id,
+            instanceId: instance.instanceId,
+          },
+        });
+
+        if (message) {
+          const key = message.key as {
+            id: string;
+            remoteJid: string;
+            fromMe: boolean;
+            participant: string;
+          };
+
+          await waInstance?.client.sendMessage(key.remoteJid, { delete: key });
+
+          await this.prismaRepository.message.deleteMany({
+            where: {
+              instanceId: instance.instanceId,
+              chatwootMessageId: body.id,
+            },
+          });
+        }
+        return { message: 'bot' };
+      }
+
+      const cwBotContact = this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT;
+
+      if (chatId === '123456' && body.message_type === 'outgoing') {
+        const command = messageReceived.replace('/', '');
+
+        if (cwBotContact && (command.includes('init') || command.includes('iniciar'))) {
+          const state = waInstance?.connectionStatus?.state;
+
+          if (state !== 'open') {
+            const number = command.split(':')[1];
+            await waInstance.connectToWhatsapp(number);
+          } else {
+            await this.createBotMessage(
+              instance,
+              i18next.t('cw.inbox.alreadyConnected', {
+                inboxName: body.inbox.name,
+              }),
+              'incoming',
+            );
+          }
+        }
+
+        if (command === 'clearcache') {
+          waInstance.clearCacheChatwoot();
+          await this.createBotMessage(
+            instance,
+            i18next.t('cw.inbox.clearCache', {
+              inboxName: body.inbox.name,
+            }),
+            'incoming',
+          );
+        }
+
+        if (command === 'status') {
+          const state = waInstance?.connectionStatus?.state;
+
+          if (!state) {
+            await this.createBotMessage(
+              instance,
+              i18next.t('cw.inbox.notFound', {
+                inboxName: body.inbox.name,
+              }),
+              'incoming',
+            );
+          }
+
+          if (state) {
+            await this.createBotMessage(
+              instance,
+              i18next.t('cw.inbox.status', {
+                inboxName: body.inbox.name,
+                state: state,
+              }),
+              'incoming',
+            );
+          }
+        }
+
+        if (cwBotContact && (command === 'disconnect' || command === 'desconectar')) {
+          const msgLogout = i18next.t('cw.inbox.disconnect', {
+            inboxName: body.inbox.name,
+          });
+
+          await this.createBotMessage(instance, msgLogout, 'incoming');
+
+          await waInstance?.client?.logout('Log out instance: ' + instance.instanceName);
+          await waInstance?.client?.ws?.close();
+        }
+      }
+
+      if (body.message_type === 'outgoing' && body?.conversation?.messages?.length && chatId !== '123456') {
+        if (body?.conversation?.messages[0]?.source_id?.substring(0, 5) === 'WAID:') {
+          return { message: 'bot' };
+        }
+
+        if (!waInstance && body.conversation?.id) {
+          this.onSendMessageError(instance, body.conversation?.id, 'Instance not found');
+          return { message: 'bot' };
+        }
+
+        let formatText: string;
+        if (senderName === null || senderName === undefined) {
+          formatText = messageReceived;
+        } else {
+          const formattedDelimiter = this.provider.signDelimiter
+            ? this.provider.signDelimiter.replaceAll('\\n', '\n')
+            : '\n';
+          const textToConcat = this.provider.signMsg ? [`*${senderName}:*`] : [];
+          textToConcat.push(messageReceived);
+
+          formatText = textToConcat.join(formattedDelimiter);
+        }
+
+        for (const message of body.conversation.messages) {
+          if (message.attachments && message.attachments.length > 0) {
+            for (const attachment of message.attachments) {
+              if (!messageReceived) {
+                formatText = null;
+              }
+
+              const options: Options = {
+                quoted: await this.getQuotedMessage(body, instance),
+              };
+
               const messageSent = await this.sendAttachment(
                 waInstance,
-                chatId,
+                createJid(chatId),
                 attachment.data_url,
                 formatText,
                 options,
               );
-              if (!messageSent && body.conversation?.id) {
-                this.onSendMessageError(instance, body.conversation?.id);
-              }
-
-              await this.updateChatwootMessageId(
-                {
-                  ...messageSent,
-                  owner: instance.instanceName,
-                },
-                {
-                  messageId: body.id,
-                  inboxId: body.inbox?.id,
-                  conversationId: body.conversation?.id,
-                  contactInboxSourceId: body.conversation?.contact_inbox?.source_id,
-                },
-                instance,
-              );
-            }
-          } else {
+              if (!messageSent && body.conversation?.id) {
+                this.onSendMessageError(instance, body.conversation?.id);
+              }
+
+              await this.updateChatwootMessageId(
+                {
+                  ...messageSent,
+                  owner: instance.instanceName,
+                },
+                {
+                  messageId: body.id,
+                  inboxId: body.inbox?.id,
+                  conversationId: body.conversation?.id,
+                  contactInboxSourceId: body.conversation?.contact_inbox?.source_id,
+                },
+                instance,
+              );
+            }
+          } else {
             const data: SendTextDto = {
-              number: chatId,
+              number: createJid(chatId),
               text: formatText,
               delay: 1200,
               quoted: await this.getQuotedMessage(body, instance),
             };
-
-            sendTelemetry('/message/sendText');
-
-            let messageSent: any;
-            try {
-              messageSent = await waInstance?.textMessage(data, true);
-              if (!messageSent) {
-                throw new Error('Message not sent');
-              }
-
-              if (Long.isLong(messageSent?.messageTimestamp)) {
-                messageSent.messageTimestamp = messageSent.messageTimestamp?.toNumber();
-              }
-
-              await this.updateChatwootMessageId(
-                {
-                  ...messageSent,
-                  instanceId: instance.instanceId,
-                },
-                {
-                  messageId: body.id,
-                  inboxId: body.inbox?.id,
-                  conversationId: body.conversation?.id,
-                  contactInboxSourceId: body.conversation?.contact_inbox?.source_id,
-                },
-                instance,
-              );
-            } catch (error) {
-              if (!messageSent && body.conversation?.id) {
-                this.onSendMessageError(instance, body.conversation?.id, error);
-              }
-              throw error;
-            }
-          }
-        }
-
-        const chatwootRead = this.configService.get<Chatwoot>('CHATWOOT').MESSAGE_READ;
-        if (chatwootRead) {
-          const lastMessage = await this.prismaRepository.message.findFirst({
-            where: {
-              key: {
-                path: ['fromMe'],
-                equals: false,
-              },
-              instanceId: instance.instanceId,
-            },
-          });
-          if (lastMessage && !lastMessage.chatwootIsRead) {
-            const key = lastMessage.key as {
-              id: string;
-              fromMe: boolean;
-              remoteJid: string;
-              participant?: string;
-            };
-
-            waInstance?.markMessageAsRead({
-              readMessages: [
-                {
-                  id: key.id,
-                  fromMe: key.fromMe,
-                  remoteJid: key.remoteJid,
-                },
-              ],
-            });
-            const updateMessage = {
-              chatwootMessageId: lastMessage.chatwootMessageId,
-              chatwootConversationId: lastMessage.chatwootConversationId,
-              chatwootInboxId: lastMessage.chatwootInboxId,
-              chatwootContactInboxSourceId: lastMessage.chatwootContactInboxSourceId,
-              chatwootIsRead: true,
-            };
-
-            await this.prismaRepository.message.updateMany({
-              where: {
-                instanceId: instance.instanceId,
-                key: {
-                  path: ['id'],
-                  equals: key.id,
-                },
-              },
-              data: updateMessage,
-            });
-          }
-        }
-      }
-
+
+            sendTelemetry('/message/sendText');
+
+            let messageSent: any;
+            try {
+              messageSent = await waInstance?.textMessage(data, true);
+              if (!messageSent) {
+                throw new Error('Message not sent');
+              }
+
+              if (Long.isLong(messageSent?.messageTimestamp)) {
+                messageSent.messageTimestamp = messageSent.messageTimestamp?.toNumber();
+              }
+
+              await this.updateChatwootMessageId(
+                {
+                  ...messageSent,
+                  instanceId: instance.instanceId,
+                },
+                {
+                  messageId: body.id,
+                  inboxId: body.inbox?.id,
+                  conversationId: body.conversation?.id,
+                  contactInboxSourceId: body.conversation?.contact_inbox?.source_id,
+                },
+                instance,
+              );
+            } catch (error) {
+              if (!messageSent && body.conversation?.id) {
+                this.onSendMessageError(instance, body.conversation?.id, error);
+              }
+              throw error;
+            }
+          }
+        }
+
+        const chatwootRead = this.configService.get<Chatwoot>('CHATWOOT').MESSAGE_READ;
+        if (chatwootRead) {
+          const lastMessage = await this.prismaRepository.message.findFirst({
+            where: {
+              key: {
+                path: ['fromMe'],
+                equals: false,
+              },
+              instanceId: instance.instanceId,
+            },
+          });
+          if (lastMessage && !lastMessage.chatwootIsRead) {
+            const key = lastMessage.key as {
+              id: string;
+              fromMe: boolean;
+              remoteJid: string;
+              participant?: string;
+            };
+
+            waInstance?.markMessageAsRead({
+              readMessages: [
+                {
+                  id: key.id,
+                  fromMe: key.fromMe,
+                  remoteJid: key.remoteJid,
+                },
+              ],
+            });
+            const updateMessage = {
+              chatwootMessageId: lastMessage.chatwootMessageId,
+              chatwootConversationId: lastMessage.chatwootConversationId,
+              chatwootInboxId: lastMessage.chatwootInboxId,
+              chatwootContactInboxSourceId: lastMessage.chatwootContactInboxSourceId,
+              chatwootIsRead: true,
+            };
+
+            await this.prismaRepository.message.updateMany({
+              where: {
+                instanceId: instance.instanceId,
+                key: {
+                  path: ['id'],
+                  equals: key.id,
+                },
+              },
+              data: updateMessage,
+            });
+          }
+        }
+      }
+
       if (body.message_type === 'template' && body.event === 'message_created') {
         const data: SendTextDto = {
-          number: chatId,
-          text: body.content.replace(/\\\r\n|\\\n|\n/g, '\n'),
+          number: createJid(chatId),
+          text: body.content.replace(/\\r\\n|\\n|\n/g, '\n'),
           delay: 1200,
         };
-
-        sendTelemetry('/message/sendText');
-
-        await waInstance?.textMessage(data);
-      }
-
-      return { message: 'bot' };
-    } catch (error) {
-      this.logger.error(error);
-
-      return { message: 'bot' };
-    }
-  }
-
-  private async updateChatwootMessageId(
-    message: MessageModel,
-    chatwootMessageIds: ChatwootMessage,
-    instance: InstanceDto,
-  ) {
-    const key = message.key as {
-      id: string;
-      fromMe: boolean;
-      remoteJid: string;
-      participant?: string;
-    };
-
-    if (!chatwootMessageIds.messageId || !key?.id) {
-      return;
-    }
-
-    await this.prismaRepository.message.updateMany({
-      where: {
-        key: {
-          path: ['id'],
-          equals: key.id,
-        },
-        instanceId: instance.instanceId,
-      },
-      data: {
-        chatwootMessageId: chatwootMessageIds.messageId,
-        chatwootConversationId: chatwootMessageIds.conversationId,
-        chatwootInboxId: chatwootMessageIds.inboxId,
-        chatwootContactInboxSourceId: chatwootMessageIds.contactInboxSourceId,
-        chatwootIsRead: chatwootMessageIds.isRead,
-      },
-    });
-
-    if (this.isImportHistoryAvailable()) {
-      chatwootImport.updateMessageSourceID(chatwootMessageIds.messageId, key.id);
-    }
-  }
-
-  private async getMessageByKeyId(instance: InstanceDto, keyId: string): Promise<MessageModel> {
-    const messages = await this.prismaRepository.message.findFirst({
-      where: {
-        key: {
-          path: ['id'],
-          equals: keyId,
-        },
-        instanceId: instance.instanceId,
-      },
-    });
-
-    return messages || null;
-  }
-
-  private async getReplyToIds(
-    msg: any,
-    instance: InstanceDto,
-  ): Promise<{ in_reply_to: string; in_reply_to_external_id: string }> {
-    let inReplyTo = null;
-    let inReplyToExternalId = null;
-
-    if (msg) {
-      inReplyToExternalId = msg.message?.extendedTextMessage?.contextInfo?.stanzaId ?? msg.contextInfo?.stanzaId;
-      if (inReplyToExternalId) {
-        const message = await this.getMessageByKeyId(instance, inReplyToExternalId);
-        if (message?.chatwootMessageId) {
-          inReplyTo = message.chatwootMessageId;
-        }
-      }
-    }
-
-    return {
-      in_reply_to: inReplyTo,
-      in_reply_to_external_id: inReplyToExternalId,
-    };
-  }
-
-  private async getQuotedMessage(msg: any, instance: InstanceDto): Promise<Quoted> {
-    if (msg?.content_attributes?.in_reply_to) {
-      const message = await this.prismaRepository.message.findFirst({
-        where: {
-          chatwootMessageId: msg?.content_attributes?.in_reply_to,
-          instanceId: instance.instanceId,
-        },
-      });
-
-      const key = message?.key as {
-        id: string;
-        fromMe: boolean;
-        remoteJid: string;
-        participant?: string;
-      };
-
-      if (message && key?.id) {
-        return {
-          key: message.key as proto.IMessageKey,
-          message: message.message as proto.IMessage,
-        };
-      }
-    }
-
-    return null;
-  }
-
-  private isMediaMessage(message: any) {
-    const media = [
-      'imageMessage',
-      'documentMessage',
-      'documentWithCaptionMessage',
-      'audioMessage',
-      'videoMessage',
-      'stickerMessage',
-      'viewOnceMessageV2',
-    ];
-
-    const messageKeys = Object.keys(message);
-
-    const result = messageKeys.some((key) => media.includes(key));
-
-    return result;
-  }
-
-  private getAdsMessage(msg: any) {
-    interface AdsMessage {
-      title: string;
-      body: string;
-      thumbnailUrl: string;
-      sourceUrl: string;
-    }
-
-    const adsMessage: AdsMessage | undefined = {
-      title: msg.extendedTextMessage?.contextInfo?.externalAdReply?.title || msg.contextInfo?.externalAdReply?.title,
-      body: msg.extendedTextMessage?.contextInfo?.externalAdReply?.body || msg.contextInfo?.externalAdReply?.body,
-      thumbnailUrl:
-        msg.extendedTextMessage?.contextInfo?.externalAdReply?.thumbnailUrl ||
-        msg.contextInfo?.externalAdReply?.thumbnailUrl,
-      sourceUrl:
-        msg.extendedTextMessage?.contextInfo?.externalAdReply?.sourceUrl || msg.contextInfo?.externalAdReply?.sourceUrl,
-    };
-
-    return adsMessage;
-  }
-
-  private getReactionMessage(msg: any) {
-    interface ReactionMessage {
-      key: {
-        id: string;
-        fromMe: boolean;
-        remoteJid: string;
-        participant?: string;
-      };
-      text: string;
-    }
-    const reactionMessage: ReactionMessage | undefined = msg?.reactionMessage;
-
-    return reactionMessage;
-  }
-
-  private getTypeMessage(msg: any) {
-    const types = {
-      conversation: msg.conversation,
-      imageMessage: msg.imageMessage?.caption,
-      videoMessage: msg.videoMessage?.caption,
-      extendedTextMessage: msg.extendedTextMessage?.text,
-      messageContextInfo: msg.messageContextInfo?.stanzaId,
-      stickerMessage: undefined,
-      documentMessage: msg.documentMessage?.caption,
-      documentWithCaptionMessage: msg.documentWithCaptionMessage?.message?.documentMessage?.caption,
-      audioMessage: msg.audioMessage?.caption,
-      contactMessage: msg.contactMessage?.vcard,
-      contactsArrayMessage: msg.contactsArrayMessage,
-      locationMessage: msg.locationMessage,
-      liveLocationMessage: msg.liveLocationMessage,
-      listMessage: msg.listMessage,
-      listResponseMessage: msg.listResponseMessage,
-      viewOnceMessageV2:
-        msg?.message?.viewOnceMessageV2?.message?.imageMessage?.url ||
-        msg?.message?.viewOnceMessageV2?.message?.videoMessage?.url ||
-        msg?.message?.viewOnceMessageV2?.message?.audioMessage?.url,
-    };
-
-    return types;
-  }
-
-  private getMessageContent(types: any) {
-    const typeKey = Object.keys(types).find((key) => types[key] !== undefined);
-
-    let result = typeKey ? types[typeKey] : undefined;
-
-    // Remove externalAdReplyBody| in Chatwoot (Already Have)
-    if (result && typeof result === 'string' && result.includes('externalAdReplyBody|')) {
-      result = result.split('externalAdReplyBody|').filter(Boolean).join('');
-    }
-
-    if (typeKey === 'locationMessage' || typeKey === 'liveLocationMessage') {
-      const latitude = result.degreesLatitude;
-      const longitude = result.degreesLongitude;
-
-      const locationName = result?.name;
-      const locationAddress = result?.address;
-
-      const formattedLocation =
-        `*${i18next.t('cw.locationMessage.location')}:*\n\n` +
-        `_${i18next.t('cw.locationMessage.latitude')}:_ ${latitude} \n` +
-        `_${i18next.t('cw.locationMessage.longitude')}:_ ${longitude} \n` +
-        (locationName ? `_${i18next.t('cw.locationMessage.locationName')}:_ ${locationName}\n` : '') +
-        (locationAddress ? `_${i18next.t('cw.locationMessage.locationAddress')}:_ ${locationAddress} \n` : '') +
-        `_${i18next.t('cw.locationMessage.locationUrl')}:_ ` +
-        `https://www.google.com/maps/search/?api=1&query=${latitude},${longitude}`;
-
-      return formattedLocation;
-    }
-
-    if (typeKey === 'contactMessage') {
-      const vCardData = result.split('\n');
-      const contactInfo = {};
-
-      vCardData.forEach((line) => {
-        const [key, value] = line.split(':');
-        if (key && value) {
-          contactInfo[key] = value;
-        }
-      });
-
-      let formattedContact =
-        `*${i18next.t('cw.contactMessage.contact')}:*\n\n` +
-        `_${i18next.t('cw.contactMessage.name')}:_ ${contactInfo['FN']}`;
-
-      let numberCount = 1;
-      Object.keys(contactInfo).forEach((key) => {
-        if (key.startsWith('item') && key.includes('TEL')) {
-          const phoneNumber = contactInfo[key];
-          formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
-          numberCount++;
-        } else if (key.includes('TEL')) {
-          const phoneNumber = contactInfo[key];
-          formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
-          numberCount++;
-        }
-      });
-
-      return formattedContact;
-    }
-
-    if (typeKey === 'contactsArrayMessage') {
-      const formattedContacts = result.contacts.map((contact) => {
-        const vCardData = contact.vcard.split('\n');
-        const contactInfo = {};
-
-        vCardData.forEach((line) => {
-          const [key, value] = line.split(':');
-          if (key && value) {
-            contactInfo[key] = value;
-          }
-        });
-
-        let formattedContact = `*${i18next.t('cw.contactMessage.contact')}:*\n\n_${i18next.t(
-          'cw.contactMessage.name',
-        )}:_ ${contact.displayName}`;
-
-        let numberCount = 1;
-        Object.keys(contactInfo).forEach((key) => {
-          if (key.startsWith('item') && key.includes('TEL')) {
-            const phoneNumber = contactInfo[key];
-            formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
-            numberCount++;
-          } else if (key.includes('TEL')) {
-            const phoneNumber = contactInfo[key];
-            formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
-            numberCount++;
-          }
-        });
-
-        return formattedContact;
-      });
-
-      const formattedContactsArray = formattedContacts.join('\n\n');
-
-      return formattedContactsArray;
-    }
-
-    if (typeKey === 'listMessage') {
-      const listTitle = result?.title || 'Unknown';
-      const listDescription = result?.description || 'Unknown';
-      const listFooter = result?.footerText || 'Unknown';
-
-      let formattedList =
-        '*List Menu:*\n\n' +
-        '_Title_: ' +
-        listTitle +
-        '\n' +
-        '_Description_: ' +
-        listDescription +
-        '\n' +
-        '_Footer_: ' +
-        listFooter;
-
-      if (result.sections && result.sections.length > 0) {
-        result.sections.forEach((section, sectionIndex) => {
-          formattedList += '\n\n*Section ' + (sectionIndex + 1) + ':* ' + section.title || 'Unknown\n';
-
-          if (section.rows && section.rows.length > 0) {
-            section.rows.forEach((row, rowIndex) => {
-              formattedList += '\n*Line ' + (rowIndex + 1) + ':*\n';
-              formattedList += '_▪️ Title:_ ' + (row.title || 'Unknown') + '\n';
-              formattedList += '_▪️ Description:_ ' + (row.description || 'Unknown') + '\n';
-              formattedList += '_▪️ ID:_ ' + (row.rowId || 'Unknown') + '\n';
-            });
-          } else {
-            formattedList += '\nNo lines found in this section.\n';
-          }
-        });
-      } else {
-        formattedList += '\nNo sections found.\n';
-      }
-
-      return formattedList;
-    }
-
-    if (typeKey === 'listResponseMessage') {
-      const responseTitle = result?.title || 'Unknown';
-      const responseDescription = result?.description || 'Unknown';
-      const responseRowId = result?.singleSelectReply?.selectedRowId || 'Unknown';
-
-      const formattedResponseList =
-        '*List Response:*\n\n' +
-        '_Title_: ' +
-        responseTitle +
-        '\n' +
-        '_Description_: ' +
-        responseDescription +
-        '\n' +
-        '_ID_: ' +
-        responseRowId;
-      return formattedResponseList;
-    }
-
-    return result;
-  }
-
-  public getConversationMessage(msg: any) {
-    const types = this.getTypeMessage(msg);
-
-    const messageContent = this.getMessageContent(types);
-
-    return messageContent;
-  }
-
-  public async eventWhatsapp(event: string, instance: InstanceDto, body: any) {
-    try {
-      const waInstance = this.waMonitor.waInstances[instance.instanceName];
-
-      if (!waInstance) {
-        this.logger.warn('wa instance not found');
-        return null;
-      }
-
-      const client = await this.clientCw(instance);
-
-      if (!client) {
-        this.logger.warn('client not found');
-        return null;
-      }
-
-      if (this.provider?.ignoreJids && this.provider?.ignoreJids.length > 0) {
-        const ignoreJids: any = this.provider?.ignoreJids;
-
-        let ignoreGroups = false;
-        let ignoreContacts = false;
-
-        if (ignoreJids.includes('@g.us')) {
-          ignoreGroups = true;
-        }
-
-        if (ignoreJids.includes('@s.whatsapp.net')) {
-          ignoreContacts = true;
-        }
-
-        if (ignoreGroups && body?.key?.remoteJid.endsWith('@g.us')) {
-          this.logger.warn('Ignoring message from group: ' + body?.key?.remoteJid);
-          return;
-        }
-
-        if (ignoreContacts && body?.key?.remoteJid.endsWith('@s.whatsapp.net')) {
+
+        sendTelemetry('/message/sendText');
+
+        await waInstance?.textMessage(data);
+      }
+
+      return { message: 'bot' };
+    } catch (error) {
+      this.logger.error(error);
+
+      return { message: 'bot' };
+    }
+  }
+
+  private async updateChatwootMessageId(
+    message: MessageModel,
+    chatwootMessageIds: ChatwootMessage,
+    instance: InstanceDto,
+  ) {
+    const key = message.key as {
+      id: string;
+      fromMe: boolean;
+      remoteJid: string;
+      participant?: string;
+    };
+
+    if (!chatwootMessageIds.messageId || !key?.id) {
+      return;
+    }
+
+    await this.prismaRepository.message.updateMany({
+      where: {
+        key: {
+          path: ['id'],
+          equals: key.id,
+        },
+        instanceId: instance.instanceId,
+      },
+      data: {
+        chatwootMessageId: chatwootMessageIds.messageId,
+        chatwootConversationId: chatwootMessageIds.conversationId,
+        chatwootInboxId: chatwootMessageIds.inboxId,
+        chatwootContactInboxSourceId: chatwootMessageIds.contactInboxSourceId,
+        chatwootIsRead: chatwootMessageIds.isRead,
+      },
+    });
+
+    if (this.isImportHistoryAvailable()) {
+      chatwootImport.updateMessageSourceID(chatwootMessageIds.messageId, key.id);
+    }
+  }
+
+  private async getMessageByKeyId(instance: InstanceDto, keyId: string): Promise<MessageModel> {
+    const messages = await this.prismaRepository.message.findFirst({
+      where: {
+        key: {
+          path: ['id'],
+          equals: keyId,
+        },
+        instanceId: instance.instanceId,
+      },
+    });
+
+    return messages || null;
+  }
+
+  private async getReplyToIds(
+    msg: any,
+    instance: InstanceDto,
+  ): Promise<{ in_reply_to: string; in_reply_to_external_id: string }> {
+    let inReplyTo = null;
+    let inReplyToExternalId = null;
+
+    if (msg) {
+      inReplyToExternalId = msg.message?.extendedTextMessage?.contextInfo?.stanzaId ?? msg.contextInfo?.stanzaId;
+      if (inReplyToExternalId) {
+        const message = await this.getMessageByKeyId(instance, inReplyToExternalId);
+        if (message?.chatwootMessageId) {
+          inReplyTo = message.chatwootMessageId;
+        }
+      }
+    }
+
+    return {
+      in_reply_to: inReplyTo,
+      in_reply_to_external_id: inReplyToExternalId,
+    };
+  }
+
+  private async getQuotedMessage(msg: any, instance: InstanceDto): Promise<Quoted> {
+    if (msg?.content_attributes?.in_reply_to) {
+      const message = await this.prismaRepository.message.findFirst({
+        where: {
+          chatwootMessageId: msg?.content_attributes?.in_reply_to,
+          instanceId: instance.instanceId,
+        },
+      });
+
+      const key = message?.key as {
+        id: string;
+        fromMe: boolean;
+        remoteJid: string;
+        participant?: string;
+      };
+
+      if (message && key?.id) {
+        return {
+          key: message.key as proto.IMessageKey,
+          message: message.message as proto.IMessage,
+        };
+      }
+    }
+
+    return null;
+  }
+
+  private isMediaMessage(message: any) {
+    const media = [
+      'imageMessage',
+      'documentMessage',
+      'documentWithCaptionMessage',
+      'audioMessage',
+      'videoMessage',
+      'stickerMessage',
+      'viewOnceMessageV2',
+    ];
+
+    const messageKeys = Object.keys(message);
+
+    const result = messageKeys.some((key) => media.includes(key));
+
+    return result;
+  }
+
+  private getAdsMessage(msg: any) {
+    interface AdsMessage {
+      title: string;
+      body: string;
+      thumbnailUrl: string;
+      sourceUrl: string;
+    }
+
+    const adsMessage: AdsMessage | undefined = {
+      title: msg.extendedTextMessage?.contextInfo?.externalAdReply?.title || msg.contextInfo?.externalAdReply?.title,
+      body: msg.extendedTextMessage?.contextInfo?.externalAdReply?.body || msg.contextInfo?.externalAdReply?.body,
+      thumbnailUrl:
+        msg.extendedTextMessage?.contextInfo?.externalAdReply?.thumbnailUrl ||
+        msg.contextInfo?.externalAdReply?.thumbnailUrl,
+      sourceUrl:
+        msg.extendedTextMessage?.contextInfo?.externalAdReply?.sourceUrl || msg.contextInfo?.externalAdReply?.sourceUrl,
+    };
+
+    return adsMessage;
+  }
+
+  private getReactionMessage(msg: any) {
+    interface ReactionMessage {
+      key: {
+        id: string;
+        fromMe: boolean;
+        remoteJid: string;
+        participant?: string;
+      };
+      text: string;
+    }
+    const reactionMessage: ReactionMessage | undefined = msg?.reactionMessage;
+
+    return reactionMessage;
+  }
+
+  private getTypeMessage(msg: any) {
+    const types = {
+      conversation: msg.conversation,
+      imageMessage: msg.imageMessage?.caption,
+      videoMessage: msg.videoMessage?.caption,
+      extendedTextMessage: msg.extendedTextMessage?.text,
+      messageContextInfo: msg.messageContextInfo?.stanzaId,
+      stickerMessage: undefined,
+      documentMessage: msg.documentMessage?.caption,
+      documentWithCaptionMessage: msg.documentWithCaptionMessage?.message?.documentMessage?.caption,
+      audioMessage: msg.audioMessage?.caption,
+      contactMessage: msg.contactMessage?.vcard,
+      contactsArrayMessage: msg.contactsArrayMessage,
+      locationMessage: msg.locationMessage,
+      liveLocationMessage: msg.liveLocationMessage,
+      listMessage: msg.listMessage,
+      listResponseMessage: msg.listResponseMessage,
+      viewOnceMessageV2:
+        msg?.message?.viewOnceMessageV2?.message?.imageMessage?.url ||
+        msg?.message?.viewOnceMessageV2?.message?.videoMessage?.url ||
+        msg?.message?.viewOnceMessageV2?.message?.audioMessage?.url,
+    };
+
+    return types;
+  }
+
+  private getMessageContent(types: any) {
+    const typeKey = Object.keys(types).find((key) => types[key] !== undefined);
+
+    let result = typeKey ? types[typeKey] : undefined;
+
+    // Remove externalAdReplyBody| in Chatwoot (Already Have)
+    if (result && typeof result === 'string' && result.includes('externalAdReplyBody|')) {
+      result = result.split('externalAdReplyBody|').filter(Boolean).join('');
+    }
+
+    if (typeKey === 'locationMessage' || typeKey === 'liveLocationMessage') {
+      const latitude = result.degreesLatitude;
+      const longitude = result.degreesLongitude;
+
+      const locationName = result?.name;
+      const locationAddress = result?.address;
+
+      const formattedLocation =
+        `*${i18next.t('cw.locationMessage.location')}:*\n\n` +
+        `_${i18next.t('cw.locationMessage.latitude')}:_ ${latitude} \n` +
+        `_${i18next.t('cw.locationMessage.longitude')}:_ ${longitude} \n` +
+        (locationName ? `_${i18next.t('cw.locationMessage.locationName')}:_ ${locationName}\n` : '') +
+        (locationAddress ? `_${i18next.t('cw.locationMessage.locationAddress')}:_ ${locationAddress} \n` : '') +
+        `_${i18next.t('cw.locationMessage.locationUrl')}:_ ` +
+        `https://www.google.com/maps/search/?api=1&query=${latitude},${longitude}`;
+
+      return formattedLocation;
+    }
+
+    if (typeKey === 'contactMessage') {
+      const vCardData = result.split('\n');
+      const contactInfo = {};
+
+      vCardData.forEach((line) => {
+        const [key, value] = line.split(':');
+        if (key && value) {
+          contactInfo[key] = value;
+        }
+      });
+
+      let formattedContact =
+        `*${i18next.t('cw.contactMessage.contact')}:*\n\n` +
+        `_${i18next.t('cw.contactMessage.name')}:_ ${contactInfo['FN']}`;
+
+      let numberCount = 1;
+      Object.keys(contactInfo).forEach((key) => {
+        if (key.startsWith('item') && key.includes('TEL')) {
+          const phoneNumber = contactInfo[key];
+          formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
+          numberCount++;
+        } else if (key.includes('TEL')) {
+          const phoneNumber = contactInfo[key];
+          formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
+          numberCount++;
+        }
+      });
+
+      return formattedContact;
+    }
+
+    if (typeKey === 'contactsArrayMessage') {
+      const formattedContacts = result.contacts.map((contact) => {
+        const vCardData = contact.vcard.split('\n');
+        const contactInfo = {};
+
+        vCardData.forEach((line) => {
+          const [key, value] = line.split(':');
+          if (key && value) {
+            contactInfo[key] = value;
+          }
+        });
+
+        let formattedContact = `*${i18next.t('cw.contactMessage.contact')}:*\n\n_${i18next.t(
+          'cw.contactMessage.name',
+        )}:_ ${contact.displayName}`;
+
+        let numberCount = 1;
+        Object.keys(contactInfo).forEach((key) => {
+          if (key.startsWith('item') && key.includes('TEL')) {
+            const phoneNumber = contactInfo[key];
+            formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
+            numberCount++;
+          } else if (key.includes('TEL')) {
+            const phoneNumber = contactInfo[key];
+            formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
+            numberCount++;
+          }
+        });
+
+        return formattedContact;
+      });
+
+      const formattedContactsArray = formattedContacts.join('\n\n');
+
+      return formattedContactsArray;
+    }
+
+    if (typeKey === 'listMessage') {
+      const listTitle = result?.title || 'Unknown';
+      const listDescription = result?.description || 'Unknown';
+      const listFooter = result?.footerText || 'Unknown';
+
+      let formattedList =
+        '*List Menu:*\n\n' +
+        '_Title_: ' +
+        listTitle +
+        '\n' +
+        '_Description_: ' +
+        listDescription +
+        '\n' +
+        '_Footer_: ' +
+        listFooter;
+
+      if (result.sections && result.sections.length > 0) {
+        result.sections.forEach((section, sectionIndex) => {
+          formattedList += '\n\n*Section ' + (sectionIndex + 1) + ':* ' + section.title || 'Unknown\n';
+
+          if (section.rows && section.rows.length > 0) {
+            section.rows.forEach((row, rowIndex) => {
+              formattedList += '\n*Line ' + (rowIndex + 1) + ':*\n';
+              formattedList += '_▪️ Title:_ ' + (row.title || 'Unknown') + '\n';
+              formattedList += '_▪️ Description:_ ' + (row.description || 'Unknown') + '\n';
+              formattedList += '_▪️ ID:_ ' + (row.rowId || 'Unknown') + '\n';
+            });
+          } else {
+            formattedList += '\nNo lines found in this section.\n';
+          }
+        });
+      } else {
+        formattedList += '\nNo sections found.\n';
+      }
+
+      return formattedList;
+    }
+
+    if (typeKey === 'listResponseMessage') {
+      const responseTitle = result?.title || 'Unknown';
+      const responseDescription = result?.description || 'Unknown';
+      const responseRowId = result?.singleSelectReply?.selectedRowId || 'Unknown';
+
+      const formattedResponseList =
+        '*List Response:*\n\n' +
+        '_Title_: ' +
+        responseTitle +
+        '\n' +
+        '_Description_: ' +
+        responseDescription +
+        '\n' +
+        '_ID_: ' +
+        responseRowId;
+      return formattedResponseList;
+    }
+
+    return result;
+  }
+
+  public getConversationMessage(msg: any) {
+    const types = this.getTypeMessage(msg);
+
+    const messageContent = this.getMessageContent(types);
+
+    return messageContent;
+  }
+
+  public async eventWhatsapp(event: string, instance: InstanceDto, body: any) {
+    try {
+      const waInstance = this.waMonitor.waInstances[instance.instanceName];
+
+      if (!waInstance) {
+        this.logger.warn('wa instance not found');
+        return null;
+      }
+
+      const client = await this.clientCw(instance);
+
+      if (!client) {
+        this.logger.warn('client not found');
+        return null;
+      }
+
+      if (this.provider?.ignoreJids && this.provider?.ignoreJids.length > 0) {
+        const ignoreJids: any = this.provider?.ignoreJids;
+
+        let ignoreGroups = false;
+        let ignoreContacts = false;
+
+        if (ignoreJids.includes('@g.us')) {
+          ignoreGroups = true;
+        }
+
+        if (ignoreJids.includes('@s.whatsapp.net')) {
+          ignoreContacts = true;
+        }
+
+        if (ignoreGroups && body?.key?.remoteJid.endsWith('@g.us')) {
+          this.logger.warn('Ignoring message from group: ' + body?.key?.remoteJid);
+          return;
+        }
+
+        if (
+          ignoreContacts &&
+          (body?.key?.remoteJid.endsWith('@s.whatsapp.net') ||
+            body?.key?.remoteJid.endsWith('@lid'))
+        ) {
           this.logger.warn('Ignoring message from contact: ' + body?.key?.remoteJid);
           return;
         }
-
-        if (ignoreJids.includes(body?.key?.remoteJid)) {
-          this.logger.warn('Ignoring message from jid: ' + body?.key?.remoteJid);
-          return;
-        }
-      }
-
-      if (event === 'messages.upsert' || event === 'send.message') {
-        if (body.key.remoteJid === 'status@broadcast') {
-          return;
-        }
-
-        if (body.message?.ephemeralMessage?.message) {
-          body.message = {
-            ...body.message?.ephemeralMessage?.message,
-          };
-        }
-
-        const originalMessage = await this.getConversationMessage(body.message);
-        const bodyMessage = originalMessage
-          ? originalMessage
-            .replaceAll(/\*((?!\s)([^\n*]+?)(?<!\s))\*/g, '**$1**')
-            .replaceAll(/_((?!\s)([^\n_]+?)(?<!\s))_/g, '*$1*')
-            .replaceAll(/~((?!\s)([^\n~]+?)(?<!\s))~/g, '~~$1~~')
-          : originalMessage;
-
-        if (bodyMessage && bodyMessage.includes('Por favor, classifique esta conversa, http')) {
-          return;
-        }
-
-        const quotedId = body.contextInfo?.stanzaId || body.message?.contextInfo?.stanzaId;
-
-        let quotedMsg = null;
-
-        if (quotedId)
-          quotedMsg = await this.prismaRepository.message.findFirst({
-            where: {
-              key: {
-                path: ['id'],
-                equals: quotedId,
-              },
-              chatwootMessageId: {
-                not: null,
-              },
-            },
-          });
-
-        const isMedia = this.isMediaMessage(body.message);
-
-        const adsMessage = this.getAdsMessage(body);
-
-        const reactionMessage = this.getReactionMessage(body.message);
-
-        if (!bodyMessage && !isMedia && !reactionMessage) {
-          this.logger.warn('no body message found');
-          return;
-        }
-
-        const getConversation = await this.createConversation(instance, body);
-
-        if (!getConversation) {
-          this.logger.warn('conversation not found');
-          return;
-        }
-
-        const messageType = body.key.fromMe ? 'outgoing' : 'incoming';
-
-        if (isMedia) {
-          const downloadBase64 = await waInstance?.getBase64FromMediaMessage({
-            message: {
-              ...body,
-            },
-          });
-
-          let nameFile: string;
-          const messageBody = body?.message[body?.messageType];
-          const originalFilename =
-            messageBody?.fileName || messageBody?.filename || messageBody?.message?.documentMessage?.fileName;
-          if (originalFilename) {
-            const parsedFile = path.parse(originalFilename);
-            if (parsedFile.name && parsedFile.ext) {
-              nameFile = `${parsedFile.name}-${Math.floor(Math.random() * (99 - 10 + 1) + 10)}${parsedFile.ext}`;
-            }
-          }
-
-          if (!nameFile) {
-            nameFile = `${Math.random().toString(36).substring(7)}.${mimeTypes.extension(downloadBase64.mimetype) || ''}`;
-          }
-
-          const fileData = Buffer.from(downloadBase64.base64, 'base64');
-
-          const fileStream = new Readable();
-          fileStream._read = () => { };
-          fileStream.push(fileData);
-          fileStream.push(null);
-
-          if (body.key.remoteJid.includes('@g.us')) {
-            const participantName = body.pushName;
-            const rawPhoneNumber = body.key.participant.split('@')[0];
-            const phoneMatch = rawPhoneNumber.match(/^(\d{2})(\d{2})(\d{4})(\d{4})$/);
-
-            let formattedPhoneNumber: string;
-
-            if (phoneMatch) {
-              formattedPhoneNumber = `+${phoneMatch[1]} (${phoneMatch[2]}) ${phoneMatch[3]}-${phoneMatch[4]}`;
-            } else {
-              formattedPhoneNumber = `+${rawPhoneNumber}`;
-            }
-
-            let content: string;
-
-            if (!body.key.fromMe) {
-              content = `**${formattedPhoneNumber} - ${participantName}:**\n\n${bodyMessage}`;
-            } else {
-              content = `${bodyMessage}`;
-            }
-
-            const send = await this.sendData(
-              getConversation,
-              fileStream,
-              nameFile,
-              messageType,
-              content,
-              instance,
-              body,
-              'WAID:' + body.key.id,
-              quotedMsg,
-            );
-
-            if (!send) {
-              this.logger.warn('message not sent');
-              return;
-            }
-
-            return send;
-          } else {
-            const send = await this.sendData(
-              getConversation,
-              fileStream,
-              nameFile,
-              messageType,
-              bodyMessage,
-              instance,
-              body,
-              'WAID:' + body.key.id,
-              quotedMsg,
-            );
-
-            if (!send) {
-              this.logger.warn('message not sent');
-              return;
-            }
-
-            return send;
-          }
-        }
-
-        if (reactionMessage) {
-          if (reactionMessage.text) {
-            const send = await this.createMessage(
-              instance,
-              getConversation,
-              reactionMessage.text,
-              messageType,
-              false,
-              [],
-              {
-                message: { extendedTextMessage: { contextInfo: { stanzaId: reactionMessage.key.id } } },
-              },
-              'WAID:' + body.key.id,
-              quotedMsg,
-            );
-            if (!send) {
-              this.logger.warn('message not sent');
-              return;
-            }
-          }
-
-          return;
-        }
-
-        const isAdsMessage = (adsMessage && adsMessage.title) || adsMessage.body || adsMessage.thumbnailUrl;
-        if (isAdsMessage) {
-          const imgBuffer = await axios.get(adsMessage.thumbnailUrl, { responseType: 'arraybuffer' });
-
-          const extension = mimeTypes.extension(imgBuffer.headers['content-type']);
-          const mimeType = extension && mimeTypes.lookup(extension);
-
-          if (!mimeType) {
-            this.logger.warn('mimetype of Ads message not found');
-            return;
-          }
-
-          const random = Math.random().toString(36).substring(7);
-          const nameFile = `${random}.${mimeTypes.extension(mimeType)}`;
-          const fileData = Buffer.from(imgBuffer.data, 'binary');
-
-          const img = await Jimp.read(fileData);
-          await img.cover(320, 180);
-
-          const processedBuffer = await img.getBufferAsync(Jimp.MIME_PNG);
-
-          const fileStream = new Readable();
-          fileStream._read = () => { }; // _read is required but you can noop it
-          fileStream.push(processedBuffer);
-          fileStream.push(null);
-
-          const truncStr = (str: string, len: number) => {
-            if (!str) return '';
-
-            return str.length > len ? str.substring(0, len) + '...' : str;
-          };
-
-          const title = truncStr(adsMessage.title, 40);
-          const description = truncStr(adsMessage?.body, 75);
-
-          const send = await this.sendData(
-            getConversation,
-            fileStream,
-            nameFile,
-            messageType,
-            `${bodyMessage}\n\n\n**${title}**\n${description}\n${adsMessage.sourceUrl}`,
-            instance,
-            body,
-            'WAID:' + body.key.id,
-          );
-
-          if (!send) {
-            this.logger.warn('message not sent');
-            return;
-          }
-
-          return send;
-        }
-
-        if (body.key.remoteJid.includes('@g.us')) {
-          // Extrai de forma segura o JID do participante
-          const participantJid = body.key.participant;
-          
-          // Se não veio participant, envia mensagem crua
-          if (!participantJid) {
-            const rawContent = bodyMessage;
-            const sent = await this.createMessage(
-              instance,
-              getConversation,
-              rawContent,
-              messageType,
-              false,
-              [],
-              body,
-              'WAID:' + body.key.id,
-              quotedMsg,
-            );
-            if (!sent) this.logger.warn('message not sent');
-            return sent;
-          }
-        
-          // Formata o telefone
-          const rawPhone = participantJid.split('@')[0];
-          const match = rawPhone.match(/^(\d{2})(\d{2})(\d{4})(\d{4})$/);
-          const formattedPhone = match
-            ? `+${match[1]} (${match[2]}) ${match[3]}-${match[4]}`
-            : `+${rawPhone}`;
-        
-          // Define prefixo com número e nome (ou só número, se pushName vazio)
-          const name = body.pushName?.trim();
-          const prefix = name
-            ? `**${formattedPhone} – ${name}:**\n\n`
-            : `**${formattedPhone}:**\n\n`;
-        
-          // Monta o conteúdo, omitindo prefixo em mensagens enviadas por mim
-          const content = body.key.fromMe
-            ? bodyMessage
-            : `${prefix}${bodyMessage}`;
-        
-          // Envia a mensagem formatada
-          const sent = await this.createMessage(
-            instance,
-            getConversation,
-            content,
-            messageType,
-            false,
-            [],
-            body,
-            'WAID:' + body.key.id,
-            quotedMsg,
-          );
-          if (!sent) this.logger.warn('message not sent');
-          return sent;
-        } else {
-          const send = await this.createMessage(
-            instance,
-            getConversation,
-            bodyMessage,
-            messageType,
-            false,
-            [],
-            body,
-            'WAID:' + body.key.id,
-            quotedMsg,
-          );
-
-          if (!send) {
-            this.logger.warn('message not sent');
-            return;
-          }
-
-          return send;
-        }
-      }
-
-      if (event === Events.MESSAGES_DELETE) {
-        const chatwootDelete = this.configService.get<Chatwoot>('CHATWOOT').MESSAGE_DELETE;
-
-        if (chatwootDelete === true) {
-          if (!body?.key?.id) {
-            this.logger.warn('message id not found');
-            return;
-          }
-
-          const message = await this.getMessageByKeyId(instance, body.key.id);
-
-          if (message?.chatwootMessageId && message?.chatwootConversationId) {
-            await this.prismaRepository.message.deleteMany({
-              where: {
-                key: {
-                  path: ['id'],
-                  equals: body.key.id,
-                },
-                instanceId: instance.instanceId,
-              },
-            });
-
-            return await client.messages.delete({
-              accountId: this.provider.accountId,
-              conversationId: message.chatwootConversationId,
-              messageId: message.chatwootMessageId,
-            });
-          }
-        }
-      }
-
-      if (event === 'messages.edit') {
-        const editedText = `${body?.editedMessage?.conversation || body?.editedMessage?.extendedTextMessage?.text
-          }\n\n_\`${i18next.t('cw.message.edited')}.\`_`;
-        const message = await this.getMessageByKeyId(instance, body?.key?.id);
-        const key = message.key as {
-          id: string;
-          fromMe: boolean;
-          remoteJid: string;
-          participant?: string;
-        };
-
-        const messageType = key?.fromMe ? 'outgoing' : 'incoming';
-
-        if (message && message.chatwootConversationId) {
-          const send = await this.createMessage(
-            instance,
-            message.chatwootConversationId,
-            editedText,
-            messageType,
-            false,
-            [],
-            {
-              message: { extendedTextMessage: { contextInfo: { stanzaId: key.id } } },
-            },
-            'WAID:' + body.key.id,
-            null,
-          );
-          if (!send) {
-            this.logger.warn('edited message not sent');
-            return;
-          }
-        }
-        return;
-      }
-
-      if (event === 'messages.read') {
-        if (!body?.key?.id || !body?.key?.remoteJid) {
-          this.logger.warn('message id not found');
-          return;
-        }
-
-        const message = await this.getMessageByKeyId(instance, body.key.id);
-        const conversationId = message?.chatwootConversationId;
-        const contactInboxSourceId = message?.chatwootContactInboxSourceId;
-
-        if (conversationId) {
-          let sourceId = contactInboxSourceId;
-          const inbox = (await this.getInbox(instance)) as inbox & {
-            inbox_identifier?: string;
-          };
-
-          if (!sourceId && inbox) {
-            const conversation = (await client.conversations.get({
-              accountId: this.provider.accountId,
-              conversationId: conversationId,
-            })) as conversation_show & {
-              last_non_activity_message: { conversation: { contact_inbox: contact_inboxes } };
-            };
-            sourceId = conversation.last_non_activity_message?.conversation?.contact_inbox?.source_id;
-          }
-
-          if (sourceId && inbox?.inbox_identifier) {
-            const url =
-              `/public/api/v1/inboxes/${inbox.inbox_identifier}/contacts/${sourceId}` +
-              `/conversations/${conversationId}/update_last_seen`;
-            chatwootRequest(this.getClientCwConfig(), {
-              method: 'POST',
-              url: url,
-            });
-          }
-        }
-        return;
-      }
-
-      if (event === 'status.instance') {
-        const data = body;
-        const inbox = await this.getInbox(instance);
-
-        if (!inbox) {
-          this.logger.warn('inbox not found');
-          return;
-        }
-
-        const msgStatus = i18next.t('cw.inbox.status', {
-          inboxName: inbox.name,
-          state: data.status,
-        });
-
-        await this.createBotMessage(instance, msgStatus, 'incoming');
-      }
-
-      if (event === 'connection.update') {
-        if (body.status === 'open') {
-          // if we have qrcode count then we understand that a new connection was established
-          if (this.waMonitor.waInstances[instance.instanceName].qrCode.count > 0) {
-            const msgConnection = i18next.t('cw.inbox.connected');
-            await this.createBotMessage(instance, msgConnection, 'incoming');
-            this.waMonitor.waInstances[instance.instanceName].qrCode.count = 0;
-            chatwootImport.clearAll(instance);
-          }
-        }
-      }
-
-      if (event === 'qrcode.updated') {
-        if (body.statusCode === 500) {
-          const erroQRcode = `🚨 ${i18next.t('qrlimitreached')}`;
-          return await this.createBotMessage(instance, erroQRcode, 'incoming');
-        } else {
-          const fileData = Buffer.from(body?.qrcode.base64.replace('data:image/png;base64,', ''), 'base64');
-
-          const fileStream = new Readable();
-          fileStream._read = () => { };
-          fileStream.push(fileData);
-          fileStream.push(null);
-
-          await this.createBotQr(
-            instance,
-            i18next.t('qrgeneratedsuccesfully'),
-            'incoming',
-            fileStream,
-            `${instance.instanceName}.png`,
-          );
-
-          let msgQrCode = `⚡️${i18next.t('qrgeneratedsuccesfully')}\n\n${i18next.t('scanqr')}`;
-
-          if (body?.qrcode?.pairingCode) {
-            msgQrCode =
-              msgQrCode +
-              `\n\n*Pairing Code:* ${body.qrcode.pairingCode.substring(0, 4)}-${body.qrcode.pairingCode.substring(
-                4,
-                8,
-              )}`;
-          }
-
-          await this.createBotMessage(instance, msgQrCode, 'incoming');
-        }
-      }
-    } catch (error) {
-      this.logger.error(error);
-    }
-  }
-
-  public getNumberFromRemoteJid(remoteJid: string) {
-    return remoteJid.replace(/:\d+/, '').split('@')[0];
-  }
-
-  public startImportHistoryMessages(instance: InstanceDto) {
-    if (!this.isImportHistoryAvailable()) {
-      return;
-    }
-
-    this.createBotMessage(instance, i18next.t('cw.import.startImport'), 'incoming');
-  }
-
-  public isImportHistoryAvailable() {
-    const uri = this.configService.get<Chatwoot>('CHATWOOT').IMPORT.DATABASE.CONNECTION.URI;
-
-    return uri && uri !== 'postgres://user:password@hostname:port/dbname';
-  }
-
-  public addHistoryMessages(instance: InstanceDto, messagesRaw: MessageModel[]) {
-    if (!this.isImportHistoryAvailable()) {
-      return;
-    }
-
-    chatwootImport.addHistoryMessages(instance, messagesRaw);
-  }
-
-  public addHistoryContacts(instance: InstanceDto, contactsRaw: ContactModel[]) {
-    if (!this.isImportHistoryAvailable()) {
-      return;
-    }
-
-    return chatwootImport.addHistoryContacts(instance, contactsRaw);
-  }
-
-  public async importHistoryMessages(instance: InstanceDto) {
-    if (!this.isImportHistoryAvailable()) {
-      return;
-    }
-
-    this.createBotMessage(instance, i18next.t('cw.import.importingMessages'), 'incoming');
-
-    const totalMessagesImported = await chatwootImport.importHistoryMessages(
-      instance,
-      this,
-      await this.getInbox(instance),
-      this.provider,
-    );
-    this.updateContactAvatarInRecentConversations(instance);
-
-    const msg = Number.isInteger(totalMessagesImported)
-      ? i18next.t('cw.import.messagesImported', { totalMessagesImported })
-      : i18next.t('cw.import.messagesException');
-
-    this.createBotMessage(instance, msg, 'incoming');
-
-    return totalMessagesImported;
-  }
-
-  public async updateContactAvatarInRecentConversations(instance: InstanceDto, limitContacts = 100) {
-    try {
-      if (!this.isImportHistoryAvailable()) {
-        return;
-      }
-
-      const client = await this.clientCw(instance);
-      if (!client) {
-        this.logger.warn('client not found');
-        return null;
-      }
-
-      const inbox = await this.getInbox(instance);
-      if (!inbox) {
-        this.logger.warn('inbox not found');
-        return null;
-      }
-
-      const recentContacts = await chatwootImport.getContactsOrderByRecentConversations(
-        inbox,
-        this.provider,
-        limitContacts,
-      );
-
-      const contactIdentifiers = recentContacts
-        .map((contact) => contact.identifier)
-        .filter((identifier) => identifier !== null);
-
-      const contactsWithProfilePicture = (
-        await this.prismaRepository.contact.findMany({
-          where: {
-            instanceId: instance.instanceId,
-            id: {
-              in: contactIdentifiers,
-            },
-            profilePicUrl: {
-              not: null,
-            },
-          },
-        })
-      ).reduce((acc: Map<string, ContactModel>, contact: ContactModel) => acc.set(contact.id, contact), new Map());
-
-      for (const c of recentContacts) {
-        const pic = contactsWithProfilePicture.get(c.identifier);
-        if (!pic) continue;
-
-        try {
-          await client.contacts.update({
-            accountId: this.provider.accountId,
-            id: c.id,
-            data: {
-              avatar_url: pic.profilePictureUrl || null,
-            },
-          });
-          this.logger.verbose(`Avatar atualizado para o contato ${c.id}`);
-        } catch (err) {
-          this.logger.error(`Falha ao atualizar avatar do contato ${c.id}: ${err}`);
-        }
-      }
-
-
-
-    } catch (error) {
-      this.logger.error(`Error on update avatar in recent conversations: ${error.toString()}`);
-    }
-  }
-
-  public async syncLostMessages(
-    instance: InstanceDto,
-    chatwootConfig: ChatwootDto,
-    prepareMessage: (message: any) => any,
-  ) {
-    try {
-      if (!this.isImportHistoryAvailable()) {
-        return;
-      }
-      if (!this.configService.get<Database>('DATABASE').SAVE_DATA.MESSAGE_UPDATE) {
-        return;
-      }
-
-      const inbox = await this.getInbox(instance);
-
-      const sqlMessages = `select * from messages m
-        where account_id = ${chatwootConfig.accountId}
-        and inbox_id = ${inbox.id}
-        and created_at >= now() - interval '6h'
-        order by created_at desc`;
-
-      const messagesData = (await this.pgClient.query(sqlMessages))?.rows;
-      const ids: string[] = messagesData
-        .filter((message) => !!message.source_id)
-        .map((message) => message.source_id.replace('WAID:', ''));
-
-      const savedMessages = await this.prismaRepository.message.findMany({
-        where: {
-          Instance: { name: instance.instanceName },
-          messageTimestamp: { gte: dayjs().subtract(6, 'hours').unix() },
-          AND: ids.map((id) => ({ key: { path: ['id'], not: id } })),
-        },
-      });
-
-      const filteredMessages = savedMessages.filter(
-        (msg: any) => !chatwootImport.isIgnorePhoneNumber(msg.key?.remoteJid),
-      );
-      const messagesRaw: any[] = [];
-      for (const m of filteredMessages) {
-        if (!m.message || !m.key || !m.messageTimestamp) {
-          continue;
-        }
-
-        if (Long.isLong(m?.messageTimestamp)) {
-          m.messageTimestamp = m.messageTimestamp?.toNumber();
-        }
-
-        messagesRaw.push(prepareMessage(m as any));
-      }
-
-      this.addHistoryMessages(
-        instance,
-        messagesRaw.filter((msg) => !chatwootImport.isIgnorePhoneNumber(msg.key?.remoteJid)),
-      );
-
-      await chatwootImport.importHistoryMessages(instance, this, inbox, this.provider);
-      const waInstance = this.waMonitor.waInstances[instance.instanceName];
-      waInstance.clearCacheChatwoot();
-    } catch (error) {
-      return;
-    }
+
+        if (ignoreJids.includes(body?.key?.remoteJid)) {
+          this.logger.warn('Ignoring message from jid: ' + body?.key?.remoteJid);
+          return;
+        }
+      }
+
+      if (event === 'messages.upsert' || event === 'send.message') {
+        if (body.key.remoteJid === 'status@broadcast') {
+          return;
+        }
+
+        if (body.message?.ephemeralMessage?.message) {
+          body.message = {
+            ...body.message?.ephemeralMessage?.message,
+          };
+        }
+
+        const originalMessage = await this.getConversationMessage(body.message);
+        const bodyMessage = originalMessage
+          ? originalMessage
+              .replaceAll(/\*((?!\s)([^\n*]+?)(?<!\s))\*/g, '**$1**')
+              .replaceAll(/_((?!\s)([^\n_]+?)(?<!\s))_/g, '*$1*')
+              .replaceAll(/~((?!\s)([^\n~]+?)(?<!\s))~/g, '~~$1~~')
+          : originalMessage;
+
+        if (bodyMessage && bodyMessage.includes('Por favor, classifique esta conversa, http')) {
+          return;
+        }
+
+        const quotedId = body.contextInfo?.stanzaId || body.message?.contextInfo?.stanzaId;
+
+        let quotedMsg = null;
+
+        if (quotedId)
+          quotedMsg = await this.prismaRepository.message.findFirst({
+            where: {
+              key: {
+                path: ['id'],
+                equals: quotedId,
+              },
+              chatwootMessageId: {
+                not: null,
+              },
+            },
+          });
+
+        const isMedia = this.isMediaMessage(body.message);
+
+        const adsMessage = this.getAdsMessage(body);
+
+        const reactionMessage = this.getReactionMessage(body.message);
+
+        if (!bodyMessage && !isMedia && !reactionMessage) {
+          this.logger.warn('no body message found');
+          return;
+        }
+
+        const getConversation = await this.createConversation(instance, body);
+
+        if (!getConversation) {
+          this.logger.warn('conversation not found');
+          return;
+        }
+
+        const messageType = body.key.fromMe ? 'outgoing' : 'incoming';
+
+        if (isMedia) {
+          const downloadBase64 = await waInstance?.getBase64FromMediaMessage({
+            message: {
+              ...body,
+            },
+          });
+
+          let nameFile: string;
+          const messageBody = body?.message[body?.messageType];
+          const originalFilename =
+            messageBody?.fileName || messageBody?.filename || messageBody?.message?.documentMessage?.fileName;
+          if (originalFilename) {
+            const parsedFile = path.parse(originalFilename);
+            if (parsedFile.name && parsedFile.ext) {
+              nameFile = `${parsedFile.name}-${Math.floor(Math.random() * (99 - 10 + 1) + 10)}${parsedFile.ext}`;
+            }
+          }
+
+          if (!nameFile) {
+            nameFile = `${Math.random().toString(36).substring(7)}.${mimeTypes.extension(downloadBase64.mimetype) || ''}`;
+          }
+
+          const fileData = Buffer.from(downloadBase64.base64, 'base64');
+
+          const fileStream = new Readable();
+          fileStream._read = () => {};
+          fileStream.push(fileData);
+          fileStream.push(null);
+
+          if (body.key.remoteJid.includes('@g.us')) {
+            const participantName = body.pushName;
+            const rawPhoneNumber = body.key.participant.split('@')[0];
+            const phoneMatch = rawPhoneNumber.match(/^(\d{2})(\d{2})(\d{4})(\d{4})$/);
+
+            let formattedPhoneNumber: string;
+
+            if (phoneMatch) {
+              formattedPhoneNumber = `+${phoneMatch[1]} (${phoneMatch[2]}) ${phoneMatch[3]}-${phoneMatch[4]}`;
+            } else {
+              formattedPhoneNumber = `+${rawPhoneNumber}`;
+            }
+
+            let content: string;
+
+            if (!body.key.fromMe) {
+              content = `**${formattedPhoneNumber} - ${participantName}:**\n\n${bodyMessage}`;
+            } else {
+              content = `${bodyMessage}`;
+            }
+
+            const send = await this.sendData(
+              getConversation,
+              fileStream,
+              nameFile,
+              messageType,
+              content,
+              instance,
+              body,
+              'WAID:' + body.key.id,
+              quotedMsg,
+            );
+
+            if (!send) {
+              this.logger.warn('message not sent');
+              return;
+            }
+
+            return send;
+          } else {
+            const send = await this.sendData(
+              getConversation,
+              fileStream,
+              nameFile,
+              messageType,
+              bodyMessage,
+              instance,
+              body,
+              'WAID:' + body.key.id,
+              quotedMsg,
+            );
+
+            if (!send) {
+              this.logger.warn('message not sent');
+              return;
+            }
+
+            return send;
+          }
+        }
+
+        if (reactionMessage) {
+          if (reactionMessage.text) {
+            const send = await this.createMessage(
+              instance,
+              getConversation,
+              reactionMessage.text,
+              messageType,
+              false,
+              [],
+              {
+                message: { extendedTextMessage: { contextInfo: { stanzaId: reactionMessage.key.id } } },
+              },
+              'WAID:' + body.key.id,
+              quotedMsg,
+            );
+            if (!send) {
+              this.logger.warn('message not sent');
+              return;
+            }
+          }
+
+          return;
+        }
+
+        const isAdsMessage = (adsMessage && adsMessage.title) || adsMessage.body || adsMessage.thumbnailUrl;
+        if (isAdsMessage) {
+          const imgBuffer = await axios.get(adsMessage.thumbnailUrl, { responseType: 'arraybuffer' });
+
+          const extension = mimeTypes.extension(imgBuffer.headers['content-type']);
+          const mimeType = extension && mimeTypes.lookup(extension);
+
+          if (!mimeType) {
+            this.logger.warn('mimetype of Ads message not found');
+            return;
+          }
+
+          const random = Math.random().toString(36).substring(7);
+          const nameFile = `${random}.${mimeTypes.extension(mimeType)}`;
+          const fileData = Buffer.from(imgBuffer.data, 'binary');
+
+          const img = await Jimp.read(fileData);
+          await img.cover(320, 180);
+
+          const processedBuffer = await img.getBufferAsync(Jimp.MIME_PNG);
+
+          const fileStream = new Readable();
+          fileStream._read = () => {}; // _read is required but you can noop it
+          fileStream.push(processedBuffer);
+          fileStream.push(null);
+
+          const truncStr = (str: string, len: number) => {
+            if (!str) return '';
+
+            return str.length > len ? str.substring(0, len) + '...' : str;
+          };
+
+          const title = truncStr(adsMessage.title, 40);
+          const description = truncStr(adsMessage?.body, 75);
+
+          const send = await this.sendData(
+            getConversation,
+            fileStream,
+            nameFile,
+            messageType,
+            `${bodyMessage}\n\n\n**${title}**\n${description}\n${adsMessage.sourceUrl}`,
+            instance,
+            body,
+            'WAID:' + body.key.id,
+          );
+
+          if (!send) {
+            this.logger.warn('message not sent');
+            return;
+          }
+
+          return send;
+        }
+
+        if (body.key.remoteJid.includes('@g.us')) {
+          const participantName = body.pushName;
+          const rawPhoneNumber = body.key.participant.split('@')[0];
+          const phoneMatch = rawPhoneNumber.match(/^(\d{2})(\d{2})(\d{4})(\d{4})$/);
+
+          let formattedPhoneNumber: string;
+
+          if (phoneMatch) {
+            formattedPhoneNumber = `+${phoneMatch[1]} (${phoneMatch[2]}) ${phoneMatch[3]}-${phoneMatch[4]}`;
+          } else {
+            formattedPhoneNumber = `+${rawPhoneNumber}`;
+          }
+
+          let content: string;
+
+          if (!body.key.fromMe) {
+            content = `**${formattedPhoneNumber} - ${participantName}:**\n\n${bodyMessage}`;
+          } else {
+            content = `${bodyMessage}`;
+          }
+
+          const send = await this.createMessage(
+            instance,
+            getConversation,
+            content,
+            messageType,
+            false,
+            [],
+            body,
+            'WAID:' + body.key.id,
+            quotedMsg,
+          );
+
+          if (!send) {
+            this.logger.warn('message not sent');
+            return;
+          }
+
+          return send;
+        } else {
+          const send = await this.createMessage(
+            instance,
+            getConversation,
+            bodyMessage,
+            messageType,
+            false,
+            [],
+            body,
+            'WAID:' + body.key.id,
+            quotedMsg,
+          );
+
+          if (!send) {
+            this.logger.warn('message not sent');
+            return;
+          }
+
+          return send;
+        }
+      }
+
+      if (event === Events.MESSAGES_DELETE) {
+        const chatwootDelete = this.configService.get<Chatwoot>('CHATWOOT').MESSAGE_DELETE;
+
+        if (chatwootDelete === true) {
+          if (!body?.key?.id) {
+            this.logger.warn('message id not found');
+            return;
+          }
+
+          const message = await this.getMessageByKeyId(instance, body.key.id);
+
+          if (message?.chatwootMessageId && message?.chatwootConversationId) {
+            await this.prismaRepository.message.deleteMany({
+              where: {
+                key: {
+                  path: ['id'],
+                  equals: body.key.id,
+                },
+                instanceId: instance.instanceId,
+              },
+            });
+
+            return await client.messages.delete({
+              accountId: this.provider.accountId,
+              conversationId: message.chatwootConversationId,
+              messageId: message.chatwootMessageId,
+            });
+          }
+        }
+      }
+
+      if (event === 'messages.edit') {
+        const editedText = `${
+          body?.editedMessage?.conversation || body?.editedMessage?.extendedTextMessage?.text
+        }\n\n_\`${i18next.t('cw.message.edited')}.\`_`;
+        const message = await this.getMessageByKeyId(instance, body?.key?.id);
+        const key = message.key as {
+          id: string;
+          fromMe: boolean;
+          remoteJid: string;
+          participant?: string;
+        };
+
+        const messageType = key?.fromMe ? 'outgoing' : 'incoming';
+
+        if (message && message.chatwootConversationId) {
+          const send = await this.createMessage(
+            instance,
+            message.chatwootConversationId,
+            editedText,
+            messageType,
+            false,
+            [],
+            {
+              message: { extendedTextMessage: { contextInfo: { stanzaId: key.id } } },
+            },
+            'WAID:' + body.key.id,
+            null,
+          );
+          if (!send) {
+            this.logger.warn('edited message not sent');
+            return;
+          }
+        }
+        return;
+      }
+
+      if (event === 'messages.read') {
+        if (!body?.key?.id || !body?.key?.remoteJid) {
+          this.logger.warn('message id not found');
+          return;
+        }
+
+        const message = await this.getMessageByKeyId(instance, body.key.id);
+        const conversationId = message?.chatwootConversationId;
+        const contactInboxSourceId = message?.chatwootContactInboxSourceId;
+
+        if (conversationId) {
+          let sourceId = contactInboxSourceId;
+          const inbox = (await this.getInbox(instance)) as inbox & {
+            inbox_identifier?: string;
+          };
+
+          if (!sourceId && inbox) {
+            const conversation = (await client.conversations.get({
+              accountId: this.provider.accountId,
+              conversationId: conversationId,
+            })) as conversation_show & {
+              last_non_activity_message: { conversation: { contact_inbox: contact_inboxes } };
+            };
+            sourceId = conversation.last_non_activity_message?.conversation?.contact_inbox?.source_id;
+          }
+
+          if (sourceId && inbox?.inbox_identifier) {
+            const url =
+              `/public/api/v1/inboxes/${inbox.inbox_identifier}/contacts/${sourceId}` +
+              `/conversations/${conversationId}/update_last_seen`;
+            chatwootRequest(this.getClientCwConfig(), {
+              method: 'POST',
+              url: url,
+            });
+          }
+        }
+        return;
+      }
+
+      if (event === 'status.instance') {
+        const data = body;
+        const inbox = await this.getInbox(instance);
+
+        if (!inbox) {
+          this.logger.warn('inbox not found');
+          return;
+        }
+
+        const msgStatus = i18next.t('cw.inbox.status', {
+          inboxName: inbox.name,
+          state: data.status,
+        });
+
+        await this.createBotMessage(instance, msgStatus, 'incoming');
+      }
+
+      if (event === 'connection.update') {
+        if (body.status === 'open') {
+          // if we have qrcode count then we understand that a new connection was established
+          if (this.waMonitor.waInstances[instance.instanceName].qrCode.count > 0) {
+            const msgConnection = i18next.t('cw.inbox.connected');
+            await this.createBotMessage(instance, msgConnection, 'incoming');
+            this.waMonitor.waInstances[instance.instanceName].qrCode.count = 0;
+            chatwootImport.clearAll(instance);
+          }
+        }
+      }
+
+      if (event === 'qrcode.updated') {
+        if (body.statusCode === 500) {
+          const erroQRcode = `🚨 ${i18next.t('qrlimitreached')}`;
+          return await this.createBotMessage(instance, erroQRcode, 'incoming');
+        } else {
+          const fileData = Buffer.from(body?.qrcode.base64.replace('data:image/png;base64,', ''), 'base64');
+
+          const fileStream = new Readable();
+          fileStream._read = () => {};
+          fileStream.push(fileData);
+          fileStream.push(null);
+
+          await this.createBotQr(
+            instance,
+            i18next.t('qrgeneratedsuccesfully'),
+            'incoming',
+            fileStream,
+            `${instance.instanceName}.png`,
+          );
+
+          let msgQrCode = `⚡️${i18next.t('qrgeneratedsuccesfully')}\n\n${i18next.t('scanqr')}`;
+
+          if (body?.qrcode?.pairingCode) {
+            msgQrCode =
+              msgQrCode +
+              `\n\n*Pairing Code:* ${body.qrcode.pairingCode.substring(0, 4)}-${body.qrcode.pairingCode.substring(
+                4,
+                8,
+              )}`;
+          }
+
+          await this.createBotMessage(instance, msgQrCode, 'incoming');
+        }
+      }
+    } catch (error) {
+      this.logger.error(error);
+    }
+  }
+
+  public getNumberFromRemoteJid(
+    remoteJid: string,
+    phoneNumber?: string,
+  ): string | undefined {
+    const cleaned = remoteJid.replace(/:\d+/, '');
+
+    if (cleaned.endsWith('@lid')) {
+      return phoneNumber;
+    }
+
+    return cleaned.split('@')[0];
   }
-}
+
+  public startImportHistoryMessages(instance: InstanceDto) {
+    if (!this.isImportHistoryAvailable()) {
+      return;
+    }
+
+    this.createBotMessage(instance, i18next.t('cw.import.startImport'), 'incoming');
+  }
+
+  public isImportHistoryAvailable() {
+    const uri = this.configService.get<Chatwoot>('CHATWOOT').IMPORT.DATABASE.CONNECTION.URI;
+
+    return uri && uri !== 'postgres://user:password@hostname:port/dbname';
+  }
+
+  public addHistoryMessages(instance: InstanceDto, messagesRaw: MessageModel[]) {
+    if (!this.isImportHistoryAvailable()) {
+      return;
+    }
+
+    chatwootImport.addHistoryMessages(instance, messagesRaw);
+  }
+
+  public addHistoryContacts(instance: InstanceDto, contactsRaw: ContactModel[]) {
+    if (!this.isImportHistoryAvailable()) {
+      return;
+    }
+
+    return chatwootImport.addHistoryContacts(instance, contactsRaw);
+  }
+
+  public async importHistoryMessages(instance: InstanceDto) {
+    if (!this.isImportHistoryAvailable()) {
+      return;
+    }
+
+    this.createBotMessage(instance, i18next.t('cw.import.importingMessages'), 'incoming');
+
+    const totalMessagesImported = await chatwootImport.importHistoryMessages(
+      instance,
+      this,
+      await this.getInbox(instance),
+      this.provider,
+    );
+    this.updateContactAvatarInRecentConversations(instance);
+
+    const msg = Number.isInteger(totalMessagesImported)
+      ? i18next.t('cw.import.messagesImported', { totalMessagesImported })
+      : i18next.t('cw.import.messagesException');
+
+    this.createBotMessage(instance, msg, 'incoming');
+
+    return totalMessagesImported;
+  }
+
+  public async updateContactAvatarInRecentConversations(instance: InstanceDto, limitContacts = 100) {
+    try {
+      if (!this.isImportHistoryAvailable()) {
+        return;
+      }
+
+      const client = await this.clientCw(instance);
+      if (!client) {
+        this.logger.warn('client not found');
+        return null;
+      }
+
+      const inbox = await this.getInbox(instance);
+      if (!inbox) {
+        this.logger.warn('inbox not found');
+        return null;
+      }
+
+      const recentContacts = await chatwootImport.getContactsOrderByRecentConversations(
+        inbox,
+        this.provider,
+        limitContacts,
+      );
+
+      const contactIdentifiers = recentContacts
+        .map((contact) => contact.identifier)
+        .filter((identifier) => identifier !== null);
+
+      const contactsWithProfilePicture = (
+        await this.prismaRepository.contact.findMany({
+          where: {
+            instanceId: instance.instanceId,
+            id: {
+              in: contactIdentifiers,
+            },
+            profilePicUrl: {
+              not: null,
+            },
+          },
+        })
+      ).reduce((acc: Map<string, ContactModel>, contact: ContactModel) => acc.set(contact.id, contact), new Map());
+
+      recentContacts.forEach(async (contact) => {
+        if (contactsWithProfilePicture.has(contact.identifier)) {
+          client.contacts.update({
+            accountId: this.provider.accountId,
+            id: contact.id,
+            data: {
+              avatar_url: contactsWithProfilePicture.get(contact.identifier).profilePictureUrl || null,
+            },
+          });
+        }
+      });
+    } catch (error) {
+      this.logger.error(`Error on update avatar in recent conversations: ${error.toString()}`);
+    }
+  }
+
+  public async syncLostMessages(
+    instance: InstanceDto,
+    chatwootConfig: ChatwootDto,
+    prepareMessage: (message: any) => any,
+  ) {
+    try {
+      if (!this.isImportHistoryAvailable()) {
+        return;
+      }
+      if (!this.configService.get<Database>('DATABASE').SAVE_DATA.MESSAGE_UPDATE) {
+        return;
+      }
+
+      const inbox = await this.getInbox(instance);
+
+      const sqlMessages = `select * from messages m
+      where account_id = ${chatwootConfig.accountId}
+      and inbox_id = ${inbox.id}
+      and created_at >= now() - interval '6h'
+      order by created_at desc`;
+
+      const messagesData = (await this.pgClient.query(sqlMessages))?.rows;
+      const ids: string[] = messagesData
+        .filter((message) => !!message.source_id)
+        .map((message) => message.source_id.replace('WAID:', ''));
+
+      const savedMessages = await this.prismaRepository.message.findMany({
+        where: {
+          Instance: { name: instance.instanceName },
+          messageTimestamp: { gte: dayjs().subtract(6, 'hours').unix() },
+          AND: ids.map((id) => ({ key: { path: ['id'], not: id } })),
+        },
+      });
+
+      const filteredMessages = savedMessages.filter(
+        (msg: any) => !chatwootImport.isIgnorePhoneNumber(msg.key?.remoteJid),
+      );
+      const messagesRaw: any[] = [];
+      for (const m of filteredMessages) {
+        if (!m.message || !m.key || !m.messageTimestamp) {
+          continue;
+        }
+
+        if (Long.isLong(m?.messageTimestamp)) {
+          m.messageTimestamp = m.messageTimestamp?.toNumber();
+        }
+
+        messagesRaw.push(prepareMessage(m as any));
+      }
+
+      this.addHistoryMessages(
+        instance,
+        messagesRaw.filter((msg) => !chatwootImport.isIgnorePhoneNumber(msg.key?.remoteJid)),
+      );
+
+      await chatwootImport.importHistoryMessages(instance, this, inbox, this.provider);
+      const waInstance = this.waMonitor.waInstances[instance.instanceName];
+      waInstance.clearCacheChatwoot();
+    } catch (error) {
+      return;
+    }
+  }
+}
diff --git a/src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts b/src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts
index cff97a5b..f1843687 100644
--- a/src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts
+++ b/src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts
@@ -1,122 +1,127 @@
-import { InstanceDto } from '@api/dto/instance.dto';
-import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
-import { postgresClient } from '@api/integrations/chatbot/chatwoot/libs/postgres.client';
-import { ChatwootService } from '@api/integrations/chatbot/chatwoot/services/chatwoot.service';
-import { Chatwoot, configService } from '@config/env.config';
-import { Logger } from '@config/logger.config';
-import { inbox } from '@figuro/chatwoot-sdk';
-import { Chatwoot as ChatwootModel, Contact, Message } from '@prisma/client';
-import axios from 'axios';
-import { proto } from 'baileys';
-
-type ChatwootUser = {
-  user_type: string;
-  user_id: number;
-};
-
+import { InstanceDto } from '@api/dto/instance.dto';
+import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
+import { postgresClient } from '@api/integrations/chatbot/chatwoot/libs/postgres.client';
+import { ChatwootService } from '@api/integrations/chatbot/chatwoot/services/chatwoot.service';
+import { Chatwoot, configService } from '@config/env.config';
+import { Logger } from '@config/logger.config';
+import { inbox } from '@figuro/chatwoot-sdk';
+import { Chatwoot as ChatwootModel, Contact, Message } from '@prisma/client';
+import { proto } from 'baileys';
+
+type ChatwootUser = {
+  user_type: string;
+  user_id: number;
+};
+
 type FksChatwoot = {
   phone_number: string;
+  identifier: string;
   contact_id: string;
   conversation_id: string;
 };
-
-type firstLastTimestamp = {
-  first: number;
-  last: number;
-};
-
-type IWebMessageInfo = Omit<proto.IWebMessageInfo, 'key'> & Partial<Pick<proto.IWebMessageInfo, 'key'>>;
-
-class ChatwootImport {
-  private logger = new Logger('ChatwootImport');
-  private repositoryMessagesCache = new Map<string, Set<string>>();
-  private historyMessages = new Map<string, Message[]>();
-  private historyContacts = new Map<string, Contact[]>();
-
-  public getRepositoryMessagesCache(instance: InstanceDto) {
-    return this.repositoryMessagesCache.has(instance.instanceName)
-      ? this.repositoryMessagesCache.get(instance.instanceName)
-      : null;
-  }
-
-  public setRepositoryMessagesCache(instance: InstanceDto, repositoryMessagesCache: Set<string>) {
-    this.repositoryMessagesCache.set(instance.instanceName, repositoryMessagesCache);
-  }
-
-  public deleteRepositoryMessagesCache(instance: InstanceDto) {
-    this.repositoryMessagesCache.delete(instance.instanceName);
-  }
-
-  public addHistoryMessages(instance: InstanceDto, messagesRaw: Message[]) {
-    const actualValue = this.historyMessages.has(instance.instanceName)
-      ? this.historyMessages.get(instance.instanceName)
-      : [];
-    this.historyMessages.set(instance.instanceName, [...actualValue, ...messagesRaw]);
-  }
-
-  public addHistoryContacts(instance: InstanceDto, contactsRaw: Contact[]) {
-    const actualValue = this.historyContacts.has(instance.instanceName)
-      ? this.historyContacts.get(instance.instanceName)
-      : [];
-    this.historyContacts.set(instance.instanceName, actualValue.concat(contactsRaw));
-  }
-
-  public deleteHistoryMessages(instance: InstanceDto) {
-    this.historyMessages.delete(instance.instanceName);
-  }
-
-  public deleteHistoryContacts(instance: InstanceDto) {
-    this.historyContacts.delete(instance.instanceName);
-  }
-
-  public clearAll(instance: InstanceDto) {
-    this.deleteRepositoryMessagesCache(instance);
-    this.deleteHistoryMessages(instance);
-    this.deleteHistoryContacts(instance);
-  }
-
-  public getHistoryMessagesLenght(instance: InstanceDto) {
-    return this.historyMessages.get(instance.instanceName)?.length ?? 0;
-  }
-
-  public async importHistoryContacts(instance: InstanceDto, provider: ChatwootDto) {
-    try {
-      if (this.getHistoryMessagesLenght(instance) > 0) {
-        return;
-      }
-
-      const pgClient = postgresClient.getChatwootConnection();
-
-      let totalContactsImported = 0;
-
-      const contacts = this.historyContacts.get(instance.instanceName) || [];
-      if (contacts.length === 0) {
-        return 0;
-      }
-
-      const contactBatches = this.sliceIntoChunks(contacts, 3000);
-      for (const contactsChunk of contactBatches) {
-        const labelSql = `SELECT id FROM labels WHERE title = '${provider.nameInbox}' AND account_id = ${provider.accountId} LIMIT 1`;
-
-        let labelId = (await pgClient.query(labelSql))?.rows[0]?.id;
-
-        if (!labelId) {
-          // creating label in chatwoot db and getting the id
-          const sqlLabel = `INSERT INTO labels (title, color, show_on_sidebar, account_id, created_at, updated_at) VALUES ('${provider.nameInbox}', '#34039B', true, ${provider.accountId}, NOW(), NOW()) RETURNING id`;
-
-          labelId = (await pgClient.query(sqlLabel))?.rows[0]?.id;
-        }
-
+
+type firstLastTimestamp = {
+  first: number;
+  last: number;
+};
+
+type IWebMessageInfo = Omit<proto.IWebMessageInfo, 'key'> & Partial<Pick<proto.IWebMessageInfo, 'key'>>;
+
+class ChatwootImport {
+  private logger = new Logger('ChatwootImport');
+  private repositoryMessagesCache = new Map<string, Set<string>>();
+  private historyMessages = new Map<string, Message[]>();
+  private historyContacts = new Map<string, Contact[]>();
+
+  public getRepositoryMessagesCache(instance: InstanceDto) {
+    return this.repositoryMessagesCache.has(instance.instanceName)
+      ? this.repositoryMessagesCache.get(instance.instanceName)
+      : null;
+  }
+
+  public setRepositoryMessagesCache(instance: InstanceDto, repositoryMessagesCache: Set<string>) {
+    this.repositoryMessagesCache.set(instance.instanceName, repositoryMessagesCache);
+  }
+
+  public deleteRepositoryMessagesCache(instance: InstanceDto) {
+    this.repositoryMessagesCache.delete(instance.instanceName);
+  }
+
+  public addHistoryMessages(instance: InstanceDto, messagesRaw: Message[]) {
+    const actualValue = this.historyMessages.has(instance.instanceName)
+      ? this.historyMessages.get(instance.instanceName)
+      : [];
+    this.historyMessages.set(instance.instanceName, [...actualValue, ...messagesRaw]);
+  }
+
+  public addHistoryContacts(instance: InstanceDto, contactsRaw: Contact[]) {
+    const actualValue = this.historyContacts.has(instance.instanceName)
+      ? this.historyContacts.get(instance.instanceName)
+      : [];
+    this.historyContacts.set(instance.instanceName, actualValue.concat(contactsRaw));
+  }
+
+  public deleteHistoryMessages(instance: InstanceDto) {
+    this.historyMessages.delete(instance.instanceName);
+  }
+
+  public deleteHistoryContacts(instance: InstanceDto) {
+    this.historyContacts.delete(instance.instanceName);
+  }
+
+  public clearAll(instance: InstanceDto) {
+    this.deleteRepositoryMessagesCache(instance);
+    this.deleteHistoryMessages(instance);
+    this.deleteHistoryContacts(instance);
+  }
+
+  public getHistoryMessagesLenght(instance: InstanceDto) {
+    return this.historyMessages.get(instance.instanceName)?.length ?? 0;
+  }
+
+  public async importHistoryContacts(instance: InstanceDto, provider: ChatwootDto) {
+    try {
+      if (this.getHistoryMessagesLenght(instance) > 0) {
+        return;
+      }
+
+      const pgClient = postgresClient.getChatwootConnection();
+
+      let totalContactsImported = 0;
+
+      const contacts = this.historyContacts.get(instance.instanceName) || [];
+      if (contacts.length === 0) {
+        return 0;
+      }
+
+      let contactsChunk: Contact[] = this.sliceIntoChunks(contacts, 3000);
+      while (contactsChunk.length > 0) {
+        const labelSql = `SELECT id FROM labels WHERE title = '${provider.nameInbox}' AND account_id = ${provider.accountId} LIMIT 1`;
+
+        let labelId = (await pgClient.query(labelSql))?.rows[0]?.id;
+
+        if (!labelId) {
+          // creating label in chatwoot db and getting the id
+          const sqlLabel = `INSERT INTO labels (title, color, show_on_sidebar, account_id, created_at, updated_at) VALUES ('${provider.nameInbox}', '#34039B', true, ${provider.accountId}, NOW(), NOW()) RETURNING id`;
+
+          labelId = (await pgClient.query(sqlLabel))?.rows[0]?.id;
+        }
+
         // inserting contacts in chatwoot db
+        // identifier may contain a phone-based JID or Linked ID (e.g. *@lid*)
         let sqlInsert = `INSERT INTO contacts
           (name, phone_number, account_id, identifier, created_at, updated_at) VALUES `;
-        const bindInsert = [provider.accountId];
-
+        const bindInsert = [provider.accountId];
+
         for (const contact of contactsChunk) {
           bindInsert.push(contact.pushName);
           const bindName = `$${bindInsert.length}`;
 
-          bindInsert.push(`+${contact.remoteJid.split('@')[0]}`);
+          const phone = this.getNumberFromRemoteJid(
+            contact.remoteJid,
+            (contact as any).phoneNumber,
+          );
+          bindInsert.push(phone ? `+${phone}` : null);
           const bindPhoneNumber = `$${bindInsert.length}`;
 
           bindInsert.push(contact.remoteJid);
@@ -124,660 +129,457 @@ class ChatwootImport {
 
           sqlInsert += `(${bindName}, ${bindPhoneNumber}, $1, ${bindIdentifier}, NOW(), NOW()),`;
         }
-        if (sqlInsert.slice(-1) === ',') {
-          sqlInsert = sqlInsert.slice(0, -1);
-        }
-        sqlInsert += ` ON CONFLICT (identifier, account_id)
-                       DO UPDATE SET
-                        name = EXCLUDED.name,
-                        phone_number = EXCLUDED.phone_number,
-                        identifier = EXCLUDED.identifier`;
-
-        totalContactsImported += (await pgClient.query(sqlInsert, bindInsert))?.rowCount ?? 0;
-
-        const sqlTags = `SELECT id FROM tags WHERE name = '${provider.nameInbox}' LIMIT 1`;
-
-        const tagData = (await pgClient.query(sqlTags))?.rows[0];
-        let tagId = tagData?.id;
-
-        const sqlTag = `INSERT INTO tags (name, taggings_count) VALUES ('${provider.nameInbox}', ${totalContactsImported}) ON CONFLICT (name) DO UPDATE SET taggings_count = tags.taggings_count + ${totalContactsImported} RETURNING id`;
-
-        tagId = (await pgClient.query(sqlTag))?.rows[0]?.id;
-
-        await pgClient.query(sqlTag);
-
-        let sqlInsertLabel = `INSERT INTO taggings (tag_id, taggable_type, taggable_id, context, created_at) VALUES `;
-
-        contactsChunk.forEach((contact) => {
-          const bindTaggableId = `(SELECT id FROM contacts WHERE identifier = '${contact.remoteJid}' AND account_id = ${provider.accountId})`;
-          sqlInsertLabel += `($1, $2, ${bindTaggableId}, $3, NOW()),`;
-        });
-
-        if (sqlInsertLabel.slice(-1) === ',') {
-          sqlInsertLabel = sqlInsertLabel.slice(0, -1);
+        if (sqlInsert.slice(-1) === ',') {
+          sqlInsert = sqlInsert.slice(0, -1);
+        }
+        sqlInsert += ` ON CONFLICT (identifier, account_id)
+                       DO UPDATE SET
+                        name = EXCLUDED.name,
+                        phone_number = EXCLUDED.phone_number,
+                        identifier = EXCLUDED.identifier`;
+
+        totalContactsImported += (await pgClient.query(sqlInsert, bindInsert))?.rowCount ?? 0;
+
+        const sqlTags = `SELECT id FROM tags WHERE name = '${provider.nameInbox}' LIMIT 1`;
+
+        const tagData = (await pgClient.query(sqlTags))?.rows[0];
+        let tagId = tagData?.id;
+
+        const sqlTag = `INSERT INTO tags (name, taggings_count) VALUES ('${provider.nameInbox}', ${totalContactsImported}) ON CONFLICT (name) DO UPDATE SET taggings_count = tags.taggings_count + ${totalContactsImported} RETURNING id`;
+
+        tagId = (await pgClient.query(sqlTag))?.rows[0]?.id;
+
+        await pgClient.query(sqlTag);
+
+        let sqlInsertLabel = `INSERT INTO taggings (tag_id, taggable_type, taggable_id, context, created_at) VALUES `;
+
+        contactsChunk.forEach((contact) => {
+          const bindTaggableId = `(SELECT id FROM contacts WHERE identifier = '${contact.remoteJid}' AND account_id = ${provider.accountId})`;
+          sqlInsertLabel += `($1, $2, ${bindTaggableId}, $3, NOW()),`;
+        });
+
+        if (sqlInsertLabel.slice(-1) === ',') {
+          sqlInsertLabel = sqlInsertLabel.slice(0, -1);
+        }
+
+        await pgClient.query(sqlInsertLabel, [tagId, 'Contact', 'labels']);
+
+        contactsChunk = this.sliceIntoChunks(contacts, 3000);
+      }
+
+      this.deleteHistoryContacts(instance);
+
+      return totalContactsImported;
+    } catch (error) {
+      this.logger.error(`Error on import history contacts: ${error.toString()}`);
+    }
+  }
+
+  public async getExistingSourceIds(sourceIds: string[]): Promise<Set<string>> {
+    try {
+      const existingSourceIdsSet = new Set<string>();
+
+      if (sourceIds.length === 0) {
+        return existingSourceIdsSet;
+      }
+
+      const formattedSourceIds = sourceIds.map((sourceId) => `WAID:${sourceId.replace('WAID:', '')}`); // Make sure the sourceId is always formatted as WAID:1234567890
+      const query = 'SELECT source_id FROM messages WHERE source_id = ANY($1)';
+      const pgClient = postgresClient.getChatwootConnection();
+      const result = await pgClient.query(query, [formattedSourceIds]);
+
+      for (const row of result.rows) {
+        existingSourceIdsSet.add(row.source_id);
+      }
+
+      return existingSourceIdsSet;
+    } catch (error) {
+      return null;
+    }
+  }
+
+  public async importHistoryMessages(
+    instance: InstanceDto,
+    chatwootService: ChatwootService,
+    inbox: inbox,
+    provider: ChatwootModel,
+  ) {
+    try {
+      const pgClient = postgresClient.getChatwootConnection();
+
+      const chatwootUser = await this.getChatwootUser(provider);
+      if (!chatwootUser) {
+        throw new Error('User not found to import messages.');
+      }
+
+      let totalMessagesImported = 0;
+
+      let messagesOrdered = this.historyMessages.get(instance.instanceName) || [];
+      if (messagesOrdered.length === 0) {
+        return 0;
+      }
+
+      // ordering messages by number and timestamp asc
+      messagesOrdered.sort((a, b) => {
+        const aKey = a.key as {
+          remoteJid: string;
+        };
+
+        const bKey = b.key as {
+          remoteJid: string;
+        };
+
+        const aMessageTimestamp = a.messageTimestamp as any as number;
+        const bMessageTimestamp = b.messageTimestamp as any as number;
+
+        if (aKey.remoteJid === bKey.remoteJid) {
+          return aMessageTimestamp - bMessageTimestamp;
         }
 
-        await pgClient.query(sqlInsertLabel, [tagId, 'Contact', 'labels']);
-       
-      }
-
-      this.deleteHistoryContacts(instance);
-
-      return totalContactsImported;
-    } catch (error) {
-      this.logger.error(`Error on import history contacts: ${error.toString()}`);
-    }
-  }
-
-  public async getExistingSourceIds(sourceIds: string[]): Promise<Set<string>> {
-    try {
-      const existingSourceIdsSet = new Set<string>();
-
-      if (sourceIds.length === 0) {
-        return existingSourceIdsSet;
-      }
-
-      const formattedSourceIds = sourceIds.map((sourceId) => `WAID:${sourceId.replace('WAID:', '')}`); // Make sure the sourceId is always formatted as WAID:1234567890
-      const query = 'SELECT source_id FROM messages WHERE source_id = ANY($1)';
-      const pgClient = postgresClient.getChatwootConnection();
-      const result = await pgClient.query(query, [formattedSourceIds]);
-
-      for (const row of result.rows) {
-        existingSourceIdsSet.add(row.source_id);
-      }
-
-      return existingSourceIdsSet;
-    } catch (error) {
-      return null;
-    }
-  }
-
-  public async importHistoryMessages(
-    instance: InstanceDto,
-    chatwootService: ChatwootService,
-    inbox: inbox,
-    provider: ChatwootModel,
-  ) {
-    try {
-      this.logger.info(
-        `[importHistoryMessages] Iniciando importação de mensagens para a instância "${instance.instanceName}".`
-      );
-
-      const pgClient = postgresClient.getChatwootConnection();
-
-      const chatwootUser = await this.getChatwootUser(provider);
-      if (!chatwootUser) {
-        throw new Error('User not found to import messages.');
-      }
-
-      const touchedConversations = new Set<string>();
-      let totalMessagesImported = 0;
-
-      let messagesOrdered = this.historyMessages.get(instance.instanceName) || [];
-      this.logger.info(
-        `[importHistoryMessages] Número de mensagens recuperadas do histórico: ${messagesOrdered.length}.`
-      );
-      if (messagesOrdered.length === 0) {
-        return 0;
-      }
-
-      // Ordenando as mensagens por remoteJid e timestamp (ascendente)
-      messagesOrdered.sort((a, b) => {
-        const aKey = a.key as { remoteJid: string };
-        const bKey = b.key as { remoteJid: string };
-
-        const aMessageTimestamp = a.messageTimestamp as any as number;
-        const bMessageTimestamp = b.messageTimestamp as any as number;
-
-        return parseInt(aKey.remoteJid) - parseInt(bKey.remoteJid) || aMessageTimestamp - bMessageTimestamp;
+        return aKey.remoteJid.localeCompare(bKey.remoteJid);
       });
-      this.logger.info('[importHistoryMessages] Mensagens ordenadas por remoteJid e messageTimestamp.');
-
-      // Mapeando mensagens por telefone
+
       const allMessagesMappedByPhoneNumber = this.createMessagesMapByPhoneNumber(messagesOrdered);
-      this.logger.info(
-        `[importHistoryMessages] Mensagens mapeadas para ${allMessagesMappedByPhoneNumber.size} números únicos.`
-      );
-
-      // Map: +numero => { first: timestamp, last: timestamp }
+      // Map structure: remoteJid => { first message timestamp from chat, last message timestamp }
       const phoneNumbersWithTimestamp = new Map<string, firstLastTimestamp>();
-      allMessagesMappedByPhoneNumber.forEach((messages: Message[], phoneNumber: string) => {
-        phoneNumbersWithTimestamp.set(phoneNumber, {
-          first: messages[0]?.messageTimestamp as any as number,
-          last: messages[messages.length - 1]?.messageTimestamp as any as number,
-        });
-      });
-      this.logger.info(
-        `[importHistoryMessages] Criado mapa de timestamps para ${phoneNumbersWithTimestamp.size} números.`
-      );
-
-      // Removendo mensagens que já existem no banco (verificação pelo source_id)
-      const existingSourceIds = await this.getExistingSourceIds(
-        messagesOrdered.map((message: any) => message.key.id)
-      );
-      this.logger.info(
-        `[importHistoryMessages] Quantidade de source_ids existentes no banco: ${existingSourceIds.size}.`
-      );
-      const initialCount = messagesOrdered.length;
-      messagesOrdered = messagesOrdered.filter((message: any) => !existingSourceIds.has(message.key.id));
-      this.logger.info(
-        `[importHistoryMessages] Mensagens filtradas: de ${initialCount} para ${messagesOrdered.length} após remoção de duplicados.`
-      );
-
-      // Processamento das mensagens em batches
-      const batchSize = 4000;
-      let messagesChunks = this.sliceIntoChunks(messagesOrdered, batchSize);
-      let batchNumber = 1;
-      for (const messagesChunk of messagesChunks) {
-        this.logger.info(
-          `[importHistoryMessages] Processando batch ${batchNumber} com ${messagesChunk.length} mensagens.`
-        );
-
-        // Agrupando as mensagens deste batch por telefone
+      allMessagesMappedByPhoneNumber.forEach((messages: Message[], remoteJid: string) => {
+        phoneNumbersWithTimestamp.set(remoteJid, {
+          first: messages[0]?.messageTimestamp as any as number,
+          last: messages[messages.length - 1]?.messageTimestamp as any as number,
+        });
+      });
+
+      const existingSourceIds = await this.getExistingSourceIds(messagesOrdered.map((message: any) => message.key.id));
+      messagesOrdered = messagesOrdered.filter((message: any) => !existingSourceIds.has(message.key.id));
+      // processing messages in batch
+      const batchSize = 4000;
+      let messagesChunk: Message[] = this.sliceIntoChunks(messagesOrdered, batchSize);
+      while (messagesChunk.length > 0) {
+        // Map structure: remoteJid => Message[]
         const messagesByPhoneNumber = this.createMessagesMapByPhoneNumber(messagesChunk);
-        this.logger.info(
-          `[importHistoryMessages] Batch ${batchNumber}: ${messagesByPhoneNumber.size} números únicos encontrados.`
-        );
-
-        if (messagesByPhoneNumber.size > 0) {
-          const fksByNumber = await this.selectOrCreateFksFromChatwoot(
-            provider,
-            inbox,
-            phoneNumbersWithTimestamp,
-            messagesByPhoneNumber,
-          );
-
-          for (const { conversation_id } of fksByNumber.values()) {
-            touchedConversations.add(conversation_id);
-          }
-          
-          this.logger.info(
-            `[importHistoryMessages] Batch ${batchNumber}: FKs recuperados para ${fksByNumber.size} números.`
-          );
-
-          // Inserindo as mensagens no banco
-          let sqlInsertMsg = `INSERT INTO messages
-            (content, processed_message_content, account_id, inbox_id, conversation_id, message_type, private, content_type,
-            sender_type, sender_id, source_id, created_at, updated_at) VALUES `;
-          const bindInsertMsg = [provider.accountId, inbox.id];
-
-          messagesByPhoneNumber.forEach((messages: any[], phoneNumber: string) => {
-            const fksChatwoot = fksByNumber.get(phoneNumber);
-            this.logger.info(
-              `[importHistoryMessages] Número ${phoneNumber}: processando ${messages.length} mensagens.`
-            );
-            messages.forEach((message) => {
-              if (!message.message) {
-                return;
-              }
-              if (!fksChatwoot?.conversation_id || !fksChatwoot?.contact_id) {
-                return;
-              }
-              const contentMessage = this.getContentMessage(chatwootService, message);
-              if (!contentMessage) {
-                return;
-              }
-
-              bindInsertMsg.push(contentMessage);
-              const bindContent = `$${bindInsertMsg.length}`;
-
-              bindInsertMsg.push(fksChatwoot.conversation_id);
-              const bindConversationId = `$${bindInsertMsg.length}`;
-
-              bindInsertMsg.push(message.key.fromMe ? '1' : '0');
-              const bindMessageType = `$${bindInsertMsg.length}`;
-
-              bindInsertMsg.push(message.key.fromMe ? chatwootUser.user_type : 'Contact');
-              const bindSenderType = `$${bindInsertMsg.length}`;
-
-              bindInsertMsg.push(message.key.fromMe ? chatwootUser.user_id : fksChatwoot.contact_id);
-              const bindSenderId = `$${bindInsertMsg.length}`;
-
-              bindInsertMsg.push('WAID:' + message.key.id);
-              const bindSourceId = `$${bindInsertMsg.length}`;
-
-              bindInsertMsg.push(message.messageTimestamp as number);
-              const bindmessageTimestamp = `$${bindInsertMsg.length}`;
-
-              sqlInsertMsg += `(${bindContent}, ${bindContent}, $1, $2, ${bindConversationId}, ${bindMessageType}, FALSE, 0,
-                  ${bindSenderType},${bindSenderId},${bindSourceId}, to_timestamp(${bindmessageTimestamp}), to_timestamp(${bindmessageTimestamp})),`;
-            });
-          });
-
-
-          if (bindInsertMsg.length > 2) {
-            if (sqlInsertMsg.slice(-1) === ',') {
-              sqlInsertMsg = sqlInsertMsg.slice(0, -1);
-            }
-            const result = await pgClient.query(sqlInsertMsg, bindInsertMsg);
-            const rowCount = result?.rowCount ?? 0;
-            totalMessagesImported += rowCount;
-            this.logger.info(
-              `[importHistoryMessages] Batch ${batchNumber}: Inseridas ${rowCount} mensagens no banco.`
-            );
-          }
+
+        if (messagesByPhoneNumber.size > 0) {
+          const fksByNumber = await this.selectOrCreateFksFromChatwoot(
+            provider,
+            inbox,
+            phoneNumbersWithTimestamp,
+            messagesByPhoneNumber,
+          );
+
+          // inserting messages in chatwoot db
+          let sqlInsertMsg = `INSERT INTO messages
+            (content, processed_message_content, account_id, inbox_id, conversation_id, message_type, private, content_type,
+            sender_type, sender_id, source_id, created_at, updated_at) VALUES `;
+          const bindInsertMsg = [provider.accountId, inbox.id];
+
+          messagesByPhoneNumber.forEach((messages: any[], phoneNumber: string) => {
+            const fksChatwoot = fksByNumber.get(phoneNumber);
+
+            messages.forEach((message) => {
+              if (!message.message) {
+                return;
+              }
+
+              if (!fksChatwoot?.conversation_id || !fksChatwoot?.contact_id) {
+                return;
+              }
+
+              const contentMessage = this.getContentMessage(chatwootService, message);
+              if (!contentMessage) {
+                return;
+              }
+
+              bindInsertMsg.push(contentMessage);
+              const bindContent = `$${bindInsertMsg.length}`;
+
+              bindInsertMsg.push(fksChatwoot.conversation_id);
+              const bindConversationId = `$${bindInsertMsg.length}`;
+
+              bindInsertMsg.push(message.key.fromMe ? '1' : '0');
+              const bindMessageType = `$${bindInsertMsg.length}`;
+
+              bindInsertMsg.push(message.key.fromMe ? chatwootUser.user_type : 'Contact');
+              const bindSenderType = `$${bindInsertMsg.length}`;
+
+              bindInsertMsg.push(message.key.fromMe ? chatwootUser.user_id : fksChatwoot.contact_id);
+              const bindSenderId = `$${bindInsertMsg.length}`;
+
+              bindInsertMsg.push('WAID:' + message.key.id);
+              const bindSourceId = `$${bindInsertMsg.length}`;
+
+              bindInsertMsg.push(message.messageTimestamp as number);
+              const bindmessageTimestamp = `$${bindInsertMsg.length}`;
+
+              sqlInsertMsg += `(${bindContent}, ${bindContent}, $1, $2, ${bindConversationId}, ${bindMessageType}, FALSE, 0,
+                  ${bindSenderType},${bindSenderId},${bindSourceId}, to_timestamp(${bindmessageTimestamp}), to_timestamp(${bindmessageTimestamp})),`;
+            });
+          });
+          if (bindInsertMsg.length > 2) {
+            if (sqlInsertMsg.slice(-1) === ',') {
+              sqlInsertMsg = sqlInsertMsg.slice(0, -1);
+            }
+            totalMessagesImported += (await pgClient.query(sqlInsertMsg, bindInsertMsg))?.rowCount ?? 0;
+          }
+        }
+        messagesChunk = this.sliceIntoChunks(messagesOrdered, batchSize);
+      }
+
+      this.deleteHistoryMessages(instance);
+      this.deleteRepositoryMessagesCache(instance);
+
+      const providerData: ChatwootDto = {
+        ...provider,
+        ignoreJids: Array.isArray(provider.ignoreJids) ? provider.ignoreJids.map((event) => String(event)) : [],
+      };
+
+      this.importHistoryContacts(instance, providerData);
+
+      return totalMessagesImported;
+    } catch (error) {
+      this.logger.error(`Error on import history messages: ${error.toString()}`);
+
+      this.deleteHistoryMessages(instance);
+      this.deleteRepositoryMessagesCache(instance);
+    }
+  }
+
+  public async selectOrCreateFksFromChatwoot(
+    provider: ChatwootModel,
+    inbox: inbox,
+    phoneNumbersWithTimestamp: Map<string, firstLastTimestamp>,
+    messagesByPhoneNumber: Map<string, Message[]>,
+  ): Promise<Map<string, FksChatwoot>> {
+    const pgClient = postgresClient.getChatwootConnection();
+
+    const bindValues = [provider.accountId, inbox.id];
+    const phoneNumberBind = Array.from(messagesByPhoneNumber.keys())
+      .map((remoteJid) => {
+        const phoneNumberTimestamp = phoneNumbersWithTimestamp.get(remoteJid);
+
+        if (phoneNumberTimestamp) {
+          const phone = this.getNumberFromRemoteJid(remoteJid);
+          bindValues.push(phone ? `+${phone}` : null);
+          let bindStr = `($${bindValues.length},`;
+
+          const identifier = remoteJid.includes('@') ? remoteJid : `${remoteJid}@s.whatsapp.net`;
+          bindValues.push(identifier);
+          bindStr += `$${bindValues.length},`;
+
+          bindValues.push(phoneNumberTimestamp.first);
+          bindStr += `$${bindValues.length},`;
+
+          bindValues.push(phoneNumberTimestamp.last);
+          return `${bindStr}$${bindValues.length})`;
         }
-        batchNumber++;
-        
-      }
-
-      this.deleteHistoryMessages(instance);
-      this.deleteRepositoryMessagesCache(instance);
-
-
-
-      this.logger.info(
-        `[importHistoryMessages] Histórico e cache de mensagens da instância "${instance.instanceName}" foram limpos.`
-      );
-
-
-      for (const convId of touchedConversations) {
-        await this.safeRefreshConversation(
-          provider.url,         
-          provider.accountId,
-          convId,
-          provider.token
-        );
-      }
-
-
-      const providerData: ChatwootDto = {
-        ...provider,
-        ignoreJids: Array.isArray(provider.ignoreJids) ? provider.ignoreJids.map((event) => String(event)) : [],
-      };
-
-      this.logger.info(
-        `[importHistoryMessages] Iniciando importação de contatos do histórico para a instância "${instance.instanceName}".`
-      );
-      await this.importHistoryContacts(instance, providerData);
-
-      this.logger.info(
-        `[importHistoryMessages] Concluída a importação de mensagens para a instância "${instance.instanceName}". Total importado: ${totalMessagesImported}.`
-      );
-      return totalMessagesImported;
-    } catch (error) {
-      this.logger.error(`Error on import history messages: ${error.toString()}`);
-      this.deleteHistoryMessages(instance);
-      this.deleteRepositoryMessagesCache(instance);
-    }
-  }
-
-
-  private normalizeBrazilianPhoneNumberOptions(raw: string): [string, string] {
-    if (!raw.startsWith('+55')) {
-      return [raw, raw];
-    }
-
-    // Remove o prefixo "+55"
-    const digits = raw.slice(3); // pega tudo após os 3 primeiros caracteres
-
-    if (digits.length === 10) {
-      // Se tiver 10 dígitos, assume que é o formato antigo.
-      // Old: exatamente o valor recebido.
-      // New: insere o '9' após os dois primeiros dígitos.
-      const newDigits = digits.slice(0, 2) + '9' + digits.slice(2);
-      return [raw, `+55${newDigits}`];
-    } else if (digits.length === 11) {
-      // Se tiver 11 dígitos, assume que é o formato novo.
-      // New: exatamente o valor recebido.
-      // Old: remove o dígito extra na terceira posição.
-      const oldDigits = digits.slice(0, 2) + digits.slice(3);
-      return [`+55${oldDigits}`, raw];
-    } else {
-      // Se por algum motivo tiver outra quantidade de dígitos, retorna os mesmos valores.
-      return [raw, raw];
-    }
-  }
-
-
-  public async selectOrCreateFksFromChatwoot(
-    provider: ChatwootModel,
-    inbox: inbox,
-    phoneNumbersWithTimestamp: Map<string, firstLastTimestamp>,
-    messagesByPhoneNumber: Map<string, Message[]>
-  ): Promise<Map<string, FksChatwoot>> {
-    const pgClient = postgresClient.getChatwootConnection();
-    const resultMap = new Map<string, FksChatwoot>();
-
-    for (const rawPhone of messagesByPhoneNumber.keys()) {
-      // 1) Normalizar telefone e gerar JIDs
-      const [normalizedWith, normalizedWithout] =
-        this.normalizeBrazilianPhoneNumberOptions(rawPhone);
-      const jidWith = normalizedWith.replace(/^\+/, '') + '@s.whatsapp.net';
-      const jidWithout = normalizedWithout.replace(/^\+/, '') + '@s.whatsapp.net';
-
-      const ts = phoneNumbersWithTimestamp.get(rawPhone);
-      if (!ts) {
-        this.logger.warn(`Timestamp não encontrado para ${rawPhone}`);
-        throw new Error(`Timestamp não encontrado para ${rawPhone}`);
-      }
-
-      // 2) Buscar ou inserir Contact (agora incluindo identifier)
-      let contact: { id: number; phone_number: string };
-      {
-        const selectContact = `
-          SELECT id, phone_number
-            FROM contacts
-           WHERE account_id = $1
-             AND (
-               phone_number = $2
-               OR phone_number = $3
-               OR identifier   = $4
-               OR identifier   = $5
-             )
-           LIMIT 1
-        `;
-        const res = await pgClient.query(selectContact, [
-          provider.accountId,
-          normalizedWith,
-          normalizedWithout,
-          jidWith,
-          jidWithout
-        ]);
-        if (res.rowCount) {
-          contact = res.rows[0];
-          this.logger.verbose(`Contato existente: ${JSON.stringify(contact)}`);
-        } else {
-          const insertContact = `
-          INSERT INTO contacts
-            (name, phone_number, account_id, identifier, created_at, updated_at)
-          VALUES
-            (
-              REPLACE($2, '+', ''),
-              $2,
-              $1,
-              $5,                -- agora é $5
-              to_timestamp($3),
-              to_timestamp($4)
-            )
-          RETURNING id, phone_number
-        `;
-          const insertRes = await pgClient.query(insertContact, [
-            provider.accountId,   // $1
-            normalizedWith,       // $2
-            ts.first,             // $3
-            ts.last,              // $4
-            jidWith               // $5
-          ]);
-          contact = insertRes.rows[0];
-
-
-          this.logger.verbose(`Contato inserido: ${JSON.stringify(contact)}`);
-        }
-      }
-
-      // 3) Buscar ou inserir ContactInbox
-      let contactInboxId: number;
-      {
-        const selectCi = `
-          SELECT id
-            FROM contact_inboxes
-           WHERE contact_id = $1
-             AND inbox_id   = $2
-           LIMIT 1
-        `;
-        const ciRes = await pgClient.query(selectCi, [
-          contact.id,
-          inbox.id
-        ]);
-        if (ciRes.rowCount) {
-          contactInboxId = ciRes.rows[0].id;
-          this.logger.verbose(`Contact_inbox existente: ${contactInboxId}`);
-        } else {
-          const insertCi = `
-            INSERT INTO contact_inboxes
-              (contact_id, inbox_id, source_id, created_at, updated_at)
-            VALUES
-              ($1, $2, gen_random_uuid(), NOW(), NOW())
-            RETURNING id
-          `;
-          const insertRes = await pgClient.query(insertCi, [
-            contact.id,
-            inbox.id
-          ]);
-          contactInboxId = insertRes.rows[0].id;
-          this.logger.verbose(`Contact_inbox inserido: ${contactInboxId}`);
-        }
-      }
-
-      // 4) Buscar ou inserir Conversation
-      let conversationId: number;
-      {
-        const selectConv = `
-          SELECT id
-            FROM conversations
-           WHERE account_id = $1
-             AND inbox_id   = $2
-             AND contact_id = $3
-           LIMIT 1
-        `;
-        const convRes = await pgClient.query(selectConv, [
-          provider.accountId,
-          inbox.id,
-          contact.id
-        ]);
-        if (convRes.rowCount) {
-          conversationId = convRes.rows[0].id;
-          this.logger.verbose(`Conversa existente: ${conversationId}`);
-        } else {
-          const insertConv = `
-            INSERT INTO conversations
-              (account_id, inbox_id, status, contact_id, contact_inbox_id, uuid,
-               last_activity_at, created_at, updated_at)
-            VALUES
-              ($1, $2, 0, $3, $4, gen_random_uuid(), NOW(), NOW(), NOW())
-            RETURNING id
-          `;
-          const insertRes = await pgClient.query(insertConv, [
-            provider.accountId,
-            inbox.id,
-            contact.id,
-            contactInboxId
-          ]);
-          conversationId = insertRes.rows[0].id;
-          this.logger.verbose(`Conversa inserida: ${conversationId}`);
-        }
-      }
-
-      resultMap.set(rawPhone, {
-        phone_number: normalizedWith,
-        contact_id: String(contact.id),
-        conversation_id: String(conversationId)
-      });
-    }
-
-    return resultMap;
+      })
+      .join(',');
+
+    // select (or insert when necessary) data from tables contacts, contact_inboxes, conversations from chatwoot db
+    const sqlFromChatwoot = `WITH
+              phone_number AS (
+                SELECT phone_number, identifier, created_at::INTEGER, last_activity_at::INTEGER FROM (
+                  VALUES
+                   ${phoneNumberBind}
+                 ) as t (phone_number, identifier, created_at, last_activity_at)
+              ),
+
+              only_new_phone_number AS (
+                SELECT * FROM phone_number
+                WHERE phone_number NOT IN (
+                  SELECT phone_number
+                  FROM contacts
+                    JOIN contact_inboxes ci ON ci.contact_id = contacts.id AND ci.inbox_id = $2
+                    JOIN conversations con ON con.contact_inbox_id = ci.id 
+                      AND con.account_id = $1
+                      AND con.inbox_id = $2
+                      AND con.contact_id = contacts.id
+                  WHERE contacts.account_id = $1
+                )
+              ),
+
+              new_contact AS (
+                INSERT INTO contacts (name, phone_number, account_id, identifier, created_at, updated_at)
+                SELECT REPLACE(p.phone_number, '+', ''), p.phone_number, $1, p.identifier,
+                  to_timestamp(p.created_at), to_timestamp(p.last_activity_at)
+                FROM only_new_phone_number AS p
+                ON CONFLICT(identifier, account_id) DO UPDATE SET updated_at = EXCLUDED.updated_at
+                RETURNING id, phone_number, created_at, updated_at
+              ),
+
+              new_contact_inbox AS (
+                INSERT INTO contact_inboxes (contact_id, inbox_id, source_id, created_at, updated_at)
+                SELECT new_contact.id, $2, gen_random_uuid(), new_contact.created_at, new_contact.updated_at
+                FROM new_contact 
+                RETURNING id, contact_id, created_at, updated_at
+              ),
+
+              new_conversation AS (
+                INSERT INTO conversations (account_id, inbox_id, status, contact_id,
+                  contact_inbox_id, uuid, last_activity_at, created_at, updated_at)
+                SELECT $1, $2, 0, new_contact_inbox.contact_id, new_contact_inbox.id, gen_random_uuid(),
+                  new_contact_inbox.updated_at, new_contact_inbox.created_at, new_contact_inbox.updated_at
+                FROM new_contact_inbox
+                RETURNING id, contact_id
+              )
+
+              SELECT new_contact.phone_number, new_contact.identifier, new_conversation.contact_id, new_conversation.id AS conversation_id
+              FROM new_conversation
+              JOIN new_contact ON new_conversation.contact_id = new_contact.id
+
+              UNION
+
+              SELECT p.phone_number, c.identifier, c.id contact_id, con.id conversation_id
+                FROM phone_number p
+              JOIN contacts c ON c.phone_number = p.phone_number
+              JOIN contact_inboxes ci ON ci.contact_id = c.id AND ci.inbox_id = $2
+              JOIN conversations con ON con.contact_inbox_id = ci.id AND con.account_id = $1
+                AND con.inbox_id = $2 AND con.contact_id = c.id`;
+
+    const fksFromChatwoot = await pgClient.query(sqlFromChatwoot, bindValues);
+
+    return new Map(fksFromChatwoot.rows.map((item: FksChatwoot) => [item.identifier, item]));
   }
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  public async getChatwootUser(provider: ChatwootModel): Promise<ChatwootUser> {
-    try {
-      const pgClient = postgresClient.getChatwootConnection();
-
-      const sqlUser = `SELECT owner_type AS user_type, owner_id AS user_id
-                         FROM access_tokens
-                       WHERE token = $1`;
-
-      return (await pgClient.query(sqlUser, [provider.token]))?.rows[0] || false;
-    } catch (error) {
-      this.logger.error(`Error on getChatwootUser: ${error.toString()}`);
-    }
-  }
-
+
+  public async getChatwootUser(provider: ChatwootModel): Promise<ChatwootUser> {
+    try {
+      const pgClient = postgresClient.getChatwootConnection();
+
+      const sqlUser = `SELECT owner_type AS user_type, owner_id AS user_id
+                         FROM access_tokens
+                       WHERE token = $1`;
+
+      return (await pgClient.query(sqlUser, [provider.token]))?.rows[0] || false;
+    } catch (error) {
+      this.logger.error(`Error on getChatwootUser: ${error.toString()}`);
+    }
+  }
+
   public createMessagesMapByPhoneNumber(messages: Message[]): Map<string, Message[]> {
     return messages.reduce((acc: Map<string, Message[]>, message: Message) => {
       const key = message?.key as {
         remoteJid: string;
       };
       if (!this.isIgnorePhoneNumber(key?.remoteJid)) {
-        const phoneNumber = key?.remoteJid?.split('@')[0];
-        if (phoneNumber) {
-          const phoneNumberPlus = `+${phoneNumber}`;
-          const messages = acc.has(phoneNumberPlus) ? acc.get(phoneNumberPlus) : [];
-          messages.push(message);
-          acc.set(phoneNumberPlus, messages);
+        const jid = key?.remoteJid;
+        if (jid) {
+          const msgs = acc.has(jid) ? acc.get(jid) : [];
+          msgs.push(message);
+          acc.set(jid, msgs);
         }
       }
 
       return acc;
     }, new Map());
   }
-
-  public async getContactsOrderByRecentConversations(
-    inbox: inbox,
-    provider: ChatwootModel,
-    limit = 50,
-  ): Promise<{ id: number; phone_number: string; identifier: string }[]> {
-    try {
-      const pgClient = postgresClient.getChatwootConnection();
-
-      const sql = `SELECT contacts.id, contacts.identifier, contacts.phone_number
-                     FROM conversations
-                   JOIN contacts ON contacts.id = conversations.contact_id
-                   WHERE conversations.account_id = $1
-                     AND inbox_id = $2
-                   ORDER BY conversations.last_activity_at DESC
-                   LIMIT $3`;
-
-      return (await pgClient.query(sql, [provider.accountId, inbox.id, limit]))?.rows;
-    } catch (error) {
-      this.logger.error(`Error on get recent conversations: ${error.toString()}`);
-    }
-  }
-
-  public getContentMessage(chatwootService: ChatwootService, msg: IWebMessageInfo) {
-    const contentMessage = chatwootService.getConversationMessage(msg.message);
-    if (contentMessage) {
-      return contentMessage;
-    }
-
-    if (!configService.get<Chatwoot>('CHATWOOT').IMPORT.PLACEHOLDER_MEDIA_MESSAGE) {
-      return '';
-    }
-
-    const types = {
-      documentMessage: msg.message.documentMessage,
-      documentWithCaptionMessage: msg.message.documentWithCaptionMessage?.message?.documentMessage,
-      imageMessage: msg.message.imageMessage,
-      videoMessage: msg.message.videoMessage,
-      audioMessage: msg.message.audioMessage,
-      stickerMessage: msg.message.stickerMessage,
-      templateMessage: msg.message.templateMessage?.hydratedTemplate?.hydratedContentText,
-    };
-    const typeKey = Object.keys(types).find((key) => types[key] !== undefined);
-
-    switch (typeKey) {
-      case 'documentMessage':
-        return `_<File: ${msg.message.documentMessage.fileName}${msg.message.documentMessage.caption ? ` ${msg.message.documentMessage.caption}` : ''
-          }>_`;
-
-      case 'documentWithCaptionMessage':
-        return `_<File: ${msg.message.documentWithCaptionMessage.message.documentMessage.fileName}${msg.message.documentWithCaptionMessage.message.documentMessage.caption
-          ? ` ${msg.message.documentWithCaptionMessage.message.documentMessage.caption}`
-          : ''
-          }>_`;
-
-      case 'templateMessage':
-        return msg.message.templateMessage.hydratedTemplate.hydratedTitleText
-          ? `*${msg.message.templateMessage.hydratedTemplate.hydratedTitleText}*\\n`
-          : '' + msg.message.templateMessage.hydratedTemplate.hydratedContentText;
-
-      case 'imageMessage':
-        return '_<Image Message>_';
-
-      case 'videoMessage':
-        return '_<Video Message>_';
-
-      case 'audioMessage':
-        return '_<Audio Message>_';
-
-      case 'stickerMessage':
-        return '_<Sticker Message>_';
-
-      default:
-        return '';
-    }
-  }
-
-  public sliceIntoChunks<T>(arr: T[], chunkSize: number): T[][] {
-    const chunks: T[][] = [];
-    for (let i = 0; i < arr.length; i += chunkSize) {
-      chunks.push(arr.slice(i, i + chunkSize));
-    }
-    return chunks;
-  }
-
-  public isGroup(remoteJid: string) {
-    return remoteJid.includes('@g.us');
-  }
-
+
+  public async getContactsOrderByRecentConversations(
+    inbox: inbox,
+    provider: ChatwootModel,
+    limit = 50,
+  ): Promise<{ id: number; phone_number: string; identifier: string }[]> {
+    try {
+      const pgClient = postgresClient.getChatwootConnection();
+
+      const sql = `SELECT contacts.id, contacts.identifier, contacts.phone_number
+                     FROM conversations
+                   JOIN contacts ON contacts.id = conversations.contact_id
+                   WHERE conversations.account_id = $1
+                     AND inbox_id = $2
+                   ORDER BY conversations.last_activity_at DESC
+                   LIMIT $3`;
+
+      return (await pgClient.query(sql, [provider.accountId, inbox.id, limit]))?.rows;
+    } catch (error) {
+      this.logger.error(`Error on get recent conversations: ${error.toString()}`);
+    }
+  }
+
+  public getContentMessage(chatwootService: ChatwootService, msg: IWebMessageInfo) {
+    const contentMessage = chatwootService.getConversationMessage(msg.message);
+    if (contentMessage) {
+      return contentMessage;
+    }
+
+    if (!configService.get<Chatwoot>('CHATWOOT').IMPORT.PLACEHOLDER_MEDIA_MESSAGE) {
+      return '';
+    }
+
+    const types = {
+      documentMessage: msg.message.documentMessage,
+      documentWithCaptionMessage: msg.message.documentWithCaptionMessage?.message?.documentMessage,
+      imageMessage: msg.message.imageMessage,
+      videoMessage: msg.message.videoMessage,
+      audioMessage: msg.message.audioMessage,
+      stickerMessage: msg.message.stickerMessage,
+      templateMessage: msg.message.templateMessage?.hydratedTemplate?.hydratedContentText,
+    };
+    const typeKey = Object.keys(types).find((key) => types[key] !== undefined);
+
+    switch (typeKey) {
+      case 'documentMessage':
+        return `_<File: ${msg.message.documentMessage.fileName}${
+          msg.message.documentMessage.caption ? ` ${msg.message.documentMessage.caption}` : ''
+        }>_`;
+
+      case 'documentWithCaptionMessage':
+        return `_<File: ${msg.message.documentWithCaptionMessage.message.documentMessage.fileName}${
+          msg.message.documentWithCaptionMessage.message.documentMessage.caption
+            ? ` ${msg.message.documentWithCaptionMessage.message.documentMessage.caption}`
+            : ''
+        }>_`;
+
+      case 'templateMessage':
+        return msg.message.templateMessage.hydratedTemplate.hydratedTitleText
+          ? `*${msg.message.templateMessage.hydratedTemplate.hydratedTitleText}*\\n`
+          : '' + msg.message.templateMessage.hydratedTemplate.hydratedContentText;
+
+      case 'imageMessage':
+        return '_<imagem indisponível>_';
+
+      case 'videoMessage':
+        return '_<vídeo indisponível>_';
+
+      case 'audioMessage':
+        return '_<áudio indisponível>_';
+
+      case 'stickerMessage':
+        return '_<mídia indisponível>_';
+
+      default:
+        return '';
+    }
+  }
+
+  public sliceIntoChunks(arr: any[], chunkSize: number) {
+    return arr.splice(0, chunkSize);
+  }
+
+  public isGroup(remoteJid: string) {
+    return remoteJid.includes('@g.us');
+  }
+
   public isIgnorePhoneNumber(remoteJid: string) {
     return this.isGroup(remoteJid) || remoteJid === 'status@broadcast' || remoteJid === '0@s.whatsapp.net';
   }
 
-  public updateMessageSourceID(messageId: string | number, sourceId: string) {
-    const pgClient = postgresClient.getChatwootConnection();
-
-    const sql = `UPDATE messages SET source_id = $1, status = 0, created_at = NOW(), updated_at = NOW() WHERE id = $2;`;
-
-    return pgClient.query(sql, [`WAID:${sourceId}`, messageId]);
-  }
-
-  private async safeRefreshConversation(
-    providerUrl: string,
-    accountId: string,
-    conversationId: string,
-    apiToken: string
-  ): Promise<void> {
-    try {
-      const pgClient = postgresClient.getChatwootConnection();
-      const res = await pgClient.query(
-        `SELECT display_id
-           FROM conversations
-          WHERE id = $1
-          LIMIT 1`,
-        [parseInt(conversationId, 10)]
-      );
-      const displayId = res.rows[0]?.display_id as string;
-      if (!displayId) {
-        this.logger.warn(`Conversation ${conversationId} sem display_id.`);
-        return;
-      }
-
-      const url = `${providerUrl}/api/v1/accounts/${accountId}/conversations/${displayId}/refresh`;
-      await axios.post(url, null, {
-        params: { api_access_token: apiToken },
-      });
-      this.logger.verbose(`Conversa ${displayId} refreshada com sucesso.`);
-    } catch (err: any) {
-      this.logger.warn(
-        `Não foi possível dar refresh na conversa ${conversationId}: ${err.message}`
-      );
+  public getNumberFromRemoteJid(
+    remoteJid: string,
+    phoneNumber?: string,
+  ): string | null {
+    const cleaned = remoteJid.replace(/:\d+/, '');
+    if (cleaned.endsWith('@lid')) {
+      return phoneNumber ?? null;
     }
+    return cleaned.split('@')[0];
   }
-  
-
-  
-}
-
-export const chatwootImport = new ChatwootImport();
+
+  public updateMessageSourceID(messageId: string | number, sourceId: string) {
+    const pgClient = postgresClient.getChatwootConnection();
+
+    const sql = `UPDATE messages SET source_id = $1, status = 0, created_at = NOW(), updated_at = NOW() WHERE id = $2;`;
+
+    return pgClient.query(sql, [`WAID:${sourceId}`, messageId]);
+  }
+}
+
+export const chatwootImport = new ChatwootImport();
diff --git a/src/api/integrations/chatbot/chatwoot/validate/chatwoot.schema.ts b/src/api/integrations/chatbot/chatwoot/validate/chatwoot.schema.ts
index ce9cf701..58d076ec 100644
--- a/src/api/integrations/chatbot/chatwoot/validate/chatwoot.schema.ts
+++ b/src/api/integrations/chatbot/chatwoot/validate/chatwoot.schema.ts
@@ -38,7 +38,12 @@ export const chatwootSchema: JSONSchema7 = {
     mergeBrazilContacts: { type: 'boolean', enum: [true, false] },
     importMessages: { type: 'boolean', enum: [true, false] },
     daysLimitImportMessages: { type: 'number' },
-    ignoreJids: { type: 'array', items: { type: 'string' } },
+    ignoreJids: {
+      type: 'array',
+      items: { type: 'string' },
+      description:
+        "List of JIDs to ignore. Use '@g.us' to skip all groups and '@s.whatsapp.net' to skip all contacts (including '@lid').",
+    },
   },
   required: ['enabled', 'accountId', 'token', 'url', 'signMsg', 'reopenConversation', 'conversationPending'],
   ...isNotEmpty('enabled', 'accountId', 'token', 'url', 'signMsg', 'reopenConversation', 'conversationPending'),
diff --git a/src/api/integrations/chatbot/typebot/services/typebot.service.ts b/src/api/integrations/chatbot/typebot/services/typebot.service.ts
index f0e4dc7f..106d42aa 100644
--- a/src/api/integrations/chatbot/typebot/services/typebot.service.ts
+++ b/src/api/integrations/chatbot/typebot/services/typebot.service.ts
@@ -225,7 +225,7 @@ export class TypebotService {
 
           if (formattedText.includes('[list]')) {
             const listJson = {
-              number: remoteJid.split('@')[0],
+              number: remoteJid,
               title: '',
               description: '',
               buttonText: '',
@@ -269,7 +269,7 @@ export class TypebotService {
             await instance.listMessage(listJson);
           } else if (formattedText.includes('[buttons]')) {
             const buttonJson = {
-              number: remoteJid.split('@')[0],
+              number: remoteJid,
               thumbnailUrl: undefined,
               title: '',
               description: '',
@@ -340,7 +340,7 @@ export class TypebotService {
           } else {
             await instance.textMessage(
               {
-                number: remoteJid.split('@')[0],
+                number: remoteJid,
                 delay: settings?.delayMessage || 1000,
                 text: formattedText,
               },
@@ -354,7 +354,7 @@ export class TypebotService {
         if (message.type === 'image') {
           await instance.mediaMessage(
             {
-              number: remoteJid.split('@')[0],
+              number: remoteJid,
               delay: settings?.delayMessage || 1000,
               mediatype: 'image',
               media: message.content.url,
@@ -369,7 +369,7 @@ export class TypebotService {
         if (message.type === 'video') {
           await instance.mediaMessage(
             {
-              number: remoteJid.split('@')[0],
+              number: remoteJid,
               delay: settings?.delayMessage || 1000,
               mediatype: 'video',
               media: message.content.url,
@@ -384,7 +384,7 @@ export class TypebotService {
         if (message.type === 'audio') {
           await instance.audioWhatsapp(
             {
-              number: remoteJid.split('@')[0],
+              number: remoteJid,
               delay: settings?.delayMessage || 1000,
               encoding: true,
               audio: message.content.url,
@@ -417,7 +417,7 @@ export class TypebotService {
 
           if (formattedText.includes('[list]')) {
             const listJson = {
-              number: remoteJid.split('@')[0],
+              number: remoteJid,
               title: '',
               description: '',
               buttonText: '',
@@ -461,7 +461,7 @@ export class TypebotService {
             await instance.listMessage(listJson);
           } else if (formattedText.includes('[buttons]')) {
             const buttonJson = {
-              number: remoteJid.split('@')[0],
+              number: remoteJid,
               thumbnailUrl: undefined,
               title: '',
               description: '',
@@ -532,7 +532,7 @@ export class TypebotService {
           } else {
             await instance.textMessage(
               {
-                number: remoteJid.split('@')[0],
+                number: remoteJid,
                 delay: settings?.delayMessage || 1000,
                 text: formattedText,
               },
@@ -644,7 +644,7 @@ export class TypebotService {
             if (unknownMessage) {
               this.waMonitor.waInstances[instance.name].textMessage(
                 {
-                  number: remoteJid.split('@')[0],
+                  number: remoteJid,
                   delay: delayMessage || 1000,
                   text: unknownMessage,
                 },
@@ -788,7 +788,7 @@ export class TypebotService {
           if (unknownMessage) {
             this.waMonitor.waInstances[instance.name].textMessage(
               {
-                number: remoteJid.split('@')[0],
+                number: remoteJid,
                 delay: delayMessage || 1000,
                 text: unknownMessage,
               },
@@ -880,7 +880,7 @@ export class TypebotService {
       if (unknownMessage) {
         this.waMonitor.waInstances[instance.name].textMessage(
           {
-            number: remoteJid.split('@')[0],
+            number: remoteJid,
             delay: delayMessage || 1000,
             text: unknownMessage,
           },
diff --git a/src/api/integrations/storage/s3/libs/minio.server.ts b/src/api/integrations/storage/s3/libs/minio.server.ts
index 19128af9..5a66305c 100644
--- a/src/api/integrations/storage/s3/libs/minio.server.ts
+++ b/src/api/integrations/storage/s3/libs/minio.server.ts
@@ -40,38 +40,22 @@ const bucketExists = async () => {
 };
 
 const setBucketPolicy = async () => {
-  if (!minioClient) return;
-
-  const policy = {
-    Version: '2012-10-17',
-    Statement: [
-      {
-        Effect: 'Allow',
-        Principal: '*',
-        Action: ['s3:GetObject'],
-        Resource: [`arn:aws:s3:::${bucketName}/*`],
-      },
-    ],
-  };
-
-  try {
+  if (minioClient) {
+    const policy = {
+      Version: '2012-10-17',
+      Statement: [
+        {
+          Effect: 'Allow',
+          Principal: '*',
+          Action: ['s3:GetObject'],
+          Resource: [`arn:aws:s3:::${bucketName}/*`],
+        },
+      ],
+    };
     await minioClient.setBucketPolicy(bucketName, JSON.stringify(policy));
-    console.log(`[S3 Service] Bucket policy aplicada em ${bucketName}`);
-  } catch (err: any) {
-    // MinIO não implementa esse endpoint
-    if (err.code === 'NotImplemented') {
-      console.warn(
-        `[S3 Service] setBucketPolicy não suportado por este endpoint, ignorando (bucket=${bucketName})`
-      );
-    } else {
-      // qualquer outro erro real, relança
-      console.error('[S3 Service] Erro ao aplicar bucket policy', err);
-      throw err;
-    }
   }
 };
 
-
 const createBucket = async () => {
   if (minioClient) {
     try {
diff --git a/src/api/services/cache.service.ts b/src/api/services/cache.service.ts
index d884362d..e2f96d4b 100644
--- a/src/api/services/cache.service.ts
+++ b/src/api/services/cache.service.ts
@@ -42,10 +42,7 @@ export class CacheService {
     if (!this.cache) {
       return;
     }
-
-    const effectiveTtl = ttl ?? (2 * 60 * 60);
-
-    this.cache.set(key, value, effectiveTtl);
+    this.cache.set(key, value, ttl);
   }
 
   public async hSet(key: string, field: string, value: any) {
@@ -72,20 +69,6 @@ export class CacheService {
     if (!this.cache) {
       return;
     }
-    // Verifica se a chave é realmente uma string
-    if (typeof key !== 'string') {
-      this.logger.error(
-        `Invalid cache key type: expected string but received ${typeof key}. Key content: ${JSON.stringify(key)}. Stack trace: ${new Error().stack}`
-      );
-    } else {
-      // Opcional: se a chave contiver quebras de linha, pode ser um sinal de que há um vCard em vez de um simples identificador
-      if (key.includes('\n')) {
-        this.logger.error(
-          `Invalid cache key format (contains newline characters): ${key}. Stack trace: ${new Error().stack}`
-        );
-      }
-    }
-    // Chama a implementação real do delete
     return this.cache.delete(key);
   }
 
diff --git a/src/validate/message.schema.ts b/src/validate/message.schema.ts
index d514c619..cf8a775d 100644
--- a/src/validate/message.schema.ts
+++ b/src/validate/message.schema.ts
@@ -84,8 +84,7 @@ export const textMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
@@ -114,8 +113,7 @@ export const mediaMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
@@ -140,8 +138,7 @@ export const ptvMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
@@ -166,8 +163,7 @@ export const audioMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
@@ -189,8 +185,7 @@ export const statusMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"statusJidList" must be an array of numeric strings',
+        description: '"statusJidList" must be an array of JIDs',
       },
     },
     allContacts: { type: 'boolean', enum: [true, false] },
@@ -216,8 +211,7 @@ export const stickerMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
@@ -245,8 +239,7 @@ export const locationMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
@@ -332,8 +325,7 @@ export const pollMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
@@ -389,8 +381,7 @@ export const listMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
@@ -440,8 +431,7 @@ export const buttonsMessageSchema: JSONSchema7 = {
       uniqueItems: true,
       items: {
         type: 'string',
-        pattern: '^\\d+',
-        description: '"mentioned" must be an array of numeric strings',
+        description: '"mentioned" must be an array of JIDs',
       },
     },
   },
diff --git a/tsconfig.json b/tsconfig.json
index d31c5ea8..af814134 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -3,7 +3,6 @@
     "experimentalDecorators": true,
     "emitDecoratorMetadata": true,
     "declaration": true,
-    "sourceMap": true,
     "target": "es2020",
     "module": "CommonJS",
     "rootDir": "./",
