diff --git a/src/api/controllers/chat.controller.ts b/src/api/controllers/chat.controller.ts
index 207d8ba5..5b715924 100644
--- a/src/api/controllers/chat.controller.ts
+++ b/src/api/controllers/chat.controller.ts
@@ -19,11 +19,43 @@ import { Query } from '@api/repository/repository.service';
 import { WAMonitoringService } from '@api/services/monitor.service';
 import { Contact, Message, MessageUpdate } from '@prisma/client';
 
+class SimpleMutex {
+  private locked = false;
+  private waiting: Array<() => void> = [];
+
+  async acquire(): Promise<void> {
+    if (this.locked) {
+      await new Promise<void>(resolve => this.waiting.push(resolve));
+    }
+    this.locked = true;
+  }
+
+  release(): void {
+    const next = this.waiting.shift();
+    if (next) next();
+    else this.locked = false;
+  }
+
+  async runExclusive<T>(fn: () => Promise<T>): Promise<T> {
+    await this.acquire();
+    try {
+      return await fn();
+    } finally {
+      this.release();
+    }
+  }
+}
+
+
 export class ChatController {
   constructor(private readonly waMonitor: WAMonitoringService) {}
 
+  private static whatsappNumberMutex = new SimpleMutex();
+
   public async whatsappNumber({ instanceName }: InstanceDto, data: WhatsAppNumberDto) {
-    return await this.waMonitor.waInstances[instanceName].whatsappNumber(data);
+    return await ChatController.whatsappNumberMutex.runExclusive(async () => {
+      return this.waMonitor.waInstances[instanceName].whatsappNumber(data);
+    });
   }
 
   public async readMessage({ instanceName }: InstanceDto, data: ReadMessageDto) {
diff --git a/src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts b/src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts
index 10feb7ce..c1026a84 100644
--- a/src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts
+++ b/src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts
@@ -136,7 +136,7 @@ import mimeTypes from 'mime-types';
 import NodeCache from 'node-cache';
 import cron from 'node-cron';
 import { release } from 'os';
-import { join } from 'path';
+import path, { join } from 'path';
 import P from 'pino';
 import qrcode, { QRCodeToDataURLOptions } from 'qrcode';
 import qrcodeTerminal from 'qrcode-terminal';
@@ -146,6 +146,12 @@ import { v4 } from 'uuid';
 
 import { useVoiceCallsBaileys } from './voiceCalls/useVoiceCallsBaileys';
 
+
+type DownloadMediaMessageContext = {
+  reuploadRequest: (msg: WAMessage) => Promise<WAMessage>;
+  logger: P.Logger;
+};
+
 const groupMetadataCache = new CacheService(new CacheEngine(configService, 'groups').getEngine());
 
 // Adicione a função getVideoDuration no início do arquivo
@@ -1290,13 +1296,25 @@ export class BaileysStartupService extends ChannelStartupService {
                     true,
                   );
 
-                  const { buffer, mediaType, fileName, size } = media;
-                  const mimetype = mimeTypes.lookup(fileName).toString();
-                  const fullName = join(`${this.instance.id}`, received.key.remoteJid, mediaType, fileName);
+                  const { buffer, mediaType, fileName: originalName, size } = media;
+                  const mimetype = mimeTypes.lookup(originalName).toString();
+
+                  // calcula a extensão (usa a do nome original ou, em último caso, a do mimetype)
+                  const ext = path.extname(originalName) || `.${mimeTypes.extension(mimetype)}`;
+
+                  // força usar sempre o id da mensagem como nome de arquivo
+                  const fileName = `${received.key.id}${ext}`;
+
+                  const fullName = join(
+                    this.instance.id,
+                    received.key.remoteJid,
+                    mediaType,
+                    fileName,
+                  );
+
                   await s3Service.uploadFile(fullName, buffer, size.fileLength?.low, {
                     'Content-Type': mimetype,
                   });
-
                   await this.prismaRepository.media.create({
                     data: {
                       messageId: msg.id,
@@ -1422,6 +1440,11 @@ export class BaileysStartupService extends ChannelStartupService {
           continue;
         }
 
+        if (!key.id) {
+          console.warn(`Mensagem sem key.id, pulando update: ${JSON.stringify(key)}`);
+          continue;
+        }
+
         if (status[update.status] === 'READ' && key.fromMe) {
           if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
             this.chatwootService.eventWhatsapp(
@@ -1509,7 +1532,7 @@ export class BaileysStartupService extends ChannelStartupService {
             remoteJid: key.remoteJid,
             fromMe: key.fromMe,
             participant: key?.remoteJid,
-            status: status[update.status],
+            status: status[update.status]?? 'UNKNOWN',
             pollUpdates,
             instanceId: this.instanceId,
           };
@@ -3601,94 +3624,145 @@ export class BaileysStartupService extends ChannelStartupService {
     }
   }
 
-  public async getBase64FromMediaMessage(data: getBase64FromMediaMessageDto, getBuffer = false) {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  public async getBase64FromMediaMessage(
+    data: getBase64FromMediaMessageDto,
+    getBuffer = false
+  ) {
     try {
       const m = data?.message;
       const convertToMp4 = data?.convertToMp4 ?? false;
-
-      const msg = m?.message ? m : ((await this.getMessage(m.key, true)) as proto.IWebMessageInfo);
-
+  
+      // Se já houver propriedade "message", usa-o; senão, busca-o via key
+      const msg: proto.IWebMessageInfo = m?.message
+        ? m
+        : (await this.getMessage(m.key, true)) as proto.IWebMessageInfo;
       if (!msg) {
-        throw 'Message not found';
+        throw new Error('Message not found');
       }
-
+  
+      // Verifica se o conteúdo está aninhado em algum subtipo (ex.: extendedTextMessage)
       for (const subtype of MessageSubtype) {
         if (msg.message[subtype]) {
           msg.message = msg.message[subtype].message;
+          break;
         }
       }
-
+  
+      // Identifica o tipo de mídia contido na mensagem
       let mediaMessage: any;
-      let mediaType: string;
-
+      let mediaType = '';
       for (const type of TypeMediaMessage) {
-        mediaMessage = msg.message[type];
-        if (mediaMessage) {
+        if (msg.message[type]) {
+          mediaMessage = msg.message[type];
           mediaType = type;
           break;
         }
       }
-
       if (!mediaMessage) {
-        throw 'The message is not of the media type';
+        throw new Error('The message is not of the media type');
       }
-
-      if (typeof mediaMessage['mediaKey'] === 'object') {
+  
+      // Se o mediaKey for um objeto, forçamos a serialização para “descolar” possíveis problemas
+      if (typeof mediaMessage.mediaKey === 'object') {
         msg.message = JSON.parse(JSON.stringify(msg.message));
       }
-
-      const buffer = await downloadMediaMessage(
-        { key: msg?.key, message: msg?.message },
-        'buffer',
-        {},
-        {
-          logger: P({ level: 'error' }) as any,
-          reuploadRequest: this.client.updateMediaMessage,
+  
+      // Define um contexto completo conforme DownloadMediaMessageContext
+      const downloadContext: DownloadMediaMessageContext = {
+        logger: P({ level: 'error' }),
+        reuploadRequest: async (message: WAMessage): Promise<WAMessage> => {
+          // Aqui chamamos explicitamente o método que atualiza a mídia;
+          // Se o método updateMediaMessage não retornar nada (void), retornamos a própria mensagem.
+          const updatedMsg = await this.client.updateMediaMessage(message);
+          return updatedMsg ? updatedMsg : message;
         },
-      );
+      };
+  
+      let buffer: Buffer;
+      try {
+        // Tenta baixar a mídia usando o contexto com reuploadRequest
+        buffer = (await downloadMediaMessage(
+          { key: msg.key, message: msg.message },
+          'buffer',
+          {},
+          downloadContext
+        )) as Buffer;
+      } catch (initialError) {
+        this.logger.warn(
+          'Initial downloadMediaMessage failed, updating media and retrying...'
+        );
+        // Se a tentativa falhar (possivelmente por URL expirada), atualiza a mídia e refaz o download
+        await this.client.updateMediaMessage(msg);
+        buffer = (await downloadMediaMessage(
+          { key: msg.key, message: msg.message },
+          'buffer',
+          {},
+          { logger: P({ level: 'error' }), reuploadRequest: async (m: WAMessage) => m } // Contexto “vazio”
+        )) as Buffer;
+      }
+  
       const typeMessage = getContentType(msg.message);
-
-      const ext = mimeTypes.extension(mediaMessage?.['mimetype']);
-      const fileName = mediaMessage?.['fileName'] || `${msg.key.id}.${ext}` || `${v4()}.${ext}`;
-
+      const ext = mimeTypes.extension(mediaMessage?.mimetype);
+      const fileName =
+        mediaMessage?.fileName || `${msg.key.id}.${ext}` || `${v4()}.${ext}`;
+  
+      // Se for áudio e for pedido converter para mp4, processa a conversão
       if (convertToMp4 && typeMessage === 'audioMessage') {
         try {
-          const convert = await this.processAudioMp4(buffer.toString('base64'));
-
-          if (Buffer.isBuffer(convert)) {
-            const result = {
+          const converted = await this.processAudioMp4(buffer.toString('base64'));
+          if (Buffer.isBuffer(converted)) {
+            return {
               mediaType,
               fileName,
-              caption: mediaMessage['caption'],
+              caption: mediaMessage.caption,
               size: {
-                fileLength: mediaMessage['fileLength'],
-                height: mediaMessage['height'],
-                width: mediaMessage['width'],
+                fileLength: mediaMessage.fileLength,
+                height: mediaMessage.height,
+                width: mediaMessage.width,
               },
               mimetype: 'audio/mp4',
-              base64: convert.toString('base64'),
-              buffer: getBuffer ? convert : null,
+              base64: converted.toString('base64'),
+              buffer: getBuffer ? converted : null,
             };
-
-            return result;
           }
-        } catch (error) {
+        } catch (convertError) {
           this.logger.error('Error converting audio to mp4:');
-          this.logger.error(error);
+          this.logger.error(convertError);
           throw new BadRequestException('Failed to convert audio to MP4');
         }
       }
-
+  
+      // Retorna os dados da mídia
       return {
         mediaType,
         fileName,
-        caption: mediaMessage['caption'],
+        caption: mediaMessage.caption,
         size: {
-          fileLength: mediaMessage['fileLength'],
-          height: mediaMessage['height'],
-          width: mediaMessage['width'],
+          fileLength: mediaMessage.fileLength,
+          height: mediaMessage.height,
+          width: mediaMessage.width,
         },
-        mimetype: mediaMessage['mimetype'],
+        mimetype: mediaMessage.mimetype,
         base64: buffer.toString('base64'),
         buffer: getBuffer ? buffer : null,
       };
@@ -3699,6 +3773,19 @@ export class BaileysStartupService extends ChannelStartupService {
     }
   }
 
+
+
+
+
+
+
+
+
+
+
+
+
+
   public async fetchPrivacySettings() {
     const privacy = await this.client.fetchPrivacySettings();
 
@@ -4406,29 +4493,41 @@ export class BaileysStartupService extends ChannelStartupService {
     return unreadMessages;
   }
 
-  private async addLabel(labelId: string, instanceId: string, chatId: string) {
-    const id = cuid();
-
-    await this.prismaRepository.$executeRawUnsafe(
-      `INSERT INTO "Chat" ("id", "instanceId", "remoteJid", "labels", "createdAt", "updatedAt")
-       VALUES ($4, $2, $3, to_jsonb(ARRAY[$1]::text[]), NOW(), NOW()) ON CONFLICT ("instanceId", "remoteJid")
-     DO
-      UPDATE
-          SET "labels" = (
-          SELECT to_jsonb(array_agg(DISTINCT elem))
-          FROM (
-          SELECT jsonb_array_elements_text("Chat"."labels") AS elem
-          UNION
-          SELECT $1::text AS elem
-          ) sub
-          ),
-          "updatedAt" = NOW();`,
-      labelId,
-      instanceId,
-      chatId,
-      id,
-    );
+  private async addLabel(
+    labelId: string,
+    instanceId: string,
+    chatId: string
+  ): Promise<void> {
+    try {
+      await this.prismaRepository.$executeRawUnsafe(
+        `UPDATE "Chat"
+           SET "labels" = (
+             SELECT to_jsonb(array_agg(DISTINCT elem))
+             FROM (
+               SELECT jsonb_array_elements_text("Chat".labels) AS elem
+               UNION
+               SELECT $1::text AS elem
+             ) sub
+           ),
+           "updatedAt" = NOW()
+         WHERE "instanceId" = $2
+           AND "remoteJid"  = $3;`,
+        labelId,
+        instanceId,
+        chatId
+      );
+    } catch (err: unknown) {
+      // Não deixa quebrar nada: registra e segue em frente
+      const msg =
+        err instanceof Error ? err.message : JSON.stringify(err);
+      // Use console.warn para evitar conflito de assinatura de método
+      console.warn(
+        `Failed to add label ${labelId} to chat ${chatId}@${instanceId}: ${msg}`
+      );
+    }
   }
+  
+  
 
   private async removeLabel(labelId: string, instanceId: string, chatId: string) {
     const id = cuid();
diff --git a/src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts b/src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts
index 77b58bbe..834d97b8 100644
--- a/src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts
+++ b/src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts
@@ -50,7 +50,7 @@ export class ChatwootService {
     private readonly configService: ConfigService,
     private readonly prismaRepository: PrismaRepository,
     private readonly cache: CacheService,
-  ) {}
+  ) { }
 
   private pgClient = postgresClient.getChatwootConnection();
 
@@ -295,52 +295,84 @@ export class ChatwootService {
     avatar_url?: string,
     jid?: string,
   ) {
+    this.logger.verbose(
+      `[ChatwootService][createContact] start instance=${instance.instanceName} phone=${phoneNumber}`
+    );
+  
+    // 1) obter cliente
     const client = await this.clientCw(instance);
-
     if (!client) {
-      this.logger.warn('client not found');
+      this.logger.warn(
+        `[ChatwootService][createContact] client not found for instance=${instance.instanceName}`
+      );
       return null;
     }
-
-    let data: any = {};
+    this.logger.verbose(`[ChatwootService][createContact] client obtained`);
+  
+    // 2) montar payload
+    const data: any = { inbox_id: inboxId, name: name || phoneNumber, avatar_url };
     if (!isGroup) {
-      data = {
-        inbox_id: inboxId,
-        name: name || phoneNumber,
-        identifier: jid,
-        avatar_url: avatar_url,
-      };
-
-      if ((jid && jid.includes('@')) || !jid) {
-        data['phone_number'] = `+${phoneNumber}`;
-      }
+      data.identifier = jid;
+      data.phone_number = `+${phoneNumber}`;
     } else {
-      data = {
-        inbox_id: inboxId,
-        name: name || phoneNumber,
-        identifier: phoneNumber,
-        avatar_url: avatar_url,
-      };
+      data.identifier = phoneNumber;
     }
-
-    const contact = await client.contacts.create({
-      accountId: this.provider.accountId,
-      data,
-    });
-
-    if (!contact) {
-      this.logger.warn('contact not found');
+    this.logger.verbose(
+      `[ChatwootService][createContact] payload=${JSON.stringify(data)}`
+    );
+  
+    // 3) criar no Chatwoot
+    let rawResponse: any;
+    try {
+      rawResponse = await client.contacts.create({
+        accountId: this.provider.accountId,
+        data,
+      });
+      this.logger.verbose(
+        `[ChatwootService][createContact] raw create response=${JSON.stringify(rawResponse)}`
+      );
+    } catch (err) {
+      this.logger.error(
+        `[ChatwootService][createContact] error creating contact: ${err}`
+      );
+      throw err;
+    }
+  
+    // 4) extrair o contactId dos dois possíveis formatos
+    //    - legacy: { id: number, ... }
+    //    - nova versão: { payload: { contact: { id: number, ... } } }
+    const maybePayload = rawResponse.payload?.contact;
+    const contactObj = maybePayload ?? rawResponse;
+    const contactId = contactObj.id as number | undefined;
+  
+    if (!contactId) {
+      this.logger.error(
+        `[ChatwootService][createContact] no id found in response; raw=${JSON.stringify(rawResponse)}`
+      );
       return null;
     }
-
-    const findContact = await this.findContact(instance, phoneNumber);
-
-    const contactId = findContact?.id;
-
-    await this.addLabelToContact(this.provider.nameInbox, contactId);
-
-    return contact;
+    this.logger.verbose(
+      `[ChatwootService][createContact] created contact id=${contactId}`
+    );
+  
+    // 5) adicionar label
+    try {
+      this.logger.verbose(
+        `[ChatwootService][createContact] adding label=${this.provider.nameInbox} to contactId=${contactId}`
+      );
+      await this.addLabelToContact(this.provider.nameInbox, contactId);
+    } catch (err) {
+      this.logger.error(
+        `[ChatwootService][createContact] error addLabelToContact: ${err}`
+      );
+    }
+  
+    // 6) retornar objeto com .id para ser usado pelo createConversation
+    return { id: contactId, ...contactObj };
   }
+  
+  
+  
 
   public async updateContact(instance: InstanceDto, id: number, data: any) {
     const client = await this.clientCw(instance);
@@ -380,21 +412,21 @@ export class ChatwootService {
       const taggingsCount = tagData?.taggings_count || 0;
 
       const sqlTag = `INSERT INTO tags (name, taggings_count) 
-                      VALUES ($1, $2) 
-                      ON CONFLICT (name) 
-                      DO UPDATE SET taggings_count = tags.taggings_count + 1 
-                      RETURNING id`;
+                        VALUES ($1, $2) 
+                        ON CONFLICT (name) 
+                        DO UPDATE SET taggings_count = tags.taggings_count + 1 
+                        RETURNING id`;
 
       tagId = (await this.pgClient.query(sqlTag, [nameInbox, taggingsCount + 1]))?.rows[0]?.id;
 
       const sqlCheckTagging = `SELECT 1 FROM taggings 
-                               WHERE tag_id = $1 AND taggable_type = 'Contact' AND taggable_id = $2 AND context = 'labels' LIMIT 1`;
+                                WHERE tag_id = $1 AND taggable_type = 'Contact' AND taggable_id = $2 AND context = 'labels' LIMIT 1`;
 
       const taggingExists = (await this.pgClient.query(sqlCheckTagging, [tagId, contactId]))?.rowCount > 0;
 
       if (!taggingExists) {
         const sqlInsertLabel = `INSERT INTO taggings (tag_id, taggable_type, taggable_id, context, created_at) 
-                                VALUES ($1, 'Contact', $2, 'labels', NOW())`;
+                                  VALUES ($1, 'Contact', $2, 'labels', NOW())`;
 
         await this.pgClient.query(sqlInsertLabel, [tagId, contactId]);
       }
@@ -406,50 +438,77 @@ export class ChatwootService {
   }
 
   public async findContact(instance: InstanceDto, phoneNumber: string) {
+    this.logger.verbose(
+      `[ChatwootService][findContact] start for instance=${instance.instanceName}, phoneNumber=${phoneNumber}`
+    );
+  
     const client = await this.clientCw(instance);
-
     if (!client) {
-      this.logger.warn('client not found');
+      this.logger.warn(
+        `[ChatwootService][findContact] client not found for instance=${instance.instanceName}`
+      );
       return null;
     }
-
-    let query: any;
+  
     const isGroup = phoneNumber.includes('@g.us');
-
-    if (!isGroup) {
-      query = `+${phoneNumber}`;
-    } else {
-      query = phoneNumber;
-    }
-
-    let contact: any;
-
-    if (isGroup) {
-      contact = await client.contacts.search({
-        accountId: this.provider.accountId,
-        q: query,
-      });
-    } else {
-      contact = await chatwootRequest(this.getClientCwConfig(), {
-        method: 'POST',
-        url: `/api/v1/accounts/${this.provider.accountId}/contacts/filter`,
-        body: {
-          payload: this.getFilterPayload(query),
-        },
-      });
+    const query = isGroup ? phoneNumber : `+${phoneNumber}`;
+  
+    this.logger.verbose(
+      `[ChatwootService][findContact] isGroup=${isGroup}, query=${query}`
+    );
+  
+    let response: any;
+    try {
+      if (isGroup) {
+        response = await client.contacts.search({
+          accountId: this.provider.accountId,
+          q: query,
+        });
+      } else {
+        response = await chatwootRequest(this.getClientCwConfig(), {
+          method: 'POST',
+          url: `/api/v1/accounts/${this.provider.accountId}/contacts/filter`,
+          body: { payload: this.getFilterPayload(query) },
+        });
+      }
+      this.logger.verbose(
+        `[ChatwootService][findContact] raw response: ${JSON.stringify(response)}`
+      );
+    } catch (error) {
+      this.logger.error(
+        `[ChatwootService][findContact] error during API call: ${error.message}`
+      );
+      return null;
     }
-
-    if (!contact && contact?.payload?.length === 0) {
-      this.logger.warn('contact not found');
+  
+    const payload = response.payload || [];
+    this.logger.verbose(
+      `[ChatwootService][findContact] payload length: ${payload.length}`
+    );
+  
+    if (payload.length === 0) {
+      this.logger.warn(
+        `[ChatwootService][findContact] contact not found for query=${query}`
+      );
       return null;
     }
-
-    if (!isGroup) {
-      return contact.payload.length > 1 ? this.findContactInContactList(contact.payload, query) : contact.payload[0];
+  
+    let found: any;
+    if (isGroup) {
+      found = payload.find((c: any) => c.identifier === query);
     } else {
-      return contact.payload.find((contact) => contact.identifier === query);
+      found = payload.length > 1
+        ? this.findContactInContactList(payload, query)
+        : payload[0];
     }
+  
+    this.logger.verbose(
+      `[ChatwootService][findContact] returning contact: ${JSON.stringify(found)}`
+    );
+  
+    return found;
   }
+  
 
   private async mergeBrazilianContacts(contacts: any[]) {
     try {
@@ -542,219 +601,229 @@ export class ChatwootService {
     return filterPayload;
   }
 
-  public async createConversation(instance: InstanceDto, body: any) {
-    try {
-      this.logger.verbose('--- Start createConversation ---');
-      this.logger.verbose(`Instance: ${JSON.stringify(instance)}`);
-
-      const client = await this.clientCw(instance);
-
-      if (!client) {
-        this.logger.warn(`Client not found for instance: ${JSON.stringify(instance)}`);
-        return null;
-      }
-
-      const cacheKey = `${instance.instanceName}:createConversation-${body.key.remoteJid}`;
-      this.logger.verbose(`Cache key: ${cacheKey}`);
-
-      if (await this.cache.has(cacheKey)) {
-        this.logger.verbose(`Cache hit for key: ${cacheKey}`);
-        const conversationId = (await this.cache.get(cacheKey)) as number;
-        this.logger.verbose(`Cached conversation ID: ${conversationId}`);
-        let conversationExists: conversation | boolean;
-        try {
-          conversationExists = await client.conversations.get({
-            accountId: this.provider.accountId,
-            conversationId: conversationId,
-          });
-          this.logger.verbose(`Conversation exists: ${JSON.stringify(conversationExists)}`);
-        } catch (error) {
-          this.logger.error(`Error getting conversation: ${error}`);
-          conversationExists = false;
-        }
-        if (!conversationExists) {
-          this.logger.verbose('Conversation does not exist, re-calling createConversation');
-          this.cache.delete(cacheKey);
-          return await this.createConversation(instance, body);
+ 
+
+  private pendingCreateConv = new Map<string, Promise<number>>();
+
+  public async createConversation(instance: InstanceDto, body: any): Promise<number> {
+    const remoteJid = body.key.remoteJid as string;
+    this.logger.verbose("[createConversation] Iniciando para remoteJid=" + remoteJid);
+  
+    // 0) Se já está criando, reutiliza a promise
+    if (this.pendingCreateConv.has(remoteJid)) {
+      this.logger.verbose("[createConversation] Ja em criacao para " + remoteJid + ", retornando promise existente");
+      return this.pendingCreateConv.get(remoteJid)!;
+    }
+  
+    let triedRecovery = false;
+    const cacheKey = instance.instanceName + ":createConversation-" + remoteJid;
+  
+    const p = (async (): Promise<number> => {
+      try {
+        this.logger.verbose("[createConversation] Chamando _createConversation pela primeira vez");
+        return await this._createConversation(instance, body);
+      } catch (err) {
+        this.logger.error("[createConversation] Erro na primeira tentativa: " + err);
+        if (!triedRecovery) {
+          triedRecovery = true;
+          this.logger.warn("[createConversation] Tentando recuperacao: limpando cache e recriando conversa");
+          await this.cache.delete(cacheKey);
+          this.logger.verbose("[createConversation] Cache deletado para chave=" + cacheKey);
+          return await this._createConversation(instance, body);
         }
-
-        return conversationId;
+        this.logger.error("[createConversation] Ja tentei recuperacao, repassando erro");
+        throw err;
       }
+    })();
+  
+    this.pendingCreateConv.set(remoteJid, p);
+    try {
+      const convId = await p;
+      this.logger.verbose("[createConversation] Concluido para " + remoteJid + ", convId=" + convId);
+      return convId;
+    } finally {
+      this.pendingCreateConv.delete(remoteJid);
+      this.logger.verbose("[createConversation] Removido pendingCreateConv para " + remoteJid);
+    }
+  }
 
-      const isGroup = body.key.remoteJid.includes('@g.us');
-      this.logger.verbose(`Is group: ${isGroup}`);
-
-      const chatId = isGroup ? body.key.remoteJid : body.key.remoteJid.split('@')[0];
-      this.logger.verbose(`Chat ID: ${chatId}`);
-
-      let nameContact: string;
-
-      nameContact = !body.key.fromMe ? body.pushName : chatId;
-      this.logger.verbose(`Name contact: ${nameContact}`);
 
-      const filterInbox = await this.getInbox(instance);
+ 
+  
+  private async _createConversation(instance: InstanceDto, body: any): Promise<number> {
+    const remoteJid = body.key.remoteJid as string;
+    const cacheKey = instance.instanceName + ":createConversation-" + remoteJid;
+    this.logger.verbose("[_createConversation] Start para remoteJid=" + remoteJid);
+  
+    // 1) Cliente Chatwoot
+    const client = await this.clientCw(instance);
+    if (!client) {
+      this.logger.error("[_createConversation] Client Chatwoot nao encontrado para " + instance.instanceName);
+      throw new Error("Client not found for instance: " + instance.instanceName);
+    }
+    this.logger.verbose("[_createConversation] Client Chatwoot obtido");
+  
+    // 2) Cache
+    const hasCache = await this.cache.has(cacheKey);
+    this.logger.verbose("[_createConversation] Cache check para key=" + cacheKey + ": " + hasCache);
+    if (hasCache) {
+      const cachedId = (await this.cache.get(cacheKey)) as number;
+      this.logger.verbose("[_createConversation] Usando ID em cache=" + cachedId);
+      return cachedId;
+    }
+  
+    // 3) Inbox
+    const filterInbox = await this.getInbox(instance);
+    if (!filterInbox) {
+      this.logger.error("[_createConversation] Inbox nao encontrada para " + instance.instanceName);
+      throw new Error("Inbox not found for instance: " + instance.instanceName);
+    }
+    this.logger.verbose("[_createConversation] Inbox encontrada: id=" + filterInbox.id);
+  
+    // 4) Contato
+    const isGroup = remoteJid.includes("@g.us");
+    const chatId = isGroup ? remoteJid : remoteJid.split("@")[0];
+    this.logger.verbose("[_createConversation] isGroup=" + isGroup + ", chatId=" + chatId);
+  
+    let contact = await this.findContact(instance, chatId);
+    if (contact) {
+      this.logger.verbose("[_createConversation] Contato encontrado: id=" + contact.id);
+    } else {
+      this.logger.verbose("[_createConversation] Contato nao existe, criando...");
 
-      if (!filterInbox) {
-        this.logger.warn(`Inbox not found for instance: ${JSON.stringify(instance)}`);
-        return null;
-      }
 
-      if (isGroup) {
-        this.logger.verbose('Processing group conversation');
-        const group = await this.waMonitor.waInstances[instance.instanceName].client.groupMetadata(chatId);
-        this.logger.verbose(`Group metadata: ${JSON.stringify(group)}`);
+      const isOutgoing = body.key.fromMe;
+      const senderName = !isOutgoing && body.pushName ? body.pushName : chatId;
 
-        nameContact = `${group.subject} (GROUP)`;
+      const name = isGroup
+        ? (await this.waMonitor.waInstances[instance.instanceName]
+              .client.groupMetadata(chatId)).subject + " (GROUP)"
+        : senderName;
 
-        const picture_url = await this.waMonitor.waInstances[instance.instanceName].profilePicture(
-          body.key.participant.split('@')[0],
-        );
-        this.logger.verbose(`Participant profile picture URL: ${JSON.stringify(picture_url)}`);
 
-        const findParticipant = await this.findContact(instance, body.key.participant.split('@')[0]);
-        this.logger.verbose(`Found participant: ${JSON.stringify(findParticipant)}`);
 
-        if (findParticipant) {
-          if (!findParticipant.name || findParticipant.name === chatId) {
-            await this.updateContact(instance, findParticipant.id, {
-              name: body.pushName,
-              avatar_url: picture_url.profilePictureUrl || null,
-            });
-          }
-        } else {
-          await this.createContact(
-            instance,
-            body.key.participant.split('@')[0],
-            filterInbox.id,
-            false,
-            body.pushName,
-            picture_url.profilePictureUrl || null,
-            body.key.participant,
-          );
-        }
+      const pictureUrl = (await this.waMonitor.waInstances[instance.instanceName].profilePicture(chatId)).profilePictureUrl;
+      contact = await this.createContact(
+        instance,
+        chatId,
+        filterInbox.id,
+        isGroup,
+        name,
+        pictureUrl || null,
+        isGroup ? remoteJid : undefined
+      );
+      if (!contact) {
+        this.logger.error("[_createConversation] Falha ao criar contato para " + chatId);
+        throw new Error("Nao conseguiu criar contato para conversa");
       }
+      this.logger.verbose("[_createConversation] Contato criado: id=" + contact.id);
+    }
+    const contactId = (contact.id ?? contact.payload?.contact?.id) as number;
+  
+    // 5) Listar conversas existentes
+    this.logger.verbose("[_createConversation] Chamando listConversations para contactId=" + contactId);
+    const listResp: any = await client.contacts.listConversations({
+      accountId: this.provider.accountId,
+      id: contactId,
+    });
+    this.logger.verbose("[_createConversation] listConversations raw: " + JSON.stringify(listResp));
+  
+    let conversations: any[] = [];
+    if (Array.isArray(listResp)) conversations = listResp;
+    else if (Array.isArray(listResp.payload)) conversations = listResp.payload;
+    else if (Array.isArray(listResp.data?.payload)) conversations = listResp.data.payload;
+    else if (Array.isArray(listResp.data)) conversations = listResp.data;
+    this.logger.verbose("[_createConversation] Encontradas " + conversations.length + " conversas");
+  
+    // 6) Filtrar conversa aberta ou pendente
+    let conv = null;
+    if (this.provider.reopenConversation) {
+      this.logger.verbose("[_createConversation] reopenConversation=true, buscando inbox_id=" + filterInbox.id);
+      conv = conversations.find(c => c.inbox_id === filterInbox.id);
+      if (conv && this.provider.conversationPending && conv.status !== "pending") {
+        this.logger.verbose("[_createConversation] Reabrindo conversa " + conv.id + " para status=pending");
+        await client.conversations.toggleStatus({
+          accountId: this.provider.accountId,
+          conversationId: conv.id,
+          data: { status: "pending" },
+        });
+      }
+    } else {
+      this.logger.verbose("[_createConversation] reopenConversation=false, buscando status!=resolved");
+      conv = conversations.find(c => c.status !== "resolved" && c.inbox_id === filterInbox.id);
+    }
+  
+    if (conv) {
+      this.logger.verbose("[_createConversation] Usando conversa existente id=" + conv.id);
+      this.cache.set(cacheKey, conv.id, 5 * 60);
+      return conv.id;
+    }
+  
+    // 7) Criar nova conversa
+    this.logger.verbose("[_createConversation] Nenhuma conversa encontrada, criando nova...");
+    const payload: any = {
+      contact_id: contactId.toString(),
+      inbox_id: filterInbox.id.toString(),
+      ...(this.provider.conversationPending ? { status: "pending" } : {}),
+    };
+  
+    try {
+      const newConv = await client.conversations.create({
+        accountId: this.provider.accountId,
+        data: payload,
+      });
 
-      const picture_url = await this.waMonitor.waInstances[instance.instanceName].profilePicture(chatId);
-      this.logger.verbose(`Contact profile picture URL: ${JSON.stringify(picture_url)}`);
-
-      let contact = await this.findContact(instance, chatId);
-      this.logger.verbose(`Found contact: ${JSON.stringify(contact)}`);
+      const displayId = (newConv as any).display_id ?? newConv.id;
 
-      if (contact) {
-        if (!body.key.fromMe) {
-          const waProfilePictureFile =
-            picture_url?.profilePictureUrl?.split('#')[0].split('?')[0].split('/').pop() || '';
-          const chatwootProfilePictureFile = contact?.thumbnail?.split('#')[0].split('?')[0].split('/').pop() || '';
-          const pictureNeedsUpdate = waProfilePictureFile !== chatwootProfilePictureFile;
-          const nameNeedsUpdate =
-            !contact.name ||
-            contact.name === chatId ||
-            (`+${chatId}`.startsWith('+55')
-              ? this.getNumbers(`+${chatId}`).some(
-                  (v) => contact.name === v || contact.name === v.substring(3) || contact.name === v.substring(1),
-                )
-              : false);
-
-          this.logger.verbose(`Picture needs update: ${pictureNeedsUpdate}`);
-          this.logger.verbose(`Name needs update: ${nameNeedsUpdate}`);
-
-          if (pictureNeedsUpdate || nameNeedsUpdate) {
-            contact = await this.updateContact(instance, contact.id, {
-              ...(nameNeedsUpdate && { name: nameContact }),
-              ...(waProfilePictureFile === '' && { avatar: null }),
-              ...(pictureNeedsUpdate && { avatar_url: picture_url?.profilePictureUrl }),
-            });
-          }
-        }
-      } else {
-        const jid = body.key.remoteJid;
-        contact = await this.createContact(
-          instance,
-          chatId,
-          filterInbox.id,
-          isGroup,
-          nameContact,
-          picture_url.profilePictureUrl || null,
-          jid,
-        );
+      if (!displayId) {
+        this.logger.error("[_createConversation] create retornou sem DisplayID");
+        throw new Error("Falha ao criar nova conversa: resposta sem DisplayID");
       }
-
-      if (!contact) {
-        this.logger.warn('Contact not created or found');
-        return null;
+      this.logger.verbose("[_createConversation] Nova conversa criada DisplayId=" + displayId);
+      this.cache.set(cacheKey, displayId, 5 * 60);
+      return displayId;
+  
+    } catch (err: any) {
+      this.logger.error("[_createConversation] Erro ao criar conversa: " + err);
+      this.logger.warn("[_createConversation] Tentando recuperar conversa via listConversations novamente");
+  
+      const retryList: any = await client.contacts.listConversations({
+        accountId: this.provider.accountId,
+        id: contactId,
+      });
+      this.logger.verbose("[_createConversation] retry listConversations raw: " + JSON.stringify(retryList));
+  
+      let retryConvs: any[] = [];
+      if (Array.isArray(retryList)) retryConvs = retryList;
+      else if (Array.isArray(retryList.payload)) retryConvs = retryList.payload;
+      else if (Array.isArray(retryList.data?.payload)) retryConvs = retryList.data.payload;
+      else if (Array.isArray(retryList.data)) retryConvs = retryList.data;
+      this.logger.verbose("[_createConversation] retry encontrou " + retryConvs.length + " conversas");
+  
+      const recovered = retryConvs.find(c => c.inbox_id === filterInbox.id);
+      if (recovered) {
+        this.logger.verbose("[_createConversation] Recuperou conversa existente id=" + recovered.id);
+        this.cache.set(cacheKey, recovered.id, 5 * 60);
+        return recovered.id;
       }
+  
+      this.logger.error("[_createConversation] Nao recuperou conversa, repassando erro");
+      throw err;
+    }
+  }
+  
+
+
 
-      const contactId = contact?.payload?.id || contact?.payload?.contact?.id || contact?.id;
-      this.logger.verbose(`Contact ID: ${contactId}`);
 
-      const contactConversations = (await client.contacts.listConversations({
-        accountId: this.provider.accountId,
-        id: contactId,
-      })) as any;
-      this.logger.verbose(`Contact conversations: ${JSON.stringify(contactConversations)}`);
 
-      if (!contactConversations || !contactConversations.payload) {
-        this.logger.error('No conversations found or payload is undefined');
-        return null;
-      }
 
-      if (contactConversations.payload.length) {
-        let conversation: any;
-        if (this.provider.reopenConversation) {
-          conversation = contactConversations.payload.find((conversation) => conversation.inbox_id == filterInbox.id);
-          this.logger.verbose(`Found conversation in reopenConversation mode: ${JSON.stringify(conversation)}`);
-
-          if (this.provider.conversationPending && conversation.status !== 'open') {
-            if (conversation) {
-              await client.conversations.toggleStatus({
-                accountId: this.provider.accountId,
-                conversationId: conversation.id,
-                data: {
-                  status: 'pending',
-                },
-              });
-            }
-          }
-        } else {
-          conversation = contactConversations.payload.find(
-            (conversation) => conversation.status !== 'resolved' && conversation.inbox_id == filterInbox.id,
-          );
-          this.logger.verbose(`Found conversation: ${JSON.stringify(conversation)}`);
-        }
 
-        if (conversation) {
-          this.logger.verbose(`Returning existing conversation ID: ${conversation.id}`);
-          this.cache.set(cacheKey, conversation.id);
-          return conversation.id;
-        }
-      }
 
-      const data = {
-        contact_id: contactId.toString(),
-        inbox_id: filterInbox.id.toString(),
-      };
 
-      if (this.provider.conversationPending) {
-        data['status'] = 'pending';
-      }
 
-      const conversation = await client.conversations.create({
-        accountId: this.provider.accountId,
-        data,
-      });
 
-      if (!conversation) {
-        this.logger.warn('Conversation not created or found');
-        return null;
-      }
 
-      this.logger.verbose(`New conversation created with ID: ${conversation.id}`);
-      this.cache.set(cacheKey, conversation.id);
-      return conversation.id;
-    } catch (error) {
-      this.logger.error(`Error in createConversation: ${error}`);
-    }
-  }
 
   public async getInbox(instance: InstanceDto): Promise<inbox | null> {
     const cacheKey = `${instance.instanceName}:getInbox`;
@@ -804,6 +873,15 @@ export class ChatwootService {
     sourceId?: string,
     quotedMsg?: MessageModel,
   ) {
+
+    if (sourceId && this.isImportHistoryAvailable()) {
+      const messageAlreadySaved = await chatwootImport.getExistingSourceIds([sourceId]);
+      if (messageAlreadySaved && messageAlreadySaved.size > 0) {
+        this.logger.warn('Message already saved on chatwoot');
+        return null;
+      }
+    }
+
     const client = await this.clientCw(instance);
 
     if (!client) {
@@ -1208,10 +1286,10 @@ export class ChatwootService {
       // Chatwoot to Whatsapp
       const messageReceived = body.content
         ? body.content
-            .replaceAll(/(?<!\*)\*((?!\s)([^\n*]+?)(?<!\s))\*(?!\*)/g, '_$1_') // Substitui * por _
-            .replaceAll(/\*{2}((?!\s)([^\n*]+?)(?<!\s))\*{2}/g, '*$1*') // Substitui ** por *
-            .replaceAll(/~{2}((?!\s)([^\n*]+?)(?<!\s))~{2}/g, '~$1~') // Substitui ~~ por ~
-            .replaceAll(/(?<!`)`((?!\s)([^`*]+?)(?<!\s))`(?!`)/g, '```$1```') // Substitui ` por ```
+          .replaceAll(/(?<!\*)\*((?!\s)([^\n*]+?)(?<!\s))\*(?!\*)/g, '_$1_') // Substitui * por _
+          .replaceAll(/\*{2}((?!\s)([^\n*]+?)(?<!\s))\*{2}/g, '*$1*') // Substitui ** por *
+          .replaceAll(/~{2}((?!\s)([^\n*]+?)(?<!\s))~{2}/g, '~$1~') // Substitui ~~ por ~
+          .replaceAll(/(?<!`)`((?!\s)([^`*]+?)(?<!\s))`(?!`)/g, '```$1```') // Substitui ` por ```
         : body.content;
 
       const senderName = body?.conversation?.messages[0]?.sender?.available_name || body?.sender?.name;
@@ -1893,9 +1971,9 @@ export class ChatwootService {
         const originalMessage = await this.getConversationMessage(body.message);
         const bodyMessage = originalMessage
           ? originalMessage
-              .replaceAll(/\*((?!\s)([^\n*]+?)(?<!\s))\*/g, '**$1**')
-              .replaceAll(/_((?!\s)([^\n_]+?)(?<!\s))_/g, '*$1*')
-              .replaceAll(/~((?!\s)([^\n~]+?)(?<!\s))~/g, '~~$1~~')
+            .replaceAll(/\*((?!\s)([^\n*]+?)(?<!\s))\*/g, '**$1**')
+            .replaceAll(/_((?!\s)([^\n_]+?)(?<!\s))_/g, '*$1*')
+            .replaceAll(/~((?!\s)([^\n~]+?)(?<!\s))~/g, '~~$1~~')
           : originalMessage;
 
         if (bodyMessage && bodyMessage.includes('Por favor, classifique esta conversa, http')) {
@@ -1964,7 +2042,7 @@ export class ChatwootService {
           const fileData = Buffer.from(downloadBase64.base64, 'base64');
 
           const fileStream = new Readable();
-          fileStream._read = () => {};
+          fileStream._read = () => { };
           fileStream.push(fileData);
           fileStream.push(null);
 
@@ -2075,7 +2153,7 @@ export class ChatwootService {
           const processedBuffer = await img.getBufferAsync(Jimp.MIME_PNG);
 
           const fileStream = new Readable();
-          fileStream._read = () => {}; // _read is required but you can noop it
+          fileStream._read = () => { }; // _read is required but you can noop it
           fileStream.push(processedBuffer);
           fileStream.push(null);
 
@@ -2108,27 +2186,47 @@ export class ChatwootService {
         }
 
         if (body.key.remoteJid.includes('@g.us')) {
-          const participantName = body.pushName;
-          const rawPhoneNumber = body.key.participant.split('@')[0];
-          const phoneMatch = rawPhoneNumber.match(/^(\d{2})(\d{2})(\d{4})(\d{4})$/);
-
-          let formattedPhoneNumber: string;
-
-          if (phoneMatch) {
-            formattedPhoneNumber = `+${phoneMatch[1]} (${phoneMatch[2]}) ${phoneMatch[3]}-${phoneMatch[4]}`;
-          } else {
-            formattedPhoneNumber = `+${rawPhoneNumber}`;
-          }
-
-          let content: string;
-
-          if (!body.key.fromMe) {
-            content = `**${formattedPhoneNumber} - ${participantName}:**\n\n${bodyMessage}`;
-          } else {
-            content = `${bodyMessage}`;
+          // Extrai de forma segura o JID do participante
+          const participantJid = body.key.participant;
+          
+          // Se não veio participant, envia mensagem crua
+          if (!participantJid) {
+            const rawContent = bodyMessage;
+            const sent = await this.createMessage(
+              instance,
+              getConversation,
+              rawContent,
+              messageType,
+              false,
+              [],
+              body,
+              'WAID:' + body.key.id,
+              quotedMsg,
+            );
+            if (!sent) this.logger.warn('message not sent');
+            return sent;
           }
-
-          const send = await this.createMessage(
+        
+          // Formata o telefone
+          const rawPhone = participantJid.split('@')[0];
+          const match = rawPhone.match(/^(\d{2})(\d{2})(\d{4})(\d{4})$/);
+          const formattedPhone = match
+            ? `+${match[1]} (${match[2]}) ${match[3]}-${match[4]}`
+            : `+${rawPhone}`;
+        
+          // Define prefixo com número e nome (ou só número, se pushName vazio)
+          const name = body.pushName?.trim();
+          const prefix = name
+            ? `**${formattedPhone} – ${name}:**\n\n`
+            : `**${formattedPhone}:**\n\n`;
+        
+          // Monta o conteúdo, omitindo prefixo em mensagens enviadas por mim
+          const content = body.key.fromMe
+            ? bodyMessage
+            : `${prefix}${bodyMessage}`;
+        
+          // Envia a mensagem formatada
+          const sent = await this.createMessage(
             instance,
             getConversation,
             content,
@@ -2139,13 +2237,8 @@ export class ChatwootService {
             'WAID:' + body.key.id,
             quotedMsg,
           );
-
-          if (!send) {
-            this.logger.warn('message not sent');
-            return;
-          }
-
-          return send;
+          if (!sent) this.logger.warn('message not sent');
+          return sent;
         } else {
           const send = await this.createMessage(
             instance,
@@ -2200,9 +2293,8 @@ export class ChatwootService {
       }
 
       if (event === 'messages.edit') {
-        const editedText = `${
-          body?.editedMessage?.conversation || body?.editedMessage?.extendedTextMessage?.text
-        }\n\n_\`${i18next.t('cw.message.edited')}.\`_`;
+        const editedText = `${body?.editedMessage?.conversation || body?.editedMessage?.extendedTextMessage?.text
+          }\n\n_\`${i18next.t('cw.message.edited')}.\`_`;
         const message = await this.getMessageByKeyId(instance, body?.key?.id);
         const key = message.key as {
           id: string;
@@ -2311,7 +2403,7 @@ export class ChatwootService {
           const fileData = Buffer.from(body?.qrcode.base64.replace('data:image/png;base64,', ''), 'base64');
 
           const fileStream = new Readable();
-          fileStream._read = () => {};
+          fileStream._read = () => { };
           fileStream.push(fileData);
           fileStream.push(null);
 
@@ -2442,17 +2534,26 @@ export class ChatwootService {
         })
       ).reduce((acc: Map<string, ContactModel>, contact: ContactModel) => acc.set(contact.id, contact), new Map());
 
-      recentContacts.forEach(async (contact) => {
-        if (contactsWithProfilePicture.has(contact.identifier)) {
-          client.contacts.update({
+      for (const c of recentContacts) {
+        const pic = contactsWithProfilePicture.get(c.identifier);
+        if (!pic) continue;
+
+        try {
+          await client.contacts.update({
             accountId: this.provider.accountId,
-            id: contact.id,
+            id: c.id,
             data: {
-              avatar_url: contactsWithProfilePicture.get(contact.identifier).profilePictureUrl || null,
+              avatar_url: pic.profilePictureUrl || null,
             },
           });
+          this.logger.verbose(`Avatar atualizado para o contato ${c.id}`);
+        } catch (err) {
+          this.logger.error(`Falha ao atualizar avatar do contato ${c.id}: ${err}`);
         }
-      });
+      }
+
+
+
     } catch (error) {
       this.logger.error(`Error on update avatar in recent conversations: ${error.toString()}`);
     }
@@ -2474,10 +2575,10 @@ export class ChatwootService {
       const inbox = await this.getInbox(instance);
 
       const sqlMessages = `select * from messages m
-      where account_id = ${chatwootConfig.accountId}
-      and inbox_id = ${inbox.id}
-      and created_at >= now() - interval '6h'
-      order by created_at desc`;
+        where account_id = ${chatwootConfig.accountId}
+        and inbox_id = ${inbox.id}
+        and created_at >= now() - interval '6h'
+        order by created_at desc`;
 
       const messagesData = (await this.pgClient.query(sqlMessages))?.rows;
       const ids: string[] = messagesData
diff --git a/src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts b/src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts
index 52453f59..cff97a5b 100644
--- a/src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts
+++ b/src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts
@@ -6,6 +6,7 @@ import { Chatwoot, configService } from '@config/env.config';
 import { Logger } from '@config/logger.config';
 import { inbox } from '@figuro/chatwoot-sdk';
 import { Chatwoot as ChatwootModel, Contact, Message } from '@prisma/client';
+import axios from 'axios';
 import { proto } from 'baileys';
 
 type ChatwootUser = {
@@ -93,8 +94,8 @@ class ChatwootImport {
         return 0;
       }
 
-      let contactsChunk: Contact[] = this.sliceIntoChunks(contacts, 3000);
-      while (contactsChunk.length > 0) {
+      const contactBatches = this.sliceIntoChunks(contacts, 3000);
+      for (const contactsChunk of contactBatches) {
         const labelSql = `SELECT id FROM labels WHERE title = '${provider.nameInbox}' AND account_id = ${provider.accountId} LIMIT 1`;
 
         let labelId = (await pgClient.query(labelSql))?.rows[0]?.id;
@@ -157,8 +158,7 @@ class ChatwootImport {
         }
 
         await pgClient.query(sqlInsertLabel, [tagId, 'Contact', 'labels']);
-
-        contactsChunk = this.sliceIntoChunks(contacts, 3000);
+       
       }
 
       this.deleteHistoryContacts(instance);
@@ -199,6 +199,10 @@ class ChatwootImport {
     provider: ChatwootModel,
   ) {
     try {
+      this.logger.info(
+        `[importHistoryMessages] Iniciando importação de mensagens para a instância "${instance.instanceName}".`
+      );
+
       const pgClient = postgresClient.getChatwootConnection();
 
       const chatwootUser = await this.getChatwootUser(provider);
@@ -206,31 +210,36 @@ class ChatwootImport {
         throw new Error('User not found to import messages.');
       }
 
+      const touchedConversations = new Set<string>();
       let totalMessagesImported = 0;
 
       let messagesOrdered = this.historyMessages.get(instance.instanceName) || [];
+      this.logger.info(
+        `[importHistoryMessages] Número de mensagens recuperadas do histórico: ${messagesOrdered.length}.`
+      );
       if (messagesOrdered.length === 0) {
         return 0;
       }
 
-      // ordering messages by number and timestamp asc
+      // Ordenando as mensagens por remoteJid e timestamp (ascendente)
       messagesOrdered.sort((a, b) => {
-        const aKey = a.key as {
-          remoteJid: string;
-        };
-
-        const bKey = b.key as {
-          remoteJid: string;
-        };
+        const aKey = a.key as { remoteJid: string };
+        const bKey = b.key as { remoteJid: string };
 
         const aMessageTimestamp = a.messageTimestamp as any as number;
         const bMessageTimestamp = b.messageTimestamp as any as number;
 
         return parseInt(aKey.remoteJid) - parseInt(bKey.remoteJid) || aMessageTimestamp - bMessageTimestamp;
       });
+      this.logger.info('[importHistoryMessages] Mensagens ordenadas por remoteJid e messageTimestamp.');
 
+      // Mapeando mensagens por telefone
       const allMessagesMappedByPhoneNumber = this.createMessagesMapByPhoneNumber(messagesOrdered);
-      // Map structure: +552199999999 => { first message timestamp from number, last message timestamp from number}
+      this.logger.info(
+        `[importHistoryMessages] Mensagens mapeadas para ${allMessagesMappedByPhoneNumber.size} números únicos.`
+      );
+
+      // Map: +numero => { first: timestamp, last: timestamp }
       const phoneNumbersWithTimestamp = new Map<string, firstLastTimestamp>();
       allMessagesMappedByPhoneNumber.forEach((messages: Message[], phoneNumber: string) => {
         phoneNumbersWithTimestamp.set(phoneNumber, {
@@ -238,15 +247,37 @@ class ChatwootImport {
           last: messages[messages.length - 1]?.messageTimestamp as any as number,
         });
       });
-
-      const existingSourceIds = await this.getExistingSourceIds(messagesOrdered.map((message: any) => message.key.id));
+      this.logger.info(
+        `[importHistoryMessages] Criado mapa de timestamps para ${phoneNumbersWithTimestamp.size} números.`
+      );
+
+      // Removendo mensagens que já existem no banco (verificação pelo source_id)
+      const existingSourceIds = await this.getExistingSourceIds(
+        messagesOrdered.map((message: any) => message.key.id)
+      );
+      this.logger.info(
+        `[importHistoryMessages] Quantidade de source_ids existentes no banco: ${existingSourceIds.size}.`
+      );
+      const initialCount = messagesOrdered.length;
       messagesOrdered = messagesOrdered.filter((message: any) => !existingSourceIds.has(message.key.id));
-      // processing messages in batch
+      this.logger.info(
+        `[importHistoryMessages] Mensagens filtradas: de ${initialCount} para ${messagesOrdered.length} após remoção de duplicados.`
+      );
+
+      // Processamento das mensagens em batches
       const batchSize = 4000;
-      let messagesChunk: Message[] = this.sliceIntoChunks(messagesOrdered, batchSize);
-      while (messagesChunk.length > 0) {
-        // Map structure: +552199999999 => Message[]
+      let messagesChunks = this.sliceIntoChunks(messagesOrdered, batchSize);
+      let batchNumber = 1;
+      for (const messagesChunk of messagesChunks) {
+        this.logger.info(
+          `[importHistoryMessages] Processando batch ${batchNumber} com ${messagesChunk.length} mensagens.`
+        );
+
+        // Agrupando as mensagens deste batch por telefone
         const messagesByPhoneNumber = this.createMessagesMapByPhoneNumber(messagesChunk);
+        this.logger.info(
+          `[importHistoryMessages] Batch ${batchNumber}: ${messagesByPhoneNumber.size} números únicos encontrados.`
+        );
 
         if (messagesByPhoneNumber.size > 0) {
           const fksByNumber = await this.selectOrCreateFksFromChatwoot(
@@ -256,7 +287,15 @@ class ChatwootImport {
             messagesByPhoneNumber,
           );
 
-          // inserting messages in chatwoot db
+          for (const { conversation_id } of fksByNumber.values()) {
+            touchedConversations.add(conversation_id);
+          }
+          
+          this.logger.info(
+            `[importHistoryMessages] Batch ${batchNumber}: FKs recuperados para ${fksByNumber.size} números.`
+          );
+
+          // Inserindo as mensagens no banco
           let sqlInsertMsg = `INSERT INTO messages
             (content, processed_message_content, account_id, inbox_id, conversation_id, message_type, private, content_type,
             sender_type, sender_id, source_id, created_at, updated_at) VALUES `;
@@ -264,16 +303,16 @@ class ChatwootImport {
 
           messagesByPhoneNumber.forEach((messages: any[], phoneNumber: string) => {
             const fksChatwoot = fksByNumber.get(phoneNumber);
-
+            this.logger.info(
+              `[importHistoryMessages] Número ${phoneNumber}: processando ${messages.length} mensagens.`
+            );
             messages.forEach((message) => {
               if (!message.message) {
                 return;
               }
-
               if (!fksChatwoot?.conversation_id || !fksChatwoot?.contact_id) {
                 return;
               }
-
               const contentMessage = this.getContentMessage(chatwootService, message);
               if (!contentMessage) {
                 return;
@@ -304,127 +343,273 @@ class ChatwootImport {
                   ${bindSenderType},${bindSenderId},${bindSourceId}, to_timestamp(${bindmessageTimestamp}), to_timestamp(${bindmessageTimestamp})),`;
             });
           });
+
+
           if (bindInsertMsg.length > 2) {
             if (sqlInsertMsg.slice(-1) === ',') {
               sqlInsertMsg = sqlInsertMsg.slice(0, -1);
             }
-            totalMessagesImported += (await pgClient.query(sqlInsertMsg, bindInsertMsg))?.rowCount ?? 0;
+            const result = await pgClient.query(sqlInsertMsg, bindInsertMsg);
+            const rowCount = result?.rowCount ?? 0;
+            totalMessagesImported += rowCount;
+            this.logger.info(
+              `[importHistoryMessages] Batch ${batchNumber}: Inseridas ${rowCount} mensagens no banco.`
+            );
           }
         }
-        messagesChunk = this.sliceIntoChunks(messagesOrdered, batchSize);
+        batchNumber++;
+        
       }
 
       this.deleteHistoryMessages(instance);
       this.deleteRepositoryMessagesCache(instance);
 
+
+
+      this.logger.info(
+        `[importHistoryMessages] Histórico e cache de mensagens da instância "${instance.instanceName}" foram limpos.`
+      );
+
+
+      for (const convId of touchedConversations) {
+        await this.safeRefreshConversation(
+          provider.url,         
+          provider.accountId,
+          convId,
+          provider.token
+        );
+      }
+
+
       const providerData: ChatwootDto = {
         ...provider,
         ignoreJids: Array.isArray(provider.ignoreJids) ? provider.ignoreJids.map((event) => String(event)) : [],
       };
 
-      this.importHistoryContacts(instance, providerData);
+      this.logger.info(
+        `[importHistoryMessages] Iniciando importação de contatos do histórico para a instância "${instance.instanceName}".`
+      );
+      await this.importHistoryContacts(instance, providerData);
 
+      this.logger.info(
+        `[importHistoryMessages] Concluída a importação de mensagens para a instância "${instance.instanceName}". Total importado: ${totalMessagesImported}.`
+      );
       return totalMessagesImported;
     } catch (error) {
       this.logger.error(`Error on import history messages: ${error.toString()}`);
-
       this.deleteHistoryMessages(instance);
       this.deleteRepositoryMessagesCache(instance);
     }
   }
 
+
+  private normalizeBrazilianPhoneNumberOptions(raw: string): [string, string] {
+    if (!raw.startsWith('+55')) {
+      return [raw, raw];
+    }
+
+    // Remove o prefixo "+55"
+    const digits = raw.slice(3); // pega tudo após os 3 primeiros caracteres
+
+    if (digits.length === 10) {
+      // Se tiver 10 dígitos, assume que é o formato antigo.
+      // Old: exatamente o valor recebido.
+      // New: insere o '9' após os dois primeiros dígitos.
+      const newDigits = digits.slice(0, 2) + '9' + digits.slice(2);
+      return [raw, `+55${newDigits}`];
+    } else if (digits.length === 11) {
+      // Se tiver 11 dígitos, assume que é o formato novo.
+      // New: exatamente o valor recebido.
+      // Old: remove o dígito extra na terceira posição.
+      const oldDigits = digits.slice(0, 2) + digits.slice(3);
+      return [`+55${oldDigits}`, raw];
+    } else {
+      // Se por algum motivo tiver outra quantidade de dígitos, retorna os mesmos valores.
+      return [raw, raw];
+    }
+  }
+
+
   public async selectOrCreateFksFromChatwoot(
     provider: ChatwootModel,
     inbox: inbox,
     phoneNumbersWithTimestamp: Map<string, firstLastTimestamp>,
-    messagesByPhoneNumber: Map<string, Message[]>,
+    messagesByPhoneNumber: Map<string, Message[]>
   ): Promise<Map<string, FksChatwoot>> {
     const pgClient = postgresClient.getChatwootConnection();
+    const resultMap = new Map<string, FksChatwoot>();
+
+    for (const rawPhone of messagesByPhoneNumber.keys()) {
+      // 1) Normalizar telefone e gerar JIDs
+      const [normalizedWith, normalizedWithout] =
+        this.normalizeBrazilianPhoneNumberOptions(rawPhone);
+      const jidWith = normalizedWith.replace(/^\+/, '') + '@s.whatsapp.net';
+      const jidWithout = normalizedWithout.replace(/^\+/, '') + '@s.whatsapp.net';
+
+      const ts = phoneNumbersWithTimestamp.get(rawPhone);
+      if (!ts) {
+        this.logger.warn(`Timestamp não encontrado para ${rawPhone}`);
+        throw new Error(`Timestamp não encontrado para ${rawPhone}`);
+      }
 
-    const bindValues = [provider.accountId, inbox.id];
-    const phoneNumberBind = Array.from(messagesByPhoneNumber.keys())
-      .map((phoneNumber) => {
-        const phoneNumberTimestamp = phoneNumbersWithTimestamp.get(phoneNumber);
-
-        if (phoneNumberTimestamp) {
-          bindValues.push(phoneNumber);
-          let bindStr = `($${bindValues.length},`;
+      // 2) Buscar ou inserir Contact (agora incluindo identifier)
+      let contact: { id: number; phone_number: string };
+      {
+        const selectContact = `
+          SELECT id, phone_number
+            FROM contacts
+           WHERE account_id = $1
+             AND (
+               phone_number = $2
+               OR phone_number = $3
+               OR identifier   = $4
+               OR identifier   = $5
+             )
+           LIMIT 1
+        `;
+        const res = await pgClient.query(selectContact, [
+          provider.accountId,
+          normalizedWith,
+          normalizedWithout,
+          jidWith,
+          jidWithout
+        ]);
+        if (res.rowCount) {
+          contact = res.rows[0];
+          this.logger.verbose(`Contato existente: ${JSON.stringify(contact)}`);
+        } else {
+          const insertContact = `
+          INSERT INTO contacts
+            (name, phone_number, account_id, identifier, created_at, updated_at)
+          VALUES
+            (
+              REPLACE($2, '+', ''),
+              $2,
+              $1,
+              $5,                -- agora é $5
+              to_timestamp($3),
+              to_timestamp($4)
+            )
+          RETURNING id, phone_number
+        `;
+          const insertRes = await pgClient.query(insertContact, [
+            provider.accountId,   // $1
+            normalizedWith,       // $2
+            ts.first,             // $3
+            ts.last,              // $4
+            jidWith               // $5
+          ]);
+          contact = insertRes.rows[0];
+
+
+          this.logger.verbose(`Contato inserido: ${JSON.stringify(contact)}`);
+        }
+      }
 
-          bindValues.push(phoneNumberTimestamp.first);
-          bindStr += `$${bindValues.length},`;
+      // 3) Buscar ou inserir ContactInbox
+      let contactInboxId: number;
+      {
+        const selectCi = `
+          SELECT id
+            FROM contact_inboxes
+           WHERE contact_id = $1
+             AND inbox_id   = $2
+           LIMIT 1
+        `;
+        const ciRes = await pgClient.query(selectCi, [
+          contact.id,
+          inbox.id
+        ]);
+        if (ciRes.rowCount) {
+          contactInboxId = ciRes.rows[0].id;
+          this.logger.verbose(`Contact_inbox existente: ${contactInboxId}`);
+        } else {
+          const insertCi = `
+            INSERT INTO contact_inboxes
+              (contact_id, inbox_id, source_id, created_at, updated_at)
+            VALUES
+              ($1, $2, gen_random_uuid(), NOW(), NOW())
+            RETURNING id
+          `;
+          const insertRes = await pgClient.query(insertCi, [
+            contact.id,
+            inbox.id
+          ]);
+          contactInboxId = insertRes.rows[0].id;
+          this.logger.verbose(`Contact_inbox inserido: ${contactInboxId}`);
+        }
+      }
 
-          bindValues.push(phoneNumberTimestamp.last);
-          return `${bindStr}$${bindValues.length})`;
+      // 4) Buscar ou inserir Conversation
+      let conversationId: number;
+      {
+        const selectConv = `
+          SELECT id
+            FROM conversations
+           WHERE account_id = $1
+             AND inbox_id   = $2
+             AND contact_id = $3
+           LIMIT 1
+        `;
+        const convRes = await pgClient.query(selectConv, [
+          provider.accountId,
+          inbox.id,
+          contact.id
+        ]);
+        if (convRes.rowCount) {
+          conversationId = convRes.rows[0].id;
+          this.logger.verbose(`Conversa existente: ${conversationId}`);
+        } else {
+          const insertConv = `
+            INSERT INTO conversations
+              (account_id, inbox_id, status, contact_id, contact_inbox_id, uuid,
+               last_activity_at, created_at, updated_at)
+            VALUES
+              ($1, $2, 0, $3, $4, gen_random_uuid(), NOW(), NOW(), NOW())
+            RETURNING id
+          `;
+          const insertRes = await pgClient.query(insertConv, [
+            provider.accountId,
+            inbox.id,
+            contact.id,
+            contactInboxId
+          ]);
+          conversationId = insertRes.rows[0].id;
+          this.logger.verbose(`Conversa inserida: ${conversationId}`);
         }
-      })
-      .join(',');
-
-    // select (or insert when necessary) data from tables contacts, contact_inboxes, conversations from chatwoot db
-    const sqlFromChatwoot = `WITH
-              phone_number AS (
-                SELECT phone_number, created_at::INTEGER, last_activity_at::INTEGER FROM (
-                  VALUES 
-                   ${phoneNumberBind}
-                 ) as t (phone_number, created_at, last_activity_at)
-              ),
-
-              only_new_phone_number AS (
-                SELECT * FROM phone_number
-                WHERE phone_number NOT IN (
-                  SELECT phone_number
-                  FROM contacts
-                    JOIN contact_inboxes ci ON ci.contact_id = contacts.id AND ci.inbox_id = $2
-                    JOIN conversations con ON con.contact_inbox_id = ci.id 
-                      AND con.account_id = $1
-                      AND con.inbox_id = $2
-                      AND con.contact_id = contacts.id
-                  WHERE contacts.account_id = $1
-                )
-              ),
-
-              new_contact AS (
-                INSERT INTO contacts (name, phone_number, account_id, identifier, created_at, updated_at)
-                SELECT REPLACE(p.phone_number, '+', ''), p.phone_number, $1, CONCAT(REPLACE(p.phone_number, '+', ''),
-                  '@s.whatsapp.net'), to_timestamp(p.created_at), to_timestamp(p.last_activity_at)
-                FROM only_new_phone_number AS p
-                ON CONFLICT(identifier, account_id) DO UPDATE SET updated_at = EXCLUDED.updated_at
-                RETURNING id, phone_number, created_at, updated_at
-              ),
-
-              new_contact_inbox AS (
-                INSERT INTO contact_inboxes (contact_id, inbox_id, source_id, created_at, updated_at)
-                SELECT new_contact.id, $2, gen_random_uuid(), new_contact.created_at, new_contact.updated_at
-                FROM new_contact 
-                RETURNING id, contact_id, created_at, updated_at
-              ),
-
-              new_conversation AS (
-                INSERT INTO conversations (account_id, inbox_id, status, contact_id,
-                  contact_inbox_id, uuid, last_activity_at, created_at, updated_at)
-                SELECT $1, $2, 0, new_contact_inbox.contact_id, new_contact_inbox.id, gen_random_uuid(),
-                  new_contact_inbox.updated_at, new_contact_inbox.created_at, new_contact_inbox.updated_at
-                FROM new_contact_inbox
-                RETURNING id, contact_id
-              )
-
-              SELECT new_contact.phone_number, new_conversation.contact_id, new_conversation.id AS conversation_id
-              FROM new_conversation 
-              JOIN new_contact ON new_conversation.contact_id = new_contact.id
-
-              UNION
-
-              SELECT p.phone_number, c.id contact_id, con.id conversation_id
-                FROM phone_number p
-              JOIN contacts c ON c.phone_number = p.phone_number
-              JOIN contact_inboxes ci ON ci.contact_id = c.id AND ci.inbox_id = $2
-              JOIN conversations con ON con.contact_inbox_id = ci.id AND con.account_id = $1
-                AND con.inbox_id = $2 AND con.contact_id = c.id`;
-
-    const fksFromChatwoot = await pgClient.query(sqlFromChatwoot, bindValues);
-
-    return new Map(fksFromChatwoot.rows.map((item: FksChatwoot) => [item.phone_number, item]));
+      }
+
+      resultMap.set(rawPhone, {
+        phone_number: normalizedWith,
+        contact_id: String(contact.id),
+        conversation_id: String(conversationId)
+      });
+    }
+
+    return resultMap;
   }
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
   public async getChatwootUser(provider: ChatwootModel): Promise<ChatwootUser> {
     try {
       const pgClient = postgresClient.getChatwootConnection();
@@ -503,16 +688,14 @@ class ChatwootImport {
 
     switch (typeKey) {
       case 'documentMessage':
-        return `_<File: ${msg.message.documentMessage.fileName}${
-          msg.message.documentMessage.caption ? ` ${msg.message.documentMessage.caption}` : ''
-        }>_`;
+        return `_<File: ${msg.message.documentMessage.fileName}${msg.message.documentMessage.caption ? ` ${msg.message.documentMessage.caption}` : ''
+          }>_`;
 
       case 'documentWithCaptionMessage':
-        return `_<File: ${msg.message.documentWithCaptionMessage.message.documentMessage.fileName}${
-          msg.message.documentWithCaptionMessage.message.documentMessage.caption
-            ? ` ${msg.message.documentWithCaptionMessage.message.documentMessage.caption}`
-            : ''
-        }>_`;
+        return `_<File: ${msg.message.documentWithCaptionMessage.message.documentMessage.fileName}${msg.message.documentWithCaptionMessage.message.documentMessage.caption
+          ? ` ${msg.message.documentWithCaptionMessage.message.documentMessage.caption}`
+          : ''
+          }>_`;
 
       case 'templateMessage':
         return msg.message.templateMessage.hydratedTemplate.hydratedTitleText
@@ -536,8 +719,12 @@ class ChatwootImport {
     }
   }
 
-  public sliceIntoChunks(arr: any[], chunkSize: number) {
-    return arr.splice(0, chunkSize);
+  public sliceIntoChunks<T>(arr: T[], chunkSize: number): T[][] {
+    const chunks: T[][] = [];
+    for (let i = 0; i < arr.length; i += chunkSize) {
+      chunks.push(arr.slice(i, i + chunkSize));
+    }
+    return chunks;
   }
 
   public isGroup(remoteJid: string) {
@@ -555,6 +742,42 @@ class ChatwootImport {
 
     return pgClient.query(sql, [`WAID:${sourceId}`, messageId]);
   }
+
+  private async safeRefreshConversation(
+    providerUrl: string,
+    accountId: string,
+    conversationId: string,
+    apiToken: string
+  ): Promise<void> {
+    try {
+      const pgClient = postgresClient.getChatwootConnection();
+      const res = await pgClient.query(
+        `SELECT display_id
+           FROM conversations
+          WHERE id = $1
+          LIMIT 1`,
+        [parseInt(conversationId, 10)]
+      );
+      const displayId = res.rows[0]?.display_id as string;
+      if (!displayId) {
+        this.logger.warn(`Conversation ${conversationId} sem display_id.`);
+        return;
+      }
+
+      const url = `${providerUrl}/api/v1/accounts/${accountId}/conversations/${displayId}/refresh`;
+      await axios.post(url, null, {
+        params: { api_access_token: apiToken },
+      });
+      this.logger.verbose(`Conversa ${displayId} refreshada com sucesso.`);
+    } catch (err: any) {
+      this.logger.warn(
+        `Não foi possível dar refresh na conversa ${conversationId}: ${err.message}`
+      );
+    }
+  }
+  
+
+  
 }
 
 export const chatwootImport = new ChatwootImport();
diff --git a/src/api/integrations/storage/s3/libs/minio.server.ts b/src/api/integrations/storage/s3/libs/minio.server.ts
index 5a66305c..19128af9 100644
--- a/src/api/integrations/storage/s3/libs/minio.server.ts
+++ b/src/api/integrations/storage/s3/libs/minio.server.ts
@@ -40,22 +40,38 @@ const bucketExists = async () => {
 };
 
 const setBucketPolicy = async () => {
-  if (minioClient) {
-    const policy = {
-      Version: '2012-10-17',
-      Statement: [
-        {
-          Effect: 'Allow',
-          Principal: '*',
-          Action: ['s3:GetObject'],
-          Resource: [`arn:aws:s3:::${bucketName}/*`],
-        },
-      ],
-    };
+  if (!minioClient) return;
+
+  const policy = {
+    Version: '2012-10-17',
+    Statement: [
+      {
+        Effect: 'Allow',
+        Principal: '*',
+        Action: ['s3:GetObject'],
+        Resource: [`arn:aws:s3:::${bucketName}/*`],
+      },
+    ],
+  };
+
+  try {
     await minioClient.setBucketPolicy(bucketName, JSON.stringify(policy));
+    console.log(`[S3 Service] Bucket policy aplicada em ${bucketName}`);
+  } catch (err: any) {
+    // MinIO não implementa esse endpoint
+    if (err.code === 'NotImplemented') {
+      console.warn(
+        `[S3 Service] setBucketPolicy não suportado por este endpoint, ignorando (bucket=${bucketName})`
+      );
+    } else {
+      // qualquer outro erro real, relança
+      console.error('[S3 Service] Erro ao aplicar bucket policy', err);
+      throw err;
+    }
   }
 };
 
+
 const createBucket = async () => {
   if (minioClient) {
     try {
diff --git a/src/api/services/cache.service.ts b/src/api/services/cache.service.ts
index e2f96d4b..d884362d 100644
--- a/src/api/services/cache.service.ts
+++ b/src/api/services/cache.service.ts
@@ -42,7 +42,10 @@ export class CacheService {
     if (!this.cache) {
       return;
     }
-    this.cache.set(key, value, ttl);
+
+    const effectiveTtl = ttl ?? (2 * 60 * 60);
+
+    this.cache.set(key, value, effectiveTtl);
   }
 
   public async hSet(key: string, field: string, value: any) {
@@ -69,6 +72,20 @@ export class CacheService {
     if (!this.cache) {
       return;
     }
+    // Verifica se a chave é realmente uma string
+    if (typeof key !== 'string') {
+      this.logger.error(
+        `Invalid cache key type: expected string but received ${typeof key}. Key content: ${JSON.stringify(key)}. Stack trace: ${new Error().stack}`
+      );
+    } else {
+      // Opcional: se a chave contiver quebras de linha, pode ser um sinal de que há um vCard em vez de um simples identificador
+      if (key.includes('\n')) {
+        this.logger.error(
+          `Invalid cache key format (contains newline characters): ${key}. Stack trace: ${new Error().stack}`
+        );
+      }
+    }
+    // Chama a implementação real do delete
     return this.cache.delete(key);
   }
 
